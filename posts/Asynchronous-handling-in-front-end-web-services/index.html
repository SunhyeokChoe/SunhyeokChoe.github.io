<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="프론트엔드 웹 서비스에서 우아하게 비동기 처리하기" /><meta name="author" content="SunhyeokChoe" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="API를 호출하거나 네이티브 앱과 통신할 때 프론트엔드 웹 서비스에서는 반드시 비동기 작업이 일어나게 됩니다. 일상처럼 다루고 있지만 정작 UI에서 다루기 힘든 비동기 프로그래밍. React Suspense를 이용하여 우아하게 처리하는 이론과 실전 적용법을 공유합니다." /><meta property="og:description" content="API를 호출하거나 네이티브 앱과 통신할 때 프론트엔드 웹 서비스에서는 반드시 비동기 작업이 일어나게 됩니다. 일상처럼 다루고 있지만 정작 UI에서 다루기 힘든 비동기 프로그래밍. React Suspense를 이용하여 우아하게 처리하는 이론과 실전 적용법을 공유합니다." /><link rel="canonical" href="https://sunhyeokchoe.github.io/posts/Asynchronous-handling-in-front-end-web-services/" /><meta property="og:url" content="https://sunhyeokchoe.github.io/posts/Asynchronous-handling-in-front-end-web-services/" /><meta property="og:site_name" content="Sunhyeok Choe" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-05T11:50:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="프론트엔드 웹 서비스에서 우아하게 비동기 처리하기" /><meta name="twitter:site" content="@SunhyeokChoe" /><meta name="twitter:creator" content="@SunhyeokChoe" /><meta name="google-site-verification" content="oz2h83RZgafkaSK760iGMC02_eS2Dv7i4EdGDt1owoI" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"SunhyeokChoe"},"dateModified":"2022-01-12T17:09:30+09:00","datePublished":"2021-10-05T11:50:00+09:00","description":"API를 호출하거나 네이티브 앱과 통신할 때 프론트엔드 웹 서비스에서는 반드시 비동기 작업이 일어나게 됩니다. 일상처럼 다루고 있지만 정작 UI에서 다루기 힘든 비동기 프로그래밍. React Suspense를 이용하여 우아하게 처리하는 이론과 실전 적용법을 공유합니다.","headline":"프론트엔드 웹 서비스에서 우아하게 비동기 처리하기","mainEntityOfPage":{"@type":"WebPage","@id":"https://sunhyeokchoe.github.io/posts/Asynchronous-handling-in-front-end-web-services/"},"url":"https://sunhyeokchoe.github.io/posts/Asynchronous-handling-in-front-end-web-services/"}</script><title>프론트엔드 웹 서비스에서 우아하게 비동기 처리하기 | Sunhyeok Choe</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sunhyeok Choe"><meta name="application-name" content="Sunhyeok Choe"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/profile/thumbnail.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sunhyeok Choe</a></div><div class="site-subtitle font-italic">Dev Notes</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/SunhyeokChoe" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/SunhyeokChoe" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hackerwreckers','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>프론트엔드 웹 서비스에서 우아하게 비동기 처리하기</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>프론트엔드 웹 서비스에서 우아하게 비동기 처리하기</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/SunhyeokChoe">SunhyeokChoe</a> </em></div><div class="d-flex"><div> <span> 게시일 <em class="timeago" data-ts="1633402200" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2021-10-05 </em> </span> <span> 업데이트 <em class="timeago" data-ts="1641974970" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-01-12 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5359 단어"> <em>29 분</em> 읽는 시간 소요</span></div></div></div><div class="post-content"><p>API를 호출하거나 네이티브 앱과 통신할 때 프론트엔드 웹 서비스에서는 반드시 비동기 작업이 일어나게 됩니다. 일상처럼 다루고 있지만 정작 UI에서 다루기 힘든 비동기 프로그래밍. React Suspense를 이용하여 우아하게 처리하는 이론과 실전 적용법을 공유합니다.</p><h2 id="토스의-프로젝트-구조"><span class="mr-2">토스의 프로젝트 구조</span><a href="#토스의-프로젝트-구조" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>토스 앱 내에서 WebView를 이용해 iOS/Android 공통의 웹 서비스를 개발하고 있음<li>60개 이상의 크고 작은 활성 서비스가 웹 기술을 이용하여 개발되고 있음<li>그 외의 홈페이지나 토스증권, 토스페이먼츠, 토스인슈어런스 등의 서비스는 100% 웹 기술을 이용해서 개발되고 있음<li>토스 앱 안에서는 주식 탭, 혜택 탭 등이 대표적으로 웹 서비스를 이용해서 개발된 서비스임<li>이렇게 많은 서비스들은 마이크로프론트엔드 아키텍처(<strong>모노레포</strong>)를 이용해서 같은 레포지토리 안에서 독립적으로 개발/배포되고 있음<li>모든 서비스들은 React, TypeScript, Next.js 기술 스택을 공유하고 있고, 구체적인 로직만 다르게 가져가고 있음</ul><h2 id="웹-서비스-ui-개발에서-가장-다루기-어려운-부분은"><span class="mr-2">웹 서비스, UI 개발에서 가장 다루기 어려운 부분은?</span><a href="#웹-서비스-ui-개발에서-가장-다루기-어려운-부분은" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>웹에서는 10여년 전 JQuery를 활용해서 명령형으로 프로그래밍을 하다가 React/Vue.js와 같이 선언적인 프로그래밍을 지원하는 프레임워크들이 나오면서 각각의 개발자가 신경써야 하는 부분들이 많이 줄었다.</p><p>그럼에도 아직까지 다루기 어려운 영역을 하나 꼽아보자면 <strong>비동기 프로그래밍</strong>을 꼽을 수 있다. 비동기 프로그래밍은 ‘순서가 보장되지 않는 상황’으로 요약할 수 있다.</p><p>비동기 프로그래밍은 끊기지 않는 60프레임의 좋은 사용자 경험을 위해서는 필수이고, JavaScript에서는 Callback, Promise, Observable(using RxJs)과 같이 다양한 도구를 이용해서 비동기적인 상황을 다루고 있다.</p><p>그럼에도 불구하고 여전히 다루기가 어렵다.</p><p>이유는 뭘까?</p><h2 id="좋은-코드에-대해-돌아보자"><span class="mr-2">좋은 코드에 대해 돌아보자</span><a href="#좋은-코드에-대해-돌아보자" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>이 코드의 문제점은 무엇일까?</p><div class="language-jsx highlighter-rouge"><div class="code-header"> <span data-label-text="Jsx"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">getBazFromX</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">foo</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="nx">x</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">bar</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nx">x</span><span class="p">.</span><span class="nx">foo</span><span class="p">.</span><span class="nx">bar</span><span class="p">.</span><span class="nx">baz</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>하는 일은 단순하지만 코드가 너무 복잡하다.<li>각 프로퍼티에 접근하는 핵심 기능이 코드로 잘 드러나지 않는다.</ul><p>이 함수가 하는 일을 요약한다면, x.foo.bar.baz 라고 하는 프로퍼티에 안전하게 접근하는 일인데, 함수가 하는 일이 명확하게 드러난다기 보다는 ‘x가 없는지 검사한다.’, ‘x.foo가 없는지 검사한다.’, ‘x.foo.bar’가 없는지 검사한다’와 같이 명령어의 노이즈가 많아 함수가 어떤 역할을 하는지 명확하게 드러나지 않는다.</p><p>이를 해결하기 위해 최근 ECMAScript에 추가된 Optional Chaining 문법을 활용한 동일한 함수를 살펴보자.</p><div class="language-jsx highlighter-rouge"><div class="code-header"> <span data-label-text="Jsx"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">getBazFromX</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">x</span><span class="p">?.</span><span class="nx">foo</span><span class="p">?.</span><span class="nx">bar</span><span class="p">?.</span><span class="nx">baz</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>일전의 비효율적인 함수와 다른점이 무엇일까?</p><ul><li>‘성공한 경우’를 생각하는 x.foo.bar.baz와 문법적 차이가 크지 않다.<li>함수의 역할을 한눈에 파악할 수 있다.</ul><p>우선 함수가 하는 일을 흐리게 만들던 if문들이 사라져 코드가 간결해진 덕분에 어떤 역할을 하는 함수인지 한눈에 확인할 수 있다.</p><p>또한, 잘 살펴보면 Nullable이 아닐 때, 즉 성공할 때 접근하는 모습을 나타내는 x.foo.bar.baz라고 하는 표현식과 모양이 큰 차이가 없는 것도 확인할 수 있다.</p><p>같은 역할을 하는 식이 비슷하게 표현된다는 것은 코드에 있어서 좋은 징조 중 하나이다.</p><p>더 복잡한 예제를 살펴보자.</p><p>이 코드의 문제점은 무엇일까?</p><p>(JavaScript에 Promise가 없던 시절 비동기를 처리하기 위해 callback을 사용했던 코드)</p><div class="language-jsx highlighter-rouge"><div class="code-header"> <span data-label-text="Jsx"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">fetchAccounts</span><span class="p">(</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fetchUserEntity</span><span class="p">((</span><span class="nx">err</span><span class="p">,</span> <span class="nx">user</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="nx">callback</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="nx">fetch</span><span class="p">(</span><span class="nx">UserAccounts</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">no</span><span class="p">,</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">accounts</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="nx">err</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">callback</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="kc">null</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">{</span>

			<span class="nx">callback</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">accounts</span><span class="p">);</span>
		<span class="p">});</span>
	<span class="p">});</span>
<span class="p">}</span>
</pre></table></code></div></div><p>fetchUserEntity를 호출해서 그 결과를 Callback으로 받는데, 에러가 있으면 에러를 Emit한다.</p><p>그리고 그 결과값을 이용해서 사용자의 계좌 목록을 가져오는데, 마찬가지로 에러가 있으면 에러를 Emit하고, 그렇지 않을 경우 실제값을 Emit 한다.</p><ul><li>‘성공하는 경우’와 ‘실패하는 경우’가 섞여서 처리된다.<li>코드를 작성하는 입장에서 매번 에러 유무를 확인해야 한다.</ul><p>이 함수를 요약하자면, user를 가져오고, 그 정보를 바탕으로 accounts를 가져오고, 그 값을 반환하는 역할이다. 중간에 ‘실패하는 경우’에 대한 처리가 섞여 있어서 함수가 하는 진짜 역할이 가려졌다(노이즈).</p><p>또한, 코드를 작성하는 입장에서 매번 비동기 호출을 할 때마다 에러 처리를 해줘야 한다는 점이 불편한 점 중 하나라고 할 수 있다.</p><p>이를 해결하기 위해 async-await 문법을 활용해보자.</p><div class="language-jsx highlighter-rouge"><div class="code-header"> <span data-label-text="Jsx"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">async</span> <span class="kd">function</span> <span class="nx">fetchAccounts</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetchUserEntity</span><span class="p">();</span>
	<span class="kd">const</span> <span class="nx">accounts</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">fetchUserAccounts</span><span class="p">(</span><span class="nx">user</span><span class="p">.</span><span class="nx">no</span><span class="p">);</span>
	<span class="k">return</span> <span class="nx">accounts</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>왜 이 코드를 좋은 코드라고 말할 수 있을까?</p><ul><li>‘성공하는 경우’만 다루고, ‘실패하는 경우’는 catch 절에서 분리해서 처리한다.<li>‘실패하는 경우’에 대한 처리를 외부에 위임할 수 있다.</ul><p>비동기 요청을 통해 ‘성공하는 경우’들만 모아서 살펴볼 수 있기에 함수가 하는 역할이 명확히 드러난다. 동기적인 코드가 외견적으로는 큰 차이가 없다.</p><p>또한, 별도로 에러를 처리하는 부분이 없고 모든 에러 처리는 외부에 위임된다라고 하는 점도 좋은 코드임을 드러내는 부분 중 하나이다.</p><p>좋은 코드의 특징</p><ul><li>성공, 실패의 경우를 분리해 처리할 수 있다.<li>비즈니스 로직을 한눈에 파악할 수 있다.</ul><p>함수에는 성공하는 경우들만 적혀 있으니 읽기도 쉽고, 함수의 책임이 명확히 드러난다.</p><p>어려운 코드의 특징</p><ul><li>실패, 성공의 경우가 서로 섞여 처리된다.<li>비즈니스 로직을 파악하기 어렵다.</ul><p>‘실패하는 경우’와 ‘성공하는 경우’가 섞여서 처리된다는 점이 함수의 책임을 알아보기 어렵게 한다. 덕분에 함수의 크기가 커지고, 하는 역할이 명시적으로 드러나지 못한다.</p><h2 id="프론트엔드-웹-서비스에서-비동기-처리는-지금까지-어땠는가"><span class="mr-2">프론트엔드 웹 서비스에서 비동기 처리는 지금까지 어땠는가?</span><a href="#프론트엔드-웹-서비스에서-비동기-처리는-지금까지-어땠는가" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>우리는 보통 API 호출과 같은 상황을 처리할 때 어떻게 처리했을까?</p><p><strong>in React</strong></p><p>API 호출</p><div class="language-jsx highlighter-rouge"><div class="code-header"> <span data-label-text="Jsx"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">const</span> <span class="p">{</span> <span class="nx">data</span><span class="p">,</span> <span class="nx">error</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">useAsyncValue</span><span class="p">(()</span> <span class="err">⇒</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">fetchSomething</span><span class="p">();</span>
<span class="p">});</span>
</pre></table></code></div></div><p>SWR이나 react-query와 같은 라이브러리를 많이 활용했다.</p><p>Promise를 반환하는 함수를 React Hook의 인자로 넘기고, Promise의 상태 변화에 따라 Hook이 반환하는 data, error의 값을 적절히 채워주는 것이다.</p><p>그리고 아래와 같이 컴포넌트를 작성하고는 했다.</p><p>컴포넌트 처리</p><div class="language-jsx highlighter-rouge"><div class="code-header"> <span data-label-text="Jsx"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">Profile</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">useAsyncValue</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fetchFoo</span><span class="p">();</span>
	<span class="p">});</span>

	<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">error</span><span class="p">)</span> <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>로딩에 실패했습니다.<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">foo</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>로딩 중입니다.<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
	<span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">foo</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span>님 안녕하세요!<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>이 함수를 살펴보면, 비동기인 foo를 가져오는데, foo가 에러이면 실패 메시지를 보여주고, foo가 없으면 로딩중이라고 보여주고, foo가 있으면 안녕하세요 라고 하는 메시지를 보여주는 식이다.</p><p>위 코드는 다음과 같은 문제점이 있다.</p><ul><li>‘성공하는 경우’와 ‘실패하는 경우’가 섞여서 처리된다.<li>‘실패하는 경우’에 대한 처리를 위부에 위임하기 어렵다.</ul><p><strong>이러한 문제는 여러 개의 비동기 작업이 동시에 실행될 때 심각한 일이 발생한다!</strong></p><p>방금 전에 봤던 callback 코드와 비슷하게 코드가 점점 읽기 어려워지는 것이다.</p><p>한번 코드를 살펴보자. (foo와 bar 값을 비동기로 가져오는 함수)</p><div class="language-jsx highlighter-rouge"><div class="code-header"> <span data-label-text="Jsx"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cm">/* 비동기 코드 지옥 */</span>

<span class="kd">function</span> <span class="nx">Profile</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">useAsyncValue</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fetchFoo</span><span class="p">();</span>
	<span class="p">});</span>

	<span class="kd">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">useAsyncValue</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">error</span> <span class="o">||</span> <span class="o">!</span><span class="nx">foo</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="nx">fetchBar</span><span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">data</span><span class="p">);</span>
	<span class="p">});</span>

	<span class="k">if</span> <span class="p">(</span><span class="nx">foo</span><span class="p">.</span><span class="nx">error</span> <span class="o">||</span> <span class="nx">bar</span><span class="p">.</span><span class="nx">error</span><span class="p">)</span> <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>로딩에 실패했습니다.<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">foo</span><span class="p">.</span><span class="nx">data</span> <span class="o">||</span> <span class="o">!</span><span class="nx">bar</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span> <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>로딩 중입니다.<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
	<span class="k">return</span> <span class="cm">/* foo와 bar로 적합한 처리하기 */</span>
<span class="p">}</span>
</pre></table></code></div></div><p>bar를 가져오기 위해서는 foo가 있어야 한다.</p><p>결국 bar는 foo가 로드될 때까지 기다리고, if문은 복잡해지고… 그냥 복잡하다.</p><p>보통은 하나의 비동기 작업은 <strong>(로딩중 / 에러 / 완료됨)</strong> 3가지의 상태를 가지고 있다.</p><p><img data-src="/assets/img/2021-10-05/Three states of async job.png" alt="Three states of async job" data-proofer-ignore> <em>Three states of async job</em></p><p>만약에 2개의 비동기 작업이 있다면, 3^2=9가지의 상태를 가질 수 있다는 것을 생각할 수 있다.</p><p>그렇다면 비동기 호출이 3개, 4개가 된다면 더욱 복잡해질 것이다.</p><p><strong>React의 비동기 처리는 어렵다</strong>는 내용을 간략화 하자면</p><ul><li>성공하는 경우에만 집중해 컴포넌트를 구성하기 어렵다.<li>2개 이상의 비동기 로직이 개입할 때, 비즈니스 로직을 파악하기 점점 어려워진다.</ul><p>React에서 지금까지 살펴보았던 Hook이나 State를 사용하는 방식으로는 이렇게 간단히 비동기 처리를 할 수가 없다.</p><p><strong>다행히도 이 문제를 우아하게 해결해주는 도구가 있다!</strong></p><h2 id="react-팀이-제안하는-react-suspense-for-data-fetching"><span class="mr-2">React 팀이 제안하는 “React Suspense for Data Fetching”</span><a href="#react-팀이-제안하는-react-suspense-for-data-fetching" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>한국어로 번역하자면 “데이터를 가져오기 위한 Suspense”라고 한다. 아직은 React의 experimental, 즉 실험 버전에서만 사용할 수 있다.</p><p>React Suspense for Data Fetching이 목표로 하는 코드는 간단하다. 쉽게 말해 async-await 급으로 비동기를 처리하면서 간단하고 읽기 편한 React 컴포넌트를 만들겠다고 하는 것이다. 다시 말해, 컴포넌트는 성공한 상태만 다루고, 로딩 상태와 에러 상태는 외부에 위임함으로써 동기적인 코드와 큰 차이가 없는 코드를 만들겠다는 비전이다.</p><p>실제로 아래와 같이 FooBar 컴포넌트의 useAsyncValue를 동기적인 계산을 하는 useMemo로 거의 그대로 치환하면, 완벽히 똑같은 구조를 가지고 있는 것을 확인할 수 있다.</p><div class="language-jsx highlighter-rouge"><div class="code-header"> <span data-label-text="Jsx"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cm">/* useAsyncValue 버전 */</span>
<span class="kd">function</span> <span class="nx">FooBar</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">useAsyncValue</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">fetchFoo</span><span class="p">());</span>
	<span class="kd">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">useAsyncValue</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">fetchBar</span><span class="p">());</span>

	<span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">foo</span><span class="si">}{</span><span class="nx">bar</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">}</span>

<span class="cm">/* useMemo 버전 */</span>
<span class="kd">function</span> <span class="nx">FooBar</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">foo</span> <span class="o">=</span> <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">fetchFoo</span><span class="p">());</span>
	<span class="kd">const</span> <span class="nx">bar</span> <span class="o">=</span> <span class="nx">useMemo</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">fetchBar</span><span class="p">());</span>

	<span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">foo</span><span class="si">}{</span><span class="nx">bar</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>React Suspense for Data Fetching은 이러한 useAsyncValue와 같은 hook을 만들 수 있는 Low-level API를 제공한다.</p><p>만약에 비동기 작업을 아래와 같이 처리한다면, 로딩 상태나 에러 상태는 어떻게 처리해야 할까?</p><div class="language-html highlighter-rouge"><div class="code-header"> <span data-label-text="HTML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nt">&lt;ErrorBoundary</span> <span class="na">fallback=</span><span class="s">{&lt;MyErrorPage</span> <span class="nt">/&gt;</span>}&gt;
	<span class="nt">&lt;Suspense</span> <span class="na">fallback=</span><span class="s">{&lt;Loader</span> <span class="nt">/&gt;</span>}&gt;
		<span class="nt">&lt;FooBar</span> <span class="nt">/&gt;</span>
	<span class="nt">&lt;/Suspense&gt;</span>
<span class="nt">&lt;/ErrorBoundary&gt;</span>
</pre></table></code></div></div><p>함수의 에러 처리를 감싸는 catch 문에서 하는 것처럼 로딩 상태와 에러 처리도 컴포넌트를 쓰는 곳에서 처리해주면 된다.</p><ul><li>컴포넌트를 ‘쓰는 쪽’에서 로딩 처리와 에러를 처리한다.<li>로딩 상태는 가장 가까운 ‘Suspense’의 ‘Fallback’으로 그려진다.<li>에러 상태는 가장 가까운 ‘ErrorBoundary’가 componentDidCatch()로 처리한다.</ul><p>방금 작성한 ErrorBoundary/Suspense를 살펴보면 다음과 같은 코드와 거의 유사하다</p><div class="language-jsx highlighter-rouge"><div class="code-header"> <span data-label-text="Jsx"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">try</span> <span class="p">{</span>
	<span class="k">await</span> <span class="nx">fetchFooBar</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// 에러 처리</span>
<span class="p">}</span>
</pre></table></code></div></div><p>비동기 콜을 하는 함수나 컴포넌트가 가운데에 있고, 실패하는 경우를 처리하는 부분이 그 부분을 감싸고 있다.</p><p>ex) ErrorBoundary 컴포넌트가 Suspense와 FooBar 컴포넌트를 감싸고 있음</p><p>ex) 비동기 함수 fetchFooBar를 call하는 부분을 try…catch로 감싸고 있음</p><p>우리가 모든 실패할 수 있는 함수에 try…catch를 감싸지 않는 것처럼, Suspense를 일으키는 모든 컴포넌트에 Suspense나 ErrorBoundary를 붙여주기보다는 적당한 부분 단위로 에러와 로딩 상태를 한 번에 처리하게 된다.</p><p>예를 들어 아래 코드는 App 전체에서 로딩 상태와 에러 상태를 처리해주는 핸들러를 선언한 것이다.</p><div class="language-html highlighter-rouge"><div class="code-header"> <span data-label-text="HTML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nt">&lt;ErrorBoundary</span> <span class="na">fallback=</span><span class="s">{&lt;ErrorPage</span> <span class="nt">/&gt;</span>}&gt;
	<span class="nt">&lt;Suspense</span> <span class="na">fallback=</span><span class="s">{&lt;Loader</span> <span class="nt">/&gt;</span>}&gt;
		<span class="nt">&lt;App</span> <span class="nt">/&gt;</span>
	<span class="nt">&lt;/Suspense&gt;</span>
<span class="nt">&lt;/ErrorBoundary&gt;</span>
</pre></table></code></div></div><p>이렇게 비동기를 동기적으로 바꿔주는 Suspense 기능을 이용하기는 전혀 어렵지 않다.</p><p>사용하는 라이브러리에서 Suspense를 사용한다고 선언해주면 된다.</p><p><img data-src="/assets/img/2021-10-05/Suspense 지원 라이브러리.png" alt="Suspense 지원 라이브러리" data-proofer-ignore> <em>Suspense 지원 라이브러리</em></p><p>각 라이브러리에서 위와 같은 옵션을 사용하면 자동으로 컴포넌트의 Suspense 상태가 관리된다.</p><p>React Suspense를 사용하면 로딩과 에러 처리를 바깥에 위임하여 비동기 작업을 동기와 똑같이 처리할 수 있었는데, React 팀의 <em>Sebastian</em>이 만들었던 코드 스니펫은 이런 ‘마법’이 어떻게 React에서 구현되어 있는지 보여준다.</p><div class="language-jsx highlighter-rouge"><div class="code-header"> <span data-label-text="Jsx"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cm">/* React Team의 *Sebastian markbage*의 Proof-of-concept */</span>
<span class="kd">function</span> <span class="nx">getUserName</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">fetchTextSync</span><span class="p">(</span><span class="dl">'</span><span class="s1">/users/</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">id</span><span class="p">);</span>
	<span class="k">return</span> <span class="nx">user</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">getGreeting</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="nx">name</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">Seb</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="dl">'</span><span class="s1">Hey</span><span class="dl">'</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">fetchTextSync</span><span class="p">(</span><span class="dl">'</span><span class="s1">/greeting</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">getMessage</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">let</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">getUserName</span><span class="p">(</span><span class="mi">123</span><span class="p">);</span>
	<span class="k">return</span> <span class="nx">getGreeting</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">, </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">name</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">!</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>
<span class="nx">runPureTask</span><span class="p">(</span><span class="nx">getMessage</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">message</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">message</span><span class="p">));</span>
</pre></table></code></div></div><p>runPureTask로 실행시키면 비동기 함수도 동기적으로 작성할 수 있다.</p><p>코드를 살펴보면 fetchTextSync라고 하는 함수는 원래 API 호출으로 비동기 작업이지만, 동기처럼 사용되고 있는 걸 볼 수 있다. 이 모든것을 가능하게 해주는 것은 runPureTask라고 하는 런타임이다.</p><h2 id="토스팀에서-적용한-제품-예시"><span class="mr-2">토스팀에서 적용한 제품 예시</span><a href="#토스팀에서-적용한-제품-예시" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>토스팀에서는 최근에 개발된 서비스 일부를 React Suspense를 활용해서 마이그레이션을 진행하고 있다. 사용 경험이 좋았는데, 대표적으로 적용된 제품은 토스팀의 TUBA라고 하는 제품이다.</p><p><img data-src="/assets/img/2021-10-05/TUBA.png" alt="TUBA" data-proofer-ignore> <em>TUBA</em></p><p>TUBA 제품은 토스 대부분의 데이터가 모이고 분석되는 내부 제품이며, 다양한 A/B 테스트를 설정하거나, 알림이나 푸시를 전송하는 등 다양한 작업을 수행하고 있다.</p><p>토스 앱에서 알림이나 푸시를 보낼 때 토스팀이 사용하는 제품이 바로 ‘TUBA 메신저’ 인데, TUBA 메신저의 메시지 상세 화면에서는 상당히 복잡한 비동기 처리가 필요했다.</p><p><img data-src="/assets/img/2021-10-05/직관성을 떨어뜨리는 다양한 비동기 리소스.png" alt="직관성을 떨어뜨리는 다양한 비동기 리소스" data-proofer-ignore> <em>직관성을 떨어뜨리는 다양한 비동기 리소스</em></p><p>API 호출로 가져와야 하는 부분들이 이렇게나 다양했다.</p><p>어떤 메시지였는지, 메시지의 내용이 무엇인지, 발송 일정이 뭔지, 통계 정보가 어떻게 나왔는지 등 다양한 데이터를 복잡한 조건 하에 가져와야 하는 니즈가 있었다.</p><p><strong>토스는 이런 문제를 Recoil의 비동기 셀렉터를 이용해 해결할 수 있었다!</strong></p><p>Recoil에서는 비동기 리소스를 다음과 같이 selector 또는 selectorFamilty로 정의할 수 있다.</p><div class="language-jsx highlighter-rouge"><div class="code-header"> <span data-label-text="Jsx"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">export</span> <span class="kd">const</span> <span class="nx">templateSetSelector</span> <span class="o">=</span> <span class="nx">selectorFamily</span><span class="p">({</span>
		<span class="na">key</span><span class="p">:</span> <span class="dl">'</span><span class="s1">@messages/template-set</span><span class="dl">'</span><span class="p">,</span>
		<span class="na">get</span><span class="p">:</span> <span class="p">(</span><span class="na">no</span><span class="p">:</span> <span class="nx">number</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">fetchTemplateSet</span><span class="p">(</span><span class="nx">no</span><span class="p">);</span>
	<span class="p">},</span>
<span class="p">});</span>
</pre></table></code></div></div><p>templateSetSelector는 no라고 하는 번호를 인자로 받아 fetchTemplateSet이라고 하는 비동기 호출을 보내는 것을 볼 수 있다.</p><p>이렇게 정의한 비동기 리소스를 useRecoilValue를 이용해서 가져오려고 하면 Suspense가 발생하게 된다.</p><div class="language-jsx highlighter-rouge"><div class="code-header"> <span data-label-text="Jsx"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">function</span> <span class="nx">TemplateSetDetails</span><span class="p">({</span> <span class="nx">templateSetNo</span> <span class="p">}:</span> <span class="nx">Props</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">templateSet</span> <span class="o">=</span> <span class="nx">useRecoilValue</span><span class="p">(</span><span class="nx">templateSetSelector</span><span class="p">(</span><span class="nx">templateSetNo</span><span class="p">));</span>
	<span class="cm">/* 이 아래에서는 templateSet이 존재하는 것이 타입적으로 완전히 보장됨 */</span>
<span class="p">}</span>
</pre></table></code></div></div><div class="language-html highlighter-rouge"><div class="code-header"> <span data-label-text="HTML"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nt">&lt;Suspense</span> <span class="na">fallback=</span><span class="s">{&lt;Skeleton</span> <span class="nt">/&gt;</span>}&gt;
	<span class="nt">&lt;TemplateSetDetails</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/Suspense&gt;</span>
</pre></table></code></div></div><p>이렇게 비동기 호출을 하는 컴포넌트를 적절히 Suspense로 감싸주기만 하면 된다.</p><p>사용자 경험 측면에서도 데이터가 준비되는 대로 하나씩 자연스럽게 보여줄 수 있어 좋다고 할 수 있다.</p><h2 id="react-hooks와의-유사도"><span class="mr-2">React Hooks와의 유사도</span><a href="#react-hooks와의-유사도" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>React Suspense 덕분에 많은 비동기적인 문제를 깔끔하고 우아하게 처리할 수가 있게 되었고, 코드의 복잡도도 줄일 수 있었다.</p><p>2년 반 정도 전에 나왔던 React Hooks는 이제 엄청 익숙하지만, 비슷한 역할을 해주고 있다.</p><p>웹 서비스의 코드 복잡도를 줄여주고, 상태, 이펙트와 메모이제이션과 같이 자주 발생하는 작업들을 매우 쉽게 사용할 수 있게 해주었다.</p><p><img data-src="/assets/img/2021-10-05/React Hooks.png" alt="React Hooks" data-proofer-ignore> <em>React Hooks</em></p><p>React Hooks는 어떻게 토스팀 프로젝트 코드의 복잡도를 줄여주었을까?</p><p>그 중 <strong>선언적인 API</strong>의 비중이 굉장히 컸다.</p><p>이전의 클래스 컴포넌트에서는 컴포넌트의 라이프사이클에 맞춰 다양한 작업을 <strong>명령형</strong>으로 해주어야 했지만, Hooks를 사용하면서 상황이 달라졌다.</p><p>useState로 상태를 사용한다고 <strong>선언</strong>하고, useMemo로 메모이제이션을 한다고 <strong>선언</strong>하고, useEffect로 효과를 발생시킨다고 <strong>선언</strong>했다. 이렇게 선언하기만 하면 React 프레임워크가 실제 작업을 대신해주었다.</p><p><img data-src="/assets/img/2021-10-05/Suspense for Data Fetching.png" alt="Suspense for Data Fetching" data-proofer-ignore> <em>Suspense for Data Fetching</em></p><p>Suspense도 비슷하다. 컴포넌트에서는 비동기적인 리소스를 선언하고, 그 값을 읽어온다고 <strong>선언</strong>하기만 한 것이다. 그러면 실제 로딩 상태나 에러 상태처리는 컴포넌트를 감싸는 부모 컴포넌트가 대신해주었다.</p><p>또 비슷한 것이 있다. 바로 우리가 자주 사용하는 try…catch 문이다.</p><p><img data-src="/assets/img/2021-10-05/기존 예외처리 방법.png" alt="기존 예외처리 방법" data-proofer-ignore> <em>기존 예외처리 방법</em></p><p>실패할 수 있는 함수는 throw 문으로 에러를 발생시키고, 실제 에러 처리는 컴포넌트를 감싸는 부모 함수가 수행해주는 것이다.</p><p>이렇게 어떤 코드 조각을 감싸는 맥락으로 책임을 분리하는 방식을 <strong>대수적 효과(Algebraic Effects)</strong>라고 한다. 객체지향의 의존성 주입(DI), 의존성 역전(IoC)과도 유사하다.</p><p>대수적 효과를 지원하는 언어에서 함수는 필요한 코드 조각을 선언적으로 사용한다.</p><p>예를 들면, 메모이제이션이 필요하면 useMemo를 호출하는 식이다. 그러면 <strong>실제로 관련된 처리는 함수를 감싸는 부모 함수나 런타임이 대신 처리하는 형식</strong>이 된다.</p><h2 id="하지-못한-이야기들-react에서-사용자-경험을-더욱-향상시킬-수-있는-react-요소"><span class="mr-2">하지 못한 이야기들 (React에서 사용자 경험을 더욱 향상시킬 수 있는 React 요소)</span><a href="#하지-못한-이야기들-react에서-사용자-경험을-더욱-향상시킬-수-있는-react-요소" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><ul><li>React Concurrent Mode<li>useTransition, useDeferredValue</ul><p>위 요소들을 사용한다면 React에서 컴포넌트 렌더 트리를 부분적으로만 완성함으로써 사용자 경험을 크게 향상시킬 수 있다.</p><p><strong>비동기 작업 뿐만이 아니라 Debounce 등으로 처리하던 무거운 동기적 작업에도 적용할 수 있다.</strong></p><p><br /></p><p><strong><em>Reference</em></strong></p><hr /><ul><li><a href="https://toss.im/slash-21/sessions/3-1"><em>토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기</em></a><li><a href="https://www.youtube.com/watch?v=FvRtoViujGg&amp;t=543s&amp;ab_channel=%ED%86%A0%EC%8A%A4"><em>YouTube</em></a><li><a href="https://ko.reactjs.org/docs/concurrent-mode-suspense.html"><em>데이터를 가져오기 위한 Suspense (실험 단계) (React Suspense for Data Fetching)</em></a><li><em>Dan Abramov</em></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/react/'>React</a>, <a href='/categories/slash21-%ED%86%A0%EC%8A%A4%EA%B0%9C%EB%B0%9C%EC%9E%90%EC%BB%A8%ED%8D%BC%EB%9F%B0%EC%8A%A4/'>SLASH21 - 토스개발자컨퍼런스</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/react-suspense/" class="post-tag no-text-decoration" >React Suspense</a> <a href="/tags/data-fetching/" class="post-tag no-text-decoration" >Data Fetching</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=프론트엔드 웹 서비스에서 우아하게 비동기 처리하기 - Sunhyeok Choe&amp;url=https://sunhyeokchoe.github.io/posts/Asynchronous-handling-in-front-end-web-services/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=프론트엔드 웹 서비스에서 우아하게 비동기 처리하기 - Sunhyeok Choe&amp;u=https://sunhyeokchoe.github.io/posts/Asynchronous-handling-in-front-end-web-services/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://sunhyeokchoe.github.io/posts/Asynchronous-handling-in-front-end-web-services/&amp;text=프론트엔드 웹 서비스에서 우아하게 비동기 처리하기 - Sunhyeok Choe" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Growl-Notification/">[WPF] 팝업 알림창 MVVM 패턴으로 구현하기</a><li><a href="/posts/Contributing-to-a-Project/">[Git] 분산 환경에서 프로젝트에 기여하기</a><li><a href="/posts/Working-with-Remotes/">[Git] 리모트 저장소</a><li><a href="/posts/Branch-Management/">[Git] 브랜치 관리</a><li><a href="/posts/Branching-Workflows/">[Git] 브랜치 워크플로</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dvcs/">DVCS</a> <a class="post-tag" href="/tags/git/">Git</a> <a class="post-tag" href="/tags/github/">Github</a> <a class="post-tag" href="/tags/vcs/">VCS</a> <a class="post-tag" href="/tags/git-branch/">git branch</a> <a class="post-tag" href="/tags/commit-history/">Commit History</a> <a class="post-tag" href="/tags/git-commit/">git commit</a> <a class="post-tag" href="/tags/git-merge/">git merge</a> <a class="post-tag" href="/tags/git-remote/">git remote</a> <a class="post-tag" href="/tags/git-switch/">git switch</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/oneM2M-application-development-procedure-(1)/"><div class="card-body"> <em class="timeago small" data-ts="1645208358" > 2022-02-19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>2. oneM2M 애플리케이션 개발 절차 (1)</h3><div class="text-muted small"><p> 원격 조명 제어 유스케이스 개요 원세종 군은 하루 일과를 마친 후 지친 몸을 이끌고 집으로 귀가했다. 집에 혼자 살고 있기 때문에 귀가했을 때 집 안에 있는 불은 모두 꺼져있는 상황이다. oneM2M 사물 인터넷 서비스를 사용하지 않았던 한달 전까지만 해도, 원세종 군은 귀가 후에 거실, 주방, 화장실 등의 불을 일일이 켜고, 취침 전에는 다시 ...</p></div></div></a></div><div class="card"> <a href="/posts/oneM2M-technical-standards-and-technical-documents/"><div class="card-body"> <em class="timeago small" data-ts="1645196708" > 2022-02-19 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>1. oneM2M 기술규격 및 기술문서 소개</h3><div class="text-muted small"><p> 개요 oneM2M은 에너지, 교통, 국방, 공공서비스 등 산업별로 종속적이고 폐쇄적으로 운영되는, 파편화된 서비스 플랫폼 개발 구조를 벗어나 응용서비스 인프라(플랫폼) 환경을 통합하고 공유하기 위한 사물인터넷 공통서비스 플랫폼 개발을 위해 발족된 사실상 표준화 단체이다. 전세계 지역별 표준 개발 기구인 TTA(한국), ETSI(유럽), ATIS...</p></div></div></a></div><div class="card"> <a href="/posts/Growl-Notification/"><div class="card-body"> <em class="timeago small" data-ts="1645188678" > 2022-02-18 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[WPF] 팝업 알림창 MVVM 패턴으로 구현하기</h3><div class="text-muted small"><p> WPF 앱에서 특정 이벤트 발생시 화면 구석에 Popup Notification이 띄워지도록 해봅시다. 소스는 Growl Alike WPF Notifications 글을 참고해 만들었습니다. MVVM 패턴에 맞도록 변환했고, 앱 전역에서 호출할 수 있도록 정적 Singleton Wrapper 클래스를 정의하였으며, 외부에서 메시지 창 출력 요청시 메시...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <span class="btn btn-outline-primary disabled" prompt="이전 글"><p>-</p></span> <a href="/posts/Getting-Started/" class="btn btn-outline-primary" prompt="다음 글"><p>[Git] 시작하기</p></a></div><script src="https://utteranc.es/client.js" repo="SunhyeokChoe/SunhyeokChoe.github.io" issue-term="url" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/SunhyeokChoe">SunhyeokChoe</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dvcs/">DVCS</a> <a class="post-tag" href="/tags/git/">Git</a> <a class="post-tag" href="/tags/github/">Github</a> <a class="post-tag" href="/tags/vcs/">VCS</a> <a class="post-tag" href="/tags/git-branch/">git branch</a> <a class="post-tag" href="/tags/commit-history/">Commit History</a> <a class="post-tag" href="/tags/git-commit/">git commit</a> <a class="post-tag" href="/tags/git-merge/">git merge</a> <a class="post-tag" href="/tags/git-remote/">git remote</a> <a class="post-tag" href="/tags/git-switch/">git switch</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-0ZQ0CWNMX0"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-0ZQ0CWNMX0'); }); </script>
