<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="[Git] 리모트 브랜치" /><meta name="author" content="SunhyeokChoe" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="리모트 브랜치" /><meta property="og:description" content="리모트 브랜치" /><link rel="canonical" href="https://sunhyeokchoe.github.io/posts/Remote-Branches/" /><meta property="og:url" content="https://sunhyeokchoe.github.io/posts/Remote-Branches/" /><meta property="og:site_name" content="Sunhyeok Choe" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-12T19:46:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Git] 리모트 브랜치" /><meta name="twitter:site" content="@SunhyeokChoe" /><meta name="twitter:creator" content="@SunhyeokChoe" /><meta name="google-site-verification" content="oz2h83RZgafkaSK760iGMC02_eS2Dv7i4EdGDt1owoI" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"SunhyeokChoe"},"dateModified":"2022-01-12T20:15:36+09:00","datePublished":"2022-01-12T19:46:00+09:00","description":"리모트 브랜치","headline":"[Git] 리모트 브랜치","mainEntityOfPage":{"@type":"WebPage","@id":"https://sunhyeokchoe.github.io/posts/Remote-Branches/"},"url":"https://sunhyeokchoe.github.io/posts/Remote-Branches/"}</script><title>[Git] 리모트 브랜치 | Sunhyeok Choe</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sunhyeok Choe"><meta name="application-name" content="Sunhyeok Choe"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/profile/thumbnail.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sunhyeok Choe</a></div><div class="site-subtitle font-italic">Dev Notes</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/SunhyeokChoe" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/SunhyeokChoe" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hackerwreckers','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[Git] 리모트 브랜치</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Git] 리모트 브랜치</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/SunhyeokChoe">SunhyeokChoe</a> </em></div><div class="d-flex"><div> <span> 게시일 <em class="timeago" data-ts="1641984360" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-01-12 </em> </span> <span> 업데이트 <em class="timeago" data-ts="1641986136" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-01-12 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4285 단어"> <em>23 분</em> 읽는 시간 소요</span></div></div></div><div class="post-content"><h2 id="리모트-브랜치"><span class="mr-2">리모트 브랜치</span><a href="#리모트-브랜치" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>리모트의 <strong>Refs</strong>는 리모트 저장소에 있는 포인터이자 레퍼런스이며 리모트 저장소에 있는 브랜치, 태그 등등을 의미한다. <code class="language-plaintext highlighter-rouge">git ls-remote &lt;remote-name&gt;</code> 명령으로 특정 리모트 혹은 모든 리모트 Refs를 조회할 수 있다. <code class="language-plaintext highlighter-rouge">git remote show &lt;remote-name&gt;</code> 명령은 특정 혹은 모든 리모트 브랜치의 정보를 보여준다. 리모트 Refs가 있지만 <strong>보통은 리모트 트래킹 브랜치를 사용한다</strong>.</p><p><strong>리모트 트래킹 브랜치</strong>는 브랜치를 추적하는 레퍼런스이며 브랜치다. 리모트 트래킹 브랜치는 로컬에 있지만 임의로 움직일 수 없다. 리모트 서버에 연결할 때마다 리모트의 브랜치 업데이트 내용에 따라서 자동으로 갱신될 뿐이다. 리모트 트래킹 브랜치는 일종의 북마크라고 할 수 있다. 리모트 저장소에 마지막으로 연결했던 순간에 브랜치가 무슨 커밋을 가리키고 있는지를 나타낸다.</p><p>리모트 트래킹 브랜치의 이름은 <code class="language-plaintext highlighter-rouge">&lt;remote-name&gt;/&lt;branch-name&gt;</code> 형식으로 되어 있다. 예를 들어 리모트 저장소 origin의 master 브랜치를 보고 싶다면 origin/master 라는 이름으로 브랜치를 확인하면 된다. 다른 팀원과 함께 어떤 이슈를 해결해 나아갈 때 그 팀원이 iss53 브랜치를 서버로 Push했고 당신도 로컬에 iss53 브랜치가 있다고 가정하자. 이때 서버의 iss53 브랜치가 가리키는 커밋은 로컬에서 origin/iss53이 가리키는 커밋이다.</p><p>다소 헷갈릴 수 있으니 다음 예제를 살펴보자. git.ourcompany.com 이라는 Git 서버가 있고 이 서버의 저장소를 하나 Clone 하면 Git은 자동으로 origin 이라는 이름을 붙인다. origin으로부터 저장소 데이터를 모두 내려받고 master 브랜치를 가리키는 포인터를 만든다. 이 포인터는 origin/master 라고 부르고 멋대로 조종할 수 없다. 그리고 Git은 로컬의 master 브랜치가 리모트의 origin/master 브랜치를 가리키게 한다. 이제 이 master 브랜치에서 작업을 시작할 수 있다.</p><blockquote><p><strong>origin의 의미</strong></p><p>브랜치 이름으로 많이 사용하는 master 라는 이름이 괜히 특별한 의미를 가지는 게 아닌 것처럼 origin도 특별한 의미가 있는 것은 아니다. <code class="language-plaintext highlighter-rouge">git init</code> 명령이 자동으로 만들기 때문에 사용하는 이름인 master 와 마찬가지로 origin 도 <code class="language-plaintext highlighter-rouge">git clone</code> 명령이 자동으로 만들어주는 리모트 이름이다. <code class="language-plaintext highlighter-rouge">git clone -o mooyaho</code> 라고 옵션을 주고 명령을 실행하면 mooyaho/master 라고 사용자가 지정한 리모트 이름을 생성해준다.</p></blockquote><p><img data-src="/assets/img/2022-01-12/Git/Remote Branches/Clone 이후 서버와 로컬의 master 브랜치.png" alt="Clone 이후 서버와 로컬의 master 브랜치" data-proofer-ignore> <em>Clone 이후 서버와 로컬의 master 브랜치</em></p><p>로컬 저장소에서 어떤 작업을 진행하고 있는데 다른 팀원이 git.ourcompany.com 서버에 Push하여 master 브랜치를 업데이트했다. 그러면 그 순간부터 팀원 간의 히스토리는 서로 달라지게 된다. 서버 저장소로부터 어떤 데이터도 주고받지 않아서 origin/master 포인터는 그대로다.</p><p><img data-src="/assets/img/2022-01-12/Git/Remote Branches/로컬과 리모트 서버의 커밋 히스토리는 독립적임.png" alt="로컬과 리모트 서버의 커밋 히스토리는 독립적임" data-proofer-ignore> <em>로컬과 리모트 서버의 커밋 히스토리는 독립적임</em></p><p>리모트 서버로부터 저장소 정보를 동기화하려면 <code class="language-plaintext highlighter-rouge">git fetch origin</code> 명령을 사용한다. 명령을 실행하면 origin 서버의 주소 정보(이 예에서는 git.ourcompany.com)를 찾아서 현재 로컬 저장소에는 없는 새로운 정보가 있으면 모두 내려받고, 받은 데이터를 로컬 저장소에 업데이트하고 나서 origin/master 포인터의 위치를 최신 커밋으로 이동시킨다.</p><p><img data-src="/assets/img/2022-01-12/Git/Remote Branches/git fetch 명령은 리모트 브랜치 정보를 업데이트.png" alt="git fetch 명령은 리모트 브랜치 정보를 업데이트" data-proofer-ignore> <em><code class="language-plaintext highlighter-rouge">git fetch</code> 명령은 리모트 브랜치 정보를 업데이트</em></p><p>리모트 저장소를 여러 개 운영하는 상황을 이해할 수 잇도록 개발용으로 사용할 Git 저장소를 팀 내부에 하나 추가해 보자. 이 저장소의 주소는 git.team1.ourcompany.com 이며 <code class="language-plaintext highlighter-rouge">git remote add</code> 명령으로 현재 작업 중인 프로젝트에 팀의 저장소를 추가한다. 이름을 teamone 으로 짓고 긴 서버 주소 대신 사용한다.</p><p><img data-src="/assets/img/2022-01-12/Git/Remote Branches/서버를 리모트 저장소로 추가.png" alt="서버를 리모트 저장소로 추가" data-proofer-ignore> <em>서버를 리모트 저장소로 추가</em></p><p>서버 추가 후 <code class="language-plaintext highlighter-rouge">git fetch teamone</code> 명령으로 teamone 서버의 최신 데이터를 모두 내려받는다. 그러나 명령을 실행해도 teamone 서버의 데이터는 모두 origin 서버에도 있는 것들이라서 아무것도 내려받지 않는다. 하지만 이 명령은 리모트 트래킹 브랜치 teamone/master가 teamone 서버의 master 브랜치가 가리키는 커밋을 가리키게 한다.</p><p><img data-src="/assets/img/2022-01-12/Git/Remote Branches/리모트 저장소 teamone의 master 리모트 트래킹 브랜치.png" alt="teamone/master 의 리모트 트래킹 브랜치" data-proofer-ignore> <em>teamone/master 의 리모트 트래킹 브랜치</em></p><h2 id="push-하기"><span class="mr-2">Push 하기</span><a href="#push-하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>로컬 브랜치를 서버에 보내려면 해당 서버에 쓰기 권한이 있어야 한다. 그리고 로컬 브랜치는 자동으로 리모트 저장소로 보내지는 것이 아닌 개발자가 직접 명시적으로 브랜치를 Push 해야 서버에 반영된다. 따라서 로컬 브랜치를 서버에 보내지 않고 로컬에만 두는 비공개 브랜치를 활용할 수도 있다. 또는 다른 사람과 협업하기 위한 토픽 브랜치만 전송할 수도 있다.</p><p>serverfix라는 브랜치를 다른 사람과 공유하기 위해 서버에 Push 해보자. 명령은 <code class="language-plaintext highlighter-rouge">git push &lt;remote-name&gt; &lt;branch-name&gt;</code> 이다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git push origin serverfix
Counting objects: 24, <span class="k">done</span><span class="nb">.</span>
Delta compression using up to 8 threads.
Compressing objects: 100% <span class="o">(</span>15/15<span class="o">)</span>, <span class="k">done</span><span class="nb">.</span>
Writing objects: 100% <span class="o">(</span>24/24<span class="o">)</span>, 1.91 KiB | 0 bytes/s, <span class="k">done</span><span class="nb">.</span>
Total 24 <span class="o">(</span>delta 2<span class="o">)</span>, reused 0 <span class="o">(</span>delta 0<span class="o">)</span>
To https://github.com/schacon/simplegit
 <span class="k">*</span> <span class="o">[</span>new branch]      serverfix -&gt; serverfix
</pre></table></code></div></div><p>Git은 serverfix 브랜치 이름을 refs/heads/serverfix:refs/heads/serverfix로 확장한다. 이것은 로컬 브랜치 serverfix를 서버로 Push 하는데 리모트의 serverfix 브랜치로 업데이트 한다는 것을 의미한다. 나중에 refs/heads/의 뜻을 자세히 알아볼 것이기에 일단 넘어가도록 하자.</p><p><code class="language-plaintext highlighter-rouge">git push origin serverfix:serverfix</code> 와 같은 명령을 통해 Push 하는 것도 같은 의미인데 이것은 “로컬의 serverfix 브랜치를 리모트 저장소의 serverfix 브랜치로 Push 하라” 라는 뜻이다. 이러한 명령은 로컬 브랜치의 이름과 리모트 서버의 브랜치 이름이 다를 때 사용한다.</p><p>리모트 저장소에 serverfix라는 이름 대신 다른 이름을 사용하려면 <code class="language-plaintext highlighter-rouge">git push origin serverfix:mooyaho</code> 처럼 사용하면 된다.</p><blockquote><p><strong>리모트 저장소에 접근할 때마다 암호를 매번 입력할 필요는 없다.</strong> HTTPS URL로 시작하는 리모트 저장소를 사용한다면 아마도 Push 나 Pull을 할 때 인증을 위한 사용자 이름이나 암호를 묻는 것을 볼 수 있다. Git이 이 정보를 서버로 전달해서 권한을 확인하기 위함이다.</p><p>매번 암호를 입력하는 작업이 번거롭다면 ”credential cache” 기능을 이용할 수 있다. 이 기능을 활성화하면 Git은 몇 분 동안 입력한 사용자 이름과 암호를 저장해둔다. 이 기능을 활성화하려면 <code class="language-plaintext highlighter-rouge">git config --global credential.helper cache</code> 명령을 실행하여 환경설정을 추가한다.</p><p>이 기능이 제공하는 다른 옵션에 관한 자세한 설명은 <a href="https://git-scm.com/book/ko/v2/ch00/_credential_caching">Credential 저장소</a>를 참고하자.</p></blockquote><p>저장소를 Fetch 하고 나서 서버에 있는 serverfix 브랜치에 접근할 때 origin/serverfix 라는 이름으로 접근할 수 있다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git fetch origin
remote: Counting objects: 7, <span class="k">done</span><span class="nb">.</span>
remote: Compressing objects: 100% <span class="o">(</span>2/2<span class="o">)</span>, <span class="k">done</span><span class="nb">.</span>
remote: Total 3 <span class="o">(</span>delta 0<span class="o">)</span>, reused 3 <span class="o">(</span>delta 0<span class="o">)</span>
Unpacking objects: 100% <span class="o">(</span>3/3<span class="o">)</span>, <span class="k">done</span><span class="nb">.</span>
From https://github.com/schacon/simplegit
 <span class="k">*</span> <span class="o">[</span>new branch]      serverfix    -&gt; origin/serverfix
</pre></table></code></div></div><p>여기서 짚고 넘어가야 할 점이 있다. Fetch 명령을 통해 리모트 트래킹 브랜치를 내려받는다고 해서 로컬 저장소에 수정할 수 있는 브랜치가 자동으로 생성되는 것이 아니다. 다시 말해 serverfix 브랜치가 생기는 것이 아닌 그저 수정 불가능한 origin/serverfix 브랜치 포인터가 생기는 것이다.</p><p>새로 받은 브랜치의 내용을 Merge 하려면 <code class="language-plaintext highlighter-rouge">git merge origin/serverfix</code> 명령을 사용한다. 만약 Merge하지 않고 리모트 트래킹 브랜치에서 시작하는 새 브랜치를 로컬에 생성하려면 아래와 같은 명령을 사용한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git switch <span class="nt">-c</span> serverfix origin/serverfix
Switched to a new branch <span class="s1">'serverfix'</span>
Branch <span class="s1">'serverfix'</span> <span class="nb">set </span>up to track remote branch <span class="s1">'serverfix'</span> from <span class="s1">'origin'</span><span class="nb">.</span>
</pre></table></code></div></div><p>origin/serverfix 에서 시작하고 수정할 수 있는 serverfix 라는 로컬 브랜치가 만들어졌다.</p><h2 id="브랜치-추적"><span class="mr-2">브랜치 추적</span><a href="#브랜치-추적" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>리모트 트래킹 브랜치를 로컬 브랜치로 Checkout 하면 자동으로 트래킹 브랜치가 만들어진다. 트래킹 하는 대상 브랜치를 Upstream 브랜치라고 부른다. 트래킹 브랜치는 리모트 브랜치와 연결되어 있는 로컬 브랜치다. 트래킹 브랜치에서 <code class="language-plaintext highlighter-rouge">git pull</code> 명령을 내리면 리모트 저장소로부터 데이터를 내려받아 연결된 리모트 브랜치와 자동으로 Merge 한다.</p><p>서버로부터 저장소를 Clone 하면 Git은 자동으로 로컬 master 브랜치를 리모트 origin/master 브랜치의 트래킹 브랜치로 만든다. 트래킹 브랜치를 직접 만들 수 있는데 리모트를 origin이 아닌 다른 리모트로 할 수도 있고, 브랜치도 master가 아닌 다른 브랜치로 추적할 수 있다.</p><p><code class="language-plaintext highlighter-rouge">git switch -c &lt;branch-name&gt; &lt;remote-name&gt;/&lt;branch-name&gt;</code> 명령으로 간단히 트래킹 브랜치를 만들고 리모트 브랜치를 트래킹하도록 할 수 있다.</p><p><img data-src="/assets/img/2022-01-12/Git/Remote Branches/리모트 저장소 tr의 fbaddfiles 브랜치를 추적하는 로컬 트래킹 브랜치 fbaddfiles 생성.png" alt="리모트 저장소 tr의 fbaddfiles 브랜치를 추적하는 로컬 트래킹 브랜치 fbaddfiles 생성" data-proofer-ignore> <em>리모트 저장소 tr의 fbaddfiles 브랜치를 추적하는 로컬 트래킹 브랜치 fbaddfiles 생성</em></p><p>다음과 같이 <code class="language-plaintext highlighter-rouge">--track</code> 옵션을 사용하여 로컬 브랜치 이름을 자동으로 생성할 수도 있다.</p><p><img data-src="/assets/img/2022-01-12/Git/Remote Branches/리모트 저장소 tr의 브랜치명을 참조해 feature_division 로컬 트래킹 브랜치 생성.png" alt="리모트 저장소 tr의 브랜치명을 참조해 feature_division 로컬 트래킹 브랜치 생성" data-proofer-ignore> <em>리모트 저장소 tr의 브랜치명을 참조해 feature_division 로컬 트래킹 브랜치 생성</em></p><p>이 명령은 매우 자주 쓰이므로 더 생략할 수 있다. 리모트 브랜치에는 존재하나 로컬 브랜치에는 존재하지 않는 경우 Git은 트래킹 브랜치를 자동으로 만들어 준다.</p><p>※ <code class="language-plaintext highlighter-rouge">git branch</code> 명령의 <code class="language-plaintext highlighter-rouge">-a</code> 옵션은 현재 리모트 저장소와 로컬 저장소의 모든 브랜치를 보여준다.</p><p><img data-src="/assets/img/2022-01-12/Git/Remote Branches/로컬에는 없으나 리모트에는 존재하는 브랜치에 대한 트래킹 브랜치 자동 생성.png" alt="로컬에는 없으나 리모트에는 존재하는 브랜치에 대한 트래킹 브랜치 자동 생성" data-proofer-ignore></p><p>로컬에는 없으나 리모트에는 존재하는 브랜치에 대한 트래킹 브랜치 자동 생성</p><p>리모트 브랜치와 다른 이름으로 브랜치를 만들고 싶은 경우 로컬 브랜치의 이름을 다음과 같이 다르게 지정해보자.</p><p><img data-src="/assets/img/2022-01-12/Git/Remote Branches/리모트 저장소 tr의 gh-pages 브랜치를 추적하는 mooyaho 로컬 트래킹 브랜치가 생성됨.png" alt="tr/gh-pages를 추적하는 mooyaho 트래킹 브랜치가 생성됨" data-proofer-ignore> <em>tr/gh-pages를 추적하는 mooyaho 트래킹 브랜치가 생성됨</em></p><p>이미 로컬에 존재하는 브랜치가 리모트의 특정 브랜치를 추적하게 하려면 <code class="language-plaintext highlighter-rouge">git branch</code> 명령에 <code class="language-plaintext highlighter-rouge">-u</code> 혹은 <code class="language-plaintext highlighter-rouge">--set-upstream-to</code> 옵션을 붙이면 된다.</p><p><img data-src="/assets/img/2022-01-12/Git/Remote Branches/로컬 브랜치 mooyaho는 리모트 tr의 bisect 브랜치를 추적하게 됨.png" alt="로컬 브랜치 mooyaho는 리모트 tr의 bisect 브랜치를 추적하게 됨" data-proofer-ignore></p><p>로컬 브랜치 mooyaho는 리모트 tr의 bisect 브랜치를 추적하게 됨</p><p><code class="language-plaintext highlighter-rouge">git branch -vv</code> 명령을 통해 mooyaho 브랜치가 tr/bisect 브랜치를 추적 중임을 알 수 있다.</p><p><img data-src="/assets/img/2022-01-12/Git/Remote Branches/리모트 브랜치 bisect를 추적 중인 로컬 트래킹 브랜치 mooyaho.png" alt="리모트 브랜치 bisect를 추적 중인 로컬 트래킹 브랜치 mooyaho" data-proofer-ignore> <em>리모트 브랜치 bisect를 추적 중인 로컬 트래킹 브랜치 mooyaho</em></p><blockquote><p><strong>Upstream 별명</strong></p><p>트래킹 브랜치를 설정했다면 트래킹 브랜치 이름을 <code class="language-plaintext highlighter-rouge">@{upstream}</code> 이나 <code class="language-plaintext highlighter-rouge">@{u}</code> 로 짧게 대체하여 사용할 수 있다. master 브랜치가 origin/master 브랜치를 추적하는 경우라면 <code class="language-plaintext highlighter-rouge">git merge origin/master</code> 명령과 <code class="language-plaintext highlighter-rouge">git merge @{u}</code> 명령을 똑같이 사용할 수 있다.</p></blockquote><p>트래킹 브랜치가 현재 어떻게 설정되어 있는지 확인하려면 <code class="language-plaintext highlighter-rouge">git branch</code> 명령에 <code class="language-plaintext highlighter-rouge">-vv</code> 옵션을 사용한다. 이 명령은 로컬 브랜치 목록과 로컬 브랜치가 추적하고 있는 리모트 브랜치도 함께 보여준다. 게다가 로컬 브랜치가 앞서가는지 뒤쳐지는지에 대한 내용도 보여준다.</p><p><img data-src="/assets/img/2022-01-12/Git/Remote Branches/로컬 브랜치 상세 정보 조회.png" alt="로컬 브랜치 상세 정보 조회" data-proofer-ignore> <em>로컬 브랜치 상세 정보 조회</em></p><p>위의 결과를 보면 master 브랜치는 origin/master 리모트 브랜치를 추적하고 있다는 것을 알 수 있고 “ahead” 표시를 통해 로컬 브랜치가 커밋 1개 앞서 있다(리모트 브랜치에는 없는 커밋이 로컬에는 존재)는 것을 알 수 있다.</p><p>로컬 브랜치 중 mooyaho 브랜치는 bisect 이라는 tr 리모트 서버의 브랜치를 추적하고 있으며 커밋 3개 앞서 있고 동시에 커밋 16개 뒤쳐져 있다. 어떤 의미냐면 mooyaho 브랜치에서 서버로 보내지 않은 커밋이 1개, 서버의 브랜치에서 로컬 브랜치로 Merge 하지 않은 커밋이 16개 있다는 말이다.</p><p>br_version2, iss53, testing 브랜치는 추적하는 리모트 브랜치가 없는 상태이다.</p><p>여기서 중요한 점은 <strong>명령을 실행한 시점의 결과는 마지막으로 데이터를 서버에서 가져온(Fetch or Pull) 시점을 바탕으로 계산한다는 점</strong>이다. 단순히 이 명령만으론 서버의 최신 데이터를 반영하지는 않으며 로컬에 저장된 서버의 캐시 데이터를 사용한다. 현재 시점에서 최신 데이터로 추적 상황을 알아보려면 먼저 서버로부터 최신 데이터를 받아온 후에 추적 상황을 확인해야 한다. 아래처럼 세미콜론을 통해 두 명령을 이어서 사용하는 것이 적당하겠다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git fetch <span class="nt">--all</span><span class="p">;</span> git branch <span class="nt">-vv</span>
</pre></table></code></div></div><blockquote><p>여기서 세미콜론(;)은 git의 고유 명령이 아닌 Unix 체계의 명령이다. 세미콜론 앞의 명령어 실행을 마칠 때까지 기다린 후 이후의 명령어를 수행한다. 이는 동기식으로 진행되므로 두 명령어가 겹쳐 실행되는 경우는 없다. 그리고 앞 명령어가 실패해도 다음 명령어가 실행된다.</p></blockquote><p>이와 유사한 명령이 있는데 기능은 다음과 같다. &amp; → 앞의 명령어를 비동기로 실행하고 동시에 뒤의 명령어를 실행 &amp;&amp; → 앞 명령어가 성공했을 때 다음 명령어 실행</p><blockquote></blockquote><h2 id="pull-하기"><span class="mr-2">Pull 하기</span><a href="#pull-하기" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p><code class="language-plaintext highlighter-rouge">git fetch</code> 명령을 실행하면 서버에는 존재하지만 로컬에는 아직 없는 데이터를 받아와서 저장한다. 이때 워킹 디렉터리의 파일 내용은 변경되지 않고 그대로 남는다. 서버로부터 데이터를 가져와서 저장해두고 사용자가 직접 Merge 하도록 준비만 해둔다.</p><p>반면 <code class="language-plaintext highlighter-rouge">git pull</code> 명령은 <code class="language-plaintext highlighter-rouge">git fetch</code> 명령을 실행하고 나서 자동으로 <code class="language-plaintext highlighter-rouge">git merge</code> 명령을 수행하는 것 뿐이다. <code class="language-plaintext highlighter-rouge">git clone</code> 이나 <code class="language-plaintext highlighter-rouge">git switch</code> 명령을 실행하여 트래킹 브랜치가 설정되면 <code class="language-plaintext highlighter-rouge">git pull</code> 명령은 서버로부터 데이터를 가져와서 현재 로컬 브랜치와 서버의 트래킹 브랜치를 자동으로 Merge 한다.</p><h2 id="리모트-브랜치-삭제"><span class="mr-2">리모트 브랜치 삭제</span><a href="#리모트-브랜치-삭제" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>동료와 협업하기 위해 리모트 브랜치를 만들었다가 작업을 마치고 master 브랜치로 Merge 했다. 협업하는 데 사용했던 그 리모트 브랜치는 더 이상 필요하지 않기에 삭제할 수 있다. <code class="language-plaintext highlighter-rouge">git push</code> 명령에 <code class="language-plaintext highlighter-rouge">--delete</code> 혹은 <code class="language-plaintext highlighter-rouge">:</code> 옵션을 사용하여 리모트 브랜치를 삭제할 수 있다. serverfix 라는 리모트 브랜치를 삭제하려면 아래와 같이 실행한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git push origin <span class="nt">--delete</span> serverfix

or

<span class="nv">$ </span>git push origin : serverfix
To https://github.com/schacon/simplegit
 - <span class="o">[</span>deleted]         serverfix
</pre></table></code></div></div><p>위 명령을 실행하면 서버에서 브랜치(커밋을 가리키는 포인터) 하나가 사라진다. Git의 가비지 컬렉터가 동작하지 않는 한 데이터는 사라지지 않기 때문에 종종 의도치 않게 삭제한 경우에도 커밋한 데이터를 되살릴 수도 있다. 그러나 만약 가비지 컬렉터가 가비지 컬렉팅 작업을 수행해 Refs와 연결되어 있지 않은 커밋들을 삭제한 상태라면 브랜치 또는 커밋을 복구할 수 없으므로 백업용 저장소를 함께 운용하는 것이 좋다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/git/'>Git</a>, <a href='/categories/branch/'>Branch</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/git-tracking-branch/" class="post-tag no-text-decoration" >Git Tracking Branch</a> <a href="/tags/git-remote/" class="post-tag no-text-decoration" >git remote</a> <a href="/tags/git-branch/" class="post-tag no-text-decoration" >git branch</a> <a href="/tags/git/" class="post-tag no-text-decoration" >Git</a> <a href="/tags/vcs/" class="post-tag no-text-decoration" >VCS</a> <a href="/tags/dvcs/" class="post-tag no-text-decoration" >DVCS</a> <a href="/tags/github/" class="post-tag no-text-decoration" >Github</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Git] 리모트 브랜치 - Sunhyeok Choe&amp;url=https://sunhyeokchoe.github.io/posts/Remote-Branches/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Git] 리모트 브랜치 - Sunhyeok Choe&amp;u=https://sunhyeokchoe.github.io/posts/Remote-Branches/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://sunhyeokchoe.github.io/posts/Remote-Branches/&amp;text=[Git] 리모트 브랜치 - Sunhyeok Choe" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Growl-Notification/">[WPF] 팝업 알림창 MVVM 패턴으로 구현하기</a><li><a href="/posts/Contributing-to-a-Project/">[Git] 분산 환경에서 프로젝트에 기여하기</a><li><a href="/posts/Working-with-Remotes/">[Git] 리모트 저장소</a><li><a href="/posts/Branch-Management/">[Git] 브랜치 관리</a><li><a href="/posts/Branching-Workflows/">[Git] 브랜치 워크플로</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dvcs/">DVCS</a> <a class="post-tag" href="/tags/git/">Git</a> <a class="post-tag" href="/tags/github/">Github</a> <a class="post-tag" href="/tags/vcs/">VCS</a> <a class="post-tag" href="/tags/git-branch/">git branch</a> <a class="post-tag" href="/tags/commit-history/">Commit History</a> <a class="post-tag" href="/tags/git-commit/">git commit</a> <a class="post-tag" href="/tags/git-merge/">git merge</a> <a class="post-tag" href="/tags/git-remote/">git remote</a> <a class="post-tag" href="/tags/git-switch/">git switch</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Basic-Branching-and-Merging/"><div class="card-body"> <em class="timeago small" data-ts="1641982740" > 2022-01-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Git] 브랜치와 Merge 기초</h3><div class="text-muted small"><p> 실제 개발환경에서 겪을 만한 예제를 하나 살펴보자. 브랜치와 Merge는 보통 이런 식으로 진행한다. 작업 중인 웹사이트가 있다. 새로운 이슈를 처리할 새 Branch를 하나 생성한다. 새로 만든 Branch에서 작업을 진행한다. 이때 어떤 문제가 생겨서 그것을 해결하는 Hotfix 브랜치를 먼저 만들어야 한다. 그러면 아래와 같이 ...</p></div></div></a></div><div class="card"> <a href="/posts/Branch-Management/"><div class="card-body"> <em class="timeago small" data-ts="1641983640" > 2022-01-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Git] 브랜치 관리</h3><div class="text-muted small"><p> 어떻게 충돌을 해결했고 좀 더 확인해야 하는 부분은 무엇이고 왜 그렇게 해결했는지에 대해서 자세하게 기록한다. 자세한 기록은 나중에 이 Merge 커밋을 이해하는데 도움을 준다. 브랜치 관리 지금까지 브랜치를 만들고, Merge 하고, 삭제하는 방법에 대해서 살펴봤다. 브랜치를 관리하는 데 필요한 다른 명령도 살펴보자. git branch 명...</p></div></div></a></div><div class="card"> <a href="/posts/Branching-Workflows/"><div class="card-body"> <em class="timeago small" data-ts="1641983880" > 2022-01-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Git] 브랜치 워크플로</h3><div class="text-muted small"><p> 브랜치 워크플로 브랜치를 생성하고 Merge 하는 것을 어디에 써먹어야 할까. 이 절에서는 유용한 몇 가지 워크플로를 살펴본다. 여기서 설명하는 워크플로를 개발에 적용하면 많은 도움이 될 것이다. Long-Running 브랜치 Git은 꼼꼼하게 3-way Merge를 사용하기 때문에 장기간에 걸쳐서 한 브랜치를 다른 브랜치와 여러 번 Merg...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Branching-Workflows/" class="btn btn-outline-primary" prompt="이전 글"><p>[Git] 브랜치 워크플로</p></a> <a href="/posts/Rebasing/" class="btn btn-outline-primary" prompt="다음 글"><p>[Git] Rebase 기초</p></a></div><script src="https://utteranc.es/client.js" repo="SunhyeokChoe/SunhyeokChoe.github.io" issue-term="url" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/SunhyeokChoe">SunhyeokChoe</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dvcs/">DVCS</a> <a class="post-tag" href="/tags/git/">Git</a> <a class="post-tag" href="/tags/github/">Github</a> <a class="post-tag" href="/tags/vcs/">VCS</a> <a class="post-tag" href="/tags/git-branch/">git branch</a> <a class="post-tag" href="/tags/commit-history/">Commit History</a> <a class="post-tag" href="/tags/git-commit/">git commit</a> <a class="post-tag" href="/tags/git-merge/">git merge</a> <a class="post-tag" href="/tags/git-remote/">git remote</a> <a class="post-tag" href="/tags/git-switch/">git switch</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-0ZQ0CWNMX0"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-0ZQ0CWNMX0'); }); </script>
