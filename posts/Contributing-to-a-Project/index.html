<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="[Git] 분산 환경에서 프로젝트에 기여하기" /><meta name="author" content="SunhyeokChoe" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="기여하는 방식에 영향을 끼치는 변수가 다음과 같이 몇 가지 있다." /><meta property="og:description" content="기여하는 방식에 영향을 끼치는 변수가 다음과 같이 몇 가지 있다." /><link rel="canonical" href="https://sunhyeokchoe.github.io/posts/Contributing-to-a-Project/" /><meta property="og:url" content="https://sunhyeokchoe.github.io/posts/Contributing-to-a-Project/" /><meta property="og:site_name" content="Sunhyeok Choe" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-01-13T18:20:58+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Git] 분산 환경에서 프로젝트에 기여하기" /><meta name="twitter:site" content="@SunhyeokChoe" /><meta name="twitter:creator" content="@SunhyeokChoe" /><meta name="google-site-verification" content="oz2h83RZgafkaSK760iGMC02_eS2Dv7i4EdGDt1owoI" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"SunhyeokChoe"},"dateModified":"2022-02-08T02:12:20+09:00","datePublished":"2022-01-13T18:20:58+09:00","description":"기여하는 방식에 영향을 끼치는 변수가 다음과 같이 몇 가지 있다.","headline":"[Git] 분산 환경에서 프로젝트에 기여하기","mainEntityOfPage":{"@type":"WebPage","@id":"https://sunhyeokchoe.github.io/posts/Contributing-to-a-Project/"},"url":"https://sunhyeokchoe.github.io/posts/Contributing-to-a-Project/"}</script><title>[Git] 분산 환경에서 프로젝트에 기여하기 | Sunhyeok Choe</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Sunhyeok Choe"><meta name="application-name" content="Sunhyeok Choe"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/profile/thumbnail.jpg " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sunhyeok Choe</a></div><div class="site-subtitle font-italic">Dev Notes</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/SunhyeokChoe" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/SunhyeokChoe" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['hackerwreckers','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[Git] 분산 환경에서 프로젝트에 기여하기</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="검색..."> </span> <span id="search-cancel" >취소</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Git] 분산 환경에서 프로젝트에 기여하기</h1><div class="post-meta text-muted"><div> By <em> <a href="https://github.com/SunhyeokChoe">SunhyeokChoe</a> </em></div><div class="d-flex"><div> <span> 게시일 <em class="timeago" data-ts="1642065658" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-01-13 </em> </span> <span> 업데이트 <em class="timeago" data-ts="1644253940" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-02-08 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="8813 단어"> <em>48 분</em> 읽는 시간 소요</span></div></div></div><div class="post-content"><p>기여하는 방식에 영향을 끼치는 변수가 다음과 같이 몇 가지 있다.</p><ul><li>활발히 기여하는 개발자의 수가 몇인지<li>선택한 워크플로가 무엇인지<li>각 개발자에게 접근 권한을 어떻게 부여했는지<li>외부에서도 기여할 수 있는지 (접근 권한)</ul><p>첫 번째로 살펴볼 변수는 <strong>활발히 활동하는 개발자의 수</strong>이다. 이 활발한 개발자에 대한 기준은 얼마나 잦은 빈도로 코드를 쏟아내 기여하는가이다. 대부분 둘, 셋 정도의 개발자가 하루에 몇 번 커밋을 하고 활발하지 않은 프로젝트는 더 띄엄띄엄 할 것이다. 하지만, 아주 큰 프로젝트는 수백, 수천 명의 개발자가 하루에도 수십, 수백 개의 커밋을 만들어 낸다. 개발자가 많으면 많을수록 코드를 깔끔하게 적용하거나 Merge 하기 어려워진다. 어떤 커밋은 다른 개발자가 이미 기여한 내용일 경우 불필요해지기도 하고 때론 서로 충돌이 발생한다. 어떻게 해야 코드를 최신으로 유지하면서 원하는 대로 수정할 수 있을까?</p><p>두 번째 변수는 <strong>프로젝트에서 선택한 워크플로가 무엇인가</strong>이다. 예시는 다음과 같다.</p><ul><li>모든 개발자가 메인 저장소에 쓰기 권한을 갖는 중앙집중형 방식인가?<li>프로젝트에 모든 Patch를 검사하고 통합하는 관리자가 따로 있는가?<li>모든 수정사항을 개발자끼리 검토하고 승인하는가?<li>자신이 그저 돕는게 아니라 어떤 책임을 맡고 있는가?<li>중간 관리자가 있어서 그들에게 먼저 알려야 하는가?</ul><p>세 번째 변수는 <strong>접근 권한</strong>이다. 프로젝트에 쓰기 권한이 있어서 직접적으로 수정이 가능한 경우나 읽기만 가능한 경우에 따라서 프로젝트에 기여하는 방식이 매우 달라진다. 예시는 다음과 같다.</p><ul><li>쓰기 권한이 없다면 어떻게 수정 사항을 프로젝트에 반영할 수 있을까?<li>수정사항을 적용하는 정책이 프로젝트에 있는가?<li>얼마나 많은 시간을 프로젝트에 할애하는가?<li>얼마나 자주 기여하는가?</ul><p>이런 저런 상황에 따라 프로젝트에 기여하는 방식과 워크플로가 달라진다. 간단한 것부터 복잡한 것까지 예제를 통해 각 상황을 살펴보면 실제 프로젝트에 필요한 워크플로를 선택하는 데 도움이 될 것이다.</p><h2 id="커밋-가이드라인"><span class="mr-2">커밋 가이드라인</span><a href="#커밋-가이드라인" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>프로젝트에 기여하기에 앞서 먼저 커밋 메시지 형식에 대한 주의사항을 알아보자. 커밋 메시지를 잘 작성하는 가이드라인을 알아두면 다른 개발자와 협업하는 데 도움이 많이 된다. 참고할 만한 좋은 팁들은 공식문서 <a href="https://github.com/git/git/blob/master/Documentation/SubmittingPatches">SubmittingPatches</a>에 있다.</p><p>무엇보다도 먼저 공백문자를 깨끗하게 정리하고 커밋해야 한다. Git은 공백문자를 검사해볼 수 있는 간단한 명령을 제공한다. 커밋을 하기 전에 <code class="language-plaintext highlighter-rouge">git diff --check</code> 명령으로 공백문자에 대한 오류를 확인할 수 있다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/git diff --check 결과.png" alt="git diff --check 결과" data-proofer-ignore> <em><code class="language-plaintext highlighter-rouge">git diff --check</code> 결과</em></p><p>커밋 하기 전에 공백문자를 검사하면 의미없는 공백이 불필요하게 커밋되는 것을 막을 수 있다.</p><p>그리고 각 커밋은 논리적으로 구분되는 Changeset이다. 최대한 수정사항을 한 주제로 요약할 수 있어야 하고 여러 가지 이슈에 대한 수정사항을 하나의 커밋에 담지 않아야 한다. 작업 내용을 최대한 분할하고, 각 커밋마다 적절한 메시지를 작성한다. 같은 파일의 다른 부분을 수정하는 경우 <code class="language-plaintext highlighter-rouge">git add -patch</code> 명령을 통해 한 부분씩 나누어 Stage 해야 한다. 여러 번 나누어 커밋하면 다른 동료가 수정된 코드를 확인해야 할 때 코드 이해가 훨씬 수월해진다.</p><p>마지막으로 명심해야 할 점은 커밋 메시지 구성이다. 좋은 커밋 메시지를 작성하는 습관은 Git을 사용하는 데 많은 도움이 된다. 일반적으로 커밋 메시지를 작성할 때 사용하는 규칙이 있으며 다음과 같다.</p><ul><li>첫 라인에 50자가 넘지 않는 아주 간략한 메시지를 적어 해당 커밋을 요약한다.<li>다음 한 라인은 비우고 그 다음 라인부터 커밋을 자세히 설명한다. 예를 들어 Git 개발 프로젝트에서는 개발 동기와 구현 상황의 제약 조건이나 상황 등을 자세하게 요구한다.<li>현재형 표현을 사용하는 것이 좋다. 명령문으로 시작하는 것도 좋은 방법이다. 예를 들어 “I added tests for (테스트를 추가함)” 보다는 “Add tests for (테스트 추가)”가 적합하다.</ul><p>아래 내용은 <a href="https://tbaggery.com/2008/04/19/a-note-about-git-commit-messages.html">Tim Pope가 작성한 커밋 메시지 템플릿</a>이다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span data-label-text="Plaintext"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>영문 50글자 이하의 간략한 수정 요약

자세한 설명. 영문 72글자 이상이 되면
라인 바꿈을 하고 이어지는 내용을 작성한다.
특정 상황에서는 첫 번째 라인이 이메일
메시지의 제목이 되고 나머지는 메일
내용이 된다. 빈 라인은 본문과 요약을
구별해주기에 중요하다(본문 전체를 생략하지 않는 한).

이어지는 내용도 한 라인 띄우고 쓴다.

  - 목록 표시도 사용할 수 있다.

  - 보통 '-' 나 '*' 표시를 사용해서 목록을 표현하고
    표시 앞에 공백 하나, 각 목록 사이에는 빈 라인
    하나를 넣는데, 이건 상황에 따라 다르다.
</pre></table></code></div></div><p>메시지를 이렇게 작성하면 함께 일하는 사람은 물론이고 본인에게도 매우 유용하다. Git 개발 프로젝트에는 잘 쓰인 커밋 메시지가 많으므로 적절한 프로젝트를 내려받아서 <code class="language-plaintext highlighter-rouge">git log --no-merges</code> 명령으로 꼭 살펴보기를 권한다.</p><h2 id="비공개-소규모-팀"><span class="mr-2">비공개 소규모 팀</span><a href="#비공개-소규모-팀" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>두 세 명으로 이루어진 비공개 프로젝트가 가장 간단한 프로젝트일 것이다. “비공개” 라고 함은 소스코드가 외부에서 접근할 수 없게끔 공개되지 않은 것을 말한다.</p><p>이런 환경에서는 보통 Subversion 같은 중앙집중형 버전 관리 시스템에서 사용하던 방식을 사용한다. 물론 Git의 오프라인 커밋 기능이나 브랜치 Merge 기능을 이용하긴 하지만 크게 다르지 않다.</p><p>가장 큰 차이점은 서버가 아닌 <strong>클라이언트 쪽에서 Merge</strong> 한다는 점이다. 두 개발자가 저장소를 공유하는 시나리오를 살펴보자. 개발자인 John는 저장소를 Clone 하고 파일을 수정하고 나서 로컬에 커밋한다.</p><p>※ 예제에서 Git이 출력하는 메시지 템플릿 중 일부는 ‘…’로 줄이고 생략했다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c"># John 컴퓨터</span>
<span class="nv">$ </span>git clone john@githost:simplegit.git
Cloning into <span class="s1">'simplegit'</span>...
...
<span class="nv">$ </span><span class="nb">cd </span>simplegit/
<span class="nv">$ </span>vim lib/simplegit.rb
<span class="nv">$ </span>git commit <span class="nt">-am</span> <span class="s1">'remove invalid default value'</span>
<span class="o">[</span>master 738ee87] remove invalid default value
 1 files changed, 1 insertions<span class="o">(</span>+<span class="o">)</span>, 1 deletions<span class="o">(</span>-<span class="o">)</span>
</pre></table></code></div></div><p>개발자인 Jessica도 저장소를 Clone 하고 나서 파일을 하나 새로 추가하고 커밋한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c"># Jessica 컴퓨터</span>
<span class="nv">$ </span>git clone jessica@githost:simplegit.git
Cloning into <span class="s1">'simplegit'</span>...
...
<span class="nv">$ </span><span class="nb">cd </span>simplegit/
<span class="nv">$ </span>vim TODO
<span class="nv">$ </span>git commit <span class="nt">-am</span> <span class="s1">'add reset task'</span>
<span class="o">[</span>master fbff5bc] add reset task
 1 files changed, 1 insertions<span class="o">(</span>+<span class="o">)</span>, 0 deletions<span class="o">(</span>-<span class="o">)</span>
</pre></table></code></div></div><p>Jessica는 서버에 커밋을 Push 한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># Jessica 컴퓨터</span>
<span class="nv">$ </span>git push origin master
...
To jessica@githost:simplegit.git
   1edee6b..fbff5bc  master -&gt; master
</pre></table></code></div></div><p>Push 명령을 실행하고 난 결과 중 마지막 줄은 유용한 정보를 보여준다. 마지막 줄의 기본 형식은 <code class="language-plaintext highlighter-rouge">&lt;oldref&gt;..&lt;newref&gt; fromref -&gt; toref</code> 이다. 각 단어의 의미는 다음과 같다.</p><ul><li><code class="language-plaintext highlighter-rouge">oldref</code> : 이전 레퍼런스 해시<li><code class="language-plaintext highlighter-rouge">newref</code> : 새 레퍼런스 해시<li><code class="language-plaintext highlighter-rouge">fromref</code> : Push 명령에서 사용한 로컬 레퍼런스 이름<li><code class="language-plaintext highlighter-rouge">toref</code> : Push로 업데이트한 리모트 레퍼런스 이름</ul><p>이어지는 내용에서 지금 설명한 Push 명령 출력 결과가 여러번 등장하므로 위같은 메시지 포멧을 이해하고 있으면 다양한 상태에서 정확하게 어떤 일이 벌어지는가를 쉽게 이해할 수 있게 된다. 자세한 내용은 공식문서 <a href="https://git-scm.com/docs/git-push">git-push</a>를 참고한다.</p><p>다시 예제 내용으로 돌아와 John도 내용을 변경하고 커밋을 만든 후 서버로 커밋을 Push 하려 한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># John 컴퓨터</span>
<span class="nv">$ </span>git push origin master
To john@githost:simplegit.git
 <span class="o">!</span> <span class="o">[</span>rejected]        master -&gt; master <span class="o">(</span>non-fast forward<span class="o">)</span>
error: failed to push some refs to <span class="s1">'john@githost:simplegit.git'</span>
</pre></table></code></div></div><p>Jessica의 Push한 내용으로 인해, John의 커밋은 서버에서 거절된다. Subversion을 사용했던 사람은 이 부분을 이해하는 것이 중요하다. 같은 파일을 수정한 것도 아닌데 왜 Push가 거절되는 걸까? Subversion에서는 서로 다른 파일을 수정하는 이런 Merge 작업은 자동으로 서버가 처리한다. 하지만 Git은 <strong>로컬에서 먼저 Merge</strong> 해야 한다. 다시 말해 John은 Push 하기 전에 Jessica가 수정한 커밋을 Fetch 하고 Merge 해야 한다는 말이다. 왜 먼저 원격 저장소를 Fetch를 해야 할까? John의 로컬 저장소의 <code class="language-plaintext highlighter-rouge">master</code> 브랜치가 원격 저장소의 <code class="language-plaintext highlighter-rouge">origin/master</code> 브랜치보다 커밋이 하나 뒤쳐져 있기 때문에 Push 를 하면 덮어써야만 하는 형태가 되기 때문에 Git은 실수로 남의 작업물에 덮어쓰는 불상사를 막을 뿐이다 (덮어쓰는 형태로 강제로 Push 할 순 있다. <code class="language-plaintext highlighter-rouge">git push -f &lt;remote-name&gt; &lt;branch name&gt;</code> 명령을 사용하면 된다).</p><p>이를 위해 John은 Jessica의 작업 내용을 아래와 같이 Fetch 한다. 아래 명령은 Jessica의 작업 내용을 내려받긴 하지만 Merge 까지 하지는 않는다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git fetch origin
...
From john@githost:simplegit
 + 049d078...fbff5bc  master -&gt; origin/master
</pre></table></code></div></div><p>Fetch 하고 나면 John의 로컬 저장소는 아래와 같이 된다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/Fetch 하고 난 John의 저장소.png" alt="Fetch 하고 난 John의 저장소" data-proofer-ignore> <em>Fetch 하고 난 John의 저장소</em></p><p>Fetch 한 작업 내용을 로컬 브랜치에 Merge 하자.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git merge origin/master
Merge made by the <span class="s1">'recursive'</span> strategy.
 TODO |    1 +
 1 files changed, 1 insertions<span class="o">(</span>+<span class="o">)</span>, 0 deletions<span class="o">(</span>-<span class="o">)</span>
</pre></table></code></div></div><p>Merge 후 John의 브랜치는 아래와 같은 상태가 된다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/origin master 브랜치를 Merge 하고 난 후 John의 저장소.png" alt="origin/master 브랜치를 Merge 하고 난 후 John의 저장소" data-proofer-ignore> <em><code class="language-plaintext highlighter-rouge">origin/master</code> 브랜치를 Merge 하고 난 후 John의 저장소</em></p><p>3-Way 방식으로 새 커밋을 생성해 Merge 된 것을 알 수 있다. 자신의 코드와 내려받은 코드가 정상 작동됨을 확인한 후 원격 저장소에 Push 한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git push origin master
...
To john@githost:simplegit.git
   fbff5bc..72bbc59  master -&gt; master
</pre></table></code></div></div><p>이제 John의 저장소는 아래와 같이 되었다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/Push 하고 난 후 John의 저장소.png" alt="Push 하고 난 후 John의 저장소" data-proofer-ignore> <em>Push 하고 난 후 John의 저장소</em></p><p>리모트 트래킹 브랜치(<code class="language-plaintext highlighter-rouge">origin/master</code>)가 새로 생성된 커밋을 가리키도록 업데이트 되었다.</p><p>이번에 Jessica는 토픽 브랜치를 하나 생성한다. <code class="language-plaintext highlighter-rouge">issue54</code> 브랜치를 만들고 세 번에 걸쳐서 커밋한다. 아직 John의 커밋을 Fetch 하지 않은 상황이기 때문에 히스토리는 아래와 같은 상황이 된다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/Jessica의 토픽 브랜치.png" alt="Jessica의 토픽 브랜치" data-proofer-ignore> <em>Jessica의 토픽 브랜치</em></p><p>Jessica는 John이 새로 Push 했다는 것을 알게 되어 하던 작업을 멈추고 John의 작업 내용을 살펴보려고 한다. 하지만 아직 Jessica는 John의 변경사항을 가지고 있지 않은 상태이다. 아래 명령으로 John이 Push 한 커밋을 모두 내려받는다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c"># Jessica 컴퓨터</span>
<span class="nv">$ </span>git fetch origin
...
From jessica@githost:simplegit
   fbff5bc..72bbc59  master -&gt; origin/master
</pre></table></code></div></div><p>Jessica의 저장소는 아래와 같은 상태가 된다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/John의 커밋을 Fetch 한 후 Jessica의 저장소.png" alt="John의 커밋을 Fetch 한 후 Jessica의 저장소" data-proofer-ignore> <em>John의 커밋을 Fetch 한 후 Jessica의 저장소</em></p><p>이제 <code class="language-plaintext highlighter-rouge">orgin/master</code> 와 Merge 할 차례다. Jessica는 토픽 브랜치에서의 작업을 마치고 어떤 내용이 Merge 되는지 <code class="language-plaintext highlighter-rouge">git log</code> 명령으로 확인한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git log <span class="nt">--no-merges</span> issue54..origin/master
commit 738ee872852dfaa9d6634e0dea7a324040193016
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 16:01:27 2009 <span class="nt">-0700</span>

   remove invalid default value
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">issue54..origin/master</code> 문법은 히스토리를 검색할 때 뒤의 브랜치(<code class="language-plaintext highlighter-rouge">origin/master</code>)에 속한 커밋 중 앞의 브랜치(<code class="language-plaintext highlighter-rouge">issue54</code>)에 속하지 않은 커밋을 검색하는 문법이다. 자세한 내용은 <a href="https://git-scm.com/book/ko/v2/ch00/_commit_ranges">범위로 커밋 가리키기</a>에서 다룬다.</p><p>앞의 명령에 따라 히스토리를 검색한 결과 John이 생성하고 Jessica가 Merge 하지 않은 커밋을 하나 찾았다. <code class="language-plaintext highlighter-rouge">origin/master</code> 브랜치를 Merge 하게 되면 검색된 커밋 하나가 로컬 작업에 Merge 될 것이다.</p><p>Merge 할 내용을 확인한 Jessica는 자신이 작업한 내용과 John이 Push 한 작업(<code class="language-plaintext highlighter-rouge">origin/master</code>)을 <code class="language-plaintext highlighter-rouge">master</code> 브랜치에 Merge 하고 Push 한다.</p><p><code class="language-plaintext highlighter-rouge">issue54</code> 토픽 브랜치에 쌓은 모든 내용을 합치려면, 우선 <code class="language-plaintext highlighter-rouge">master</code> 브랜치로 이동해야 한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git switch master
Switched to branch <span class="s1">'master'</span>
Your branch is behind <span class="s1">'origin/master'</span> by 2 commits, and can be fast-forwarded.
</pre></table></code></div></div><p>Jessica는 먼저 <code class="language-plaintext highlighter-rouge">issue54</code> 브랜치를 Merge 한다(<code class="language-plaintext highlighter-rouge">origin/master</code>, <code class="language-plaintext highlighter-rouge">issue54</code> 둘 중 아무거나 먼저 Merge 해도 된다).</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git merge issue54
Updating fbff5bc..4af4298
Fast forward
 README           |    1 +
 lib/simplegit.rb |    6 +++++-
 2 files changed, 6 insertions<span class="o">(</span>+<span class="o">)</span>, 1 deletions<span class="o">(</span>-<span class="o">)</span>
</pre></table></code></div></div><p>보다시피 Fast-forward Merge 이기 때문에 명령 실행 결과는 별 문제가 없다. <code class="language-plaintext highlighter-rouge">origin/master</code>에 쌓여있던 John의 작업 내용을 다음과 같이 실행하여 Jessica는 Merge 작업을 완료할 수 있다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git merge origin/master
Auto-merging lib/simplegit.rb
Merge made by the <span class="s1">'recursive'</span> strategy.
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions<span class="o">(</span>+<span class="o">)</span>, 1 deletions<span class="o">(</span>-<span class="o">)</span>
</pre></table></code></div></div><p>Merge 가 잘 되면 아래와 같은 상태가 된다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/John의 커밋을 Merge 후 Jessica의 저장소.png" alt="John의 커밋을 Merge 후 Jessica의 저장소" data-proofer-ignore> <em>John의 커밋을 Merge 후 Jessica의 저장소</em></p><p><code class="language-plaintext highlighter-rouge">origin/master</code> 브랜치가 Jessica의 <code class="language-plaintext highlighter-rouge">master</code> 브랜치로 나아갈(reachable) 수 있기 때문에 Push는 성공한다(물론 John이 그 사이에 Push 하지 않았다면).</p><p>이제 원격 저장소에 Push 한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git push origin master
...
To jessica@githost:simplegit.git
   72bbc59..8059c15  master -&gt; master
</pre></table></code></div></div><p>두 개발자의 커밋을 성공적으로 Merge 한 결과는 아래와 같다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/Jessica가 서버로 Push 하고 난 후의 저장소.png" alt="Jessica가 서버로 Push 하고 난 후의 저장소" data-proofer-ignore> <em>Jessica가 서버로 Push 하고 난 후의 저장소</em></p><p>매우 간단한 상황의 예제를 살펴보았다. 토픽 브랜치에서 수정하고 로컬의 <code class="language-plaintext highlighter-rouge">master</code> 브랜치에 Merge 한다. 작업한 내용을 공유 저장소에 Push 하고자 할 때는 우선 <code class="language-plaintext highlighter-rouge">origin/master</code> 브랜치를 Fetch 하고 Merge 해야 한다. 그리고 나서 Merge 한 결과를 다시 서버로 Push 한다. 이런 워크플로가 일반적이며 아래와 같이 나타낼 수 있다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/소규모 팀에서 사용하는 워크플로.png" alt="소규모 팀에서 사용하는 워크플로" data-proofer-ignore> <em>소규모 팀에서 사용하는 워크플로</em></p><h2 id="비공개-대규모-팀"><span class="mr-2">비공개 대규모 팀</span><a href="#비공개-대규모-팀" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>이제 비공개 대규모 팀에서의 워크플로를 알아본다. 이런 상황에서는 보통 팀을 여러 개로 나눈다. 각각의 작은 팀이 서로 어떻게 Merge 하는지를 살펴보자.</p><p>John과 Jessica는 <code class="language-plaintext highlighter-rouge">featureA</code> 기능을 함께 작업하게 됐다. Jessica는 Josie와 함께 <code class="language-plaintext highlighter-rouge">featureB</code> 기능도 작업하고 있는 상황이다. 이런 상황이라면 회사는 Integration-Manager 워크플로를 선택하는 게 좋다. 작은 팀이 수행한 결과물은 Integration-Manager가 Merge 하고 공유 저장소의 <code class="language-plaintext highlighter-rouge">master</code> 브랜치를 업데이트한다. 팀 마다 브랜치를 하나씩 만들고 Integration-Manager는 그 브랜치를 Pull 해서 Merge 한다.</p><p>두 팀에 모두 속한 Jessica의 작업 순서를 살펴보자. 우선 Jessica는 저장소를 Clone 하고 <code class="language-plaintext highlighter-rouge">featureA</code> 작업을 먼저 한다. <code class="language-plaintext highlighter-rouge">featureA</code> 브랜치를 만들고 수정하고 커밋한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c"># Jessica 컴퓨터</span>
<span class="nv">$ </span>git switch <span class="nt">-c</span> featureA
Switched to a new branch <span class="s1">'featureA'</span>
<span class="nv">$ </span>vim lib/simplegit.rb
<span class="nv">$ </span>git commit <span class="nt">-am</span> <span class="s1">'add limit to log function'</span>
<span class="o">[</span>featureA 3300904] add limit to log <span class="k">function
 </span>1 files changed, 1 insertions<span class="o">(</span>+<span class="o">)</span>, 1 deletions<span class="o">(</span>-<span class="o">)</span>
</pre></table></code></div></div><p>수정한 내용을 John과 공유하기 위해 <code class="language-plaintext highlighter-rouge">featureA</code> 브랜치를 서버로 Push 한다. Integration-Manager만 <code class="language-plaintext highlighter-rouge">master</code> 브랜치를 업데이트할 수 있기 때문에 <code class="language-plaintext highlighter-rouge">master</code> 브랜치로 Push를 할 수 없고 다른 브랜치로 John과 공유한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git push <span class="nt">-u</span> origin featureA
...
To jessica@githost:simplegit.git
 <span class="k">*</span> <span class="o">[</span>new branch]      featureA -&gt; featureA
</pre></table></code></div></div><p>Jessica는 자신이 한 일을 <code class="language-plaintext highlighter-rouge">featureA</code> 라는 브랜치로 Push 했다는 것을 John에게 알린다. John의 피드백을 기다리는 동안 Jessica는 Josie와 함께 작업하기 위해 서버의 <code class="language-plaintext highlighter-rouge">master</code> 브랜치를 기반으로 새로운 브랜치를 하나 만든다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git fetch origin
<span class="nv">$ </span>git switch <span class="nt">-c</span> featureB origin/master
Switched to a new branch <span class="s1">'featureB'</span>
</pre></table></code></div></div><p>몇 가지 작업을 하고 <code class="language-plaintext highlighter-rouge">featureB</code> 브랜치에 커밋한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nv">$ </span>vim lib/simplegit.rb
<span class="nv">$ </span>git commit <span class="nt">-am</span> <span class="s1">'made the ls-tree function recursive'</span>
<span class="o">[</span>featureB e5b0fdc] made the ls-tree <span class="k">function </span>recursive
 1 files changed, 1 insertions<span class="o">(</span>+<span class="o">)</span>, 1 deletions<span class="o">(</span>-<span class="o">)</span>
<span class="nv">$ </span>vim lib/simplegit.rb
<span class="nv">$ </span>git commit <span class="nt">-am</span> <span class="s1">'add ls-files'</span>
<span class="o">[</span>featureB 8512791] add ls-files
 1 files changed, 5 insertions<span class="o">(</span>+<span class="o">)</span>, 0 deletions<span class="o">(</span>-<span class="o">)</span>
</pre></table></code></div></div><p>그럼 Jessica의 저장소는 아래와 같다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/Jessica의 저장소.png" alt="Jessica의 저장소" data-proofer-ignore> <em>Jessica의 저장소</em></p><p>작업을 마치고 Push 하려고 했는데 Jesie가 이미 <code class="language-plaintext highlighter-rouge">featureB</code> 작업을 하고 서버에 <code class="language-plaintext highlighter-rouge">featureBee</code> 브랜치로 Push 했다는 이메일을 받았다. Jessica는 Jesie의 작업을 먼저 Merge 해야만 Push 할 수 있다.</p><p>Merge 하기 위해서 우선 Fetch 한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git fetch origin
...
From jessica@githost:simplegit
 <span class="k">*</span> <span class="o">[</span>new branch]      featureBee -&gt; origin/featureBee
</pre></table></code></div></div><p>Jessica가 <code class="language-plaintext highlighter-rouge">featureB</code> 브랜치에서 작업중일 때, Fetch 해 온 브랜치를 <code class="language-plaintext highlighter-rouge">featureB</code> 브랜치에 Merge 한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git merge origin/featureBee
Auto-merging lib/simplegit.rb
Merge made by the <span class="s1">'recursive'</span> strategy.
 lib/simplegit.rb |    4 ++++
 1 files changed, 4 insertions<span class="o">(</span>+<span class="o">)</span>, 0 deletions<span class="o">(</span>-<span class="o">)</span>
</pre></table></code></div></div><p>이 시점에서 Jessica는 Merge 한 <code class="language-plaintext highlighter-rouge">featureB</code> 작업을 서버로 Push 할 때 서버의 <code class="language-plaintext highlighter-rouge">featureB</code> 브랜치로 Push 하지 않고 이미 Josie가 생성한 <code class="language-plaintext highlighter-rouge">featureBee</code> 로 작업 내용을 Push 하고자 한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git push <span class="nt">-u</span> origin featureB:featureBee
...
To jessica@githost:simplegit.git
   fba9af8..cd685d1  featureB -&gt; featureBee
</pre></table></code></div></div><p>이것은 <strong>refspec</strong> 이란 것을 사용하는 것인데 <a href="https://git-scm.com/book/ko/v2/ch00/_refspec">Refspec</a> 에서 자세하게 설명한다. 명령에서 사용한 <code class="language-plaintext highlighter-rouge">u</code> 옵션은 <code class="language-plaintext highlighter-rouge">--set-upstream</code> 옵션의 짧은 표현인데 브랜치를 추적하도록 설정해서 이후 Push 나 Pull 할 때 좀 더 편하게 사용할 수 있다.</p><p>John이 몇 가지 작업을 하고 나서 <code class="language-plaintext highlighter-rouge">featureA</code> 에 Push 했고 확인해 달라는 내용의 이메일을 보내왔다. Jessica는 John의 작업 내용을 확인하기 위해 다시 한 번 Fetch 한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git fetch origin
...
From jessica@githost:simplegit
   3300904..aad881d  featureA -&gt; origin/featureA
</pre></table></code></div></div><p>Jessica의 로컬 <code class="language-plaintext highlighter-rouge">featureA</code> 브랜치와 Fetch 해 온 John의 작업내용이 같은 <code class="language-plaintext highlighter-rouge">featureA</code> 브랜치 상에서 어떤 것이 업데이트됐는지 <code class="language-plaintext highlighter-rouge">git log</code> 명령으로 확인한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git log featureA..origin/featureA
commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
Author: John Smith &lt;jsmith@example.com&gt;
Date:   Fri May 29 19:57:33 2009 <span class="nt">-0700</span>

    changed log output to 30 from 25
</pre></table></code></div></div><p>확인을 마치면 로컬의 <code class="language-plaintext highlighter-rouge">featureA</code> 브랜치로 John의 작업 내용을 다음과 같이 Merge 한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git switch featureA
Switched to branch <span class="s1">'featureA'</span>
<span class="nv">$ </span>git merge origin/featureA
Updating 3300904..aad881d
Fast forward
 lib/simplegit.rb |   10 +++++++++-
1 files changed, 9 insertions<span class="o">(</span>+<span class="o">)</span>, 1 deletions<span class="o">(</span>-<span class="o">)</span>
</pre></table></code></div></div><p>Jessica는 일부 수정하고, <code class="language-plaintext highlighter-rouge">featureA</code> 브랜치에 커밋하고, 수정한 내용을 다시 서버로 Push 한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git commit <span class="nt">-am</span> <span class="s1">'small tweak'</span>
<span class="o">[</span>featureA 774b3ed] small tweak
 1 files changed, 1 insertions<span class="o">(</span>+<span class="o">)</span>, 1 deletions<span class="o">(</span>-<span class="o">)</span>
<span class="nv">$ </span>git push
...
To jessica@githost:simplegit.git
   3300904..774b3ed  featureA -&gt; featureA
</pre></table></code></div></div><p>위와 같은 작업을 마치고 나면 Jessica의 저장소는 아래와 같은 모습이 된다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/마지막 Push 하고 난 후의 Jessica의 저장소.png" alt="마지막 Push 하고 난 후의 Jessica의 저장소" data-proofer-ignore> <em>마지막 Push 하고 난 후의 Jessica의 저장소</em></p><p>그럼 <code class="language-plaintext highlighter-rouge">featureA</code> 와 <code class="language-plaintext highlighter-rouge">featureBee</code> 브랜치가 프로젝트의 메인 브랜치로 Merge 할 준비가 되었다고 Integration-Manager에게 알린다. Integration-Manager가 두 브랜치를 모두 Merge 하고 난 후에 메인 브랜치를 Fetch 하면 아래와 같은 모양이 된다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/두 브랜치가 메인 브랜치에 Merge 된 후의 저장소.png" alt="두 브랜치가 메인 브랜치에 Merge 된 후의 저장소" data-proofer-ignore> <em>두 브랜치가 메인 브랜치에 Merge 된 후의 저장소</em></p><p>수많은 팀의 작업을 동시에 진행하고 나중에 Merge 하는 기능을 사용하려고 다른 버전 관리 시스템에서 Git으로 바꾸는 조직들이 많아지고 있다. 팀은 자신의 브랜치로 작업하지만, 메인 브랜치에 영향을 끼치지 않는다는 점이 Git의 장점이다. 아래는 이런 워크플로를 나타내고 있다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/Managed 팀의 워크플로.png" alt="Managed 팀의 워크플로" data-proofer-ignore> <em>Managed 팀의 워크플로</em></p><h2 id="공개-프로젝트-fork"><span class="mr-2">공개 프로젝트 Fork</span><a href="#공개-프로젝트-fork" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>비공개 팀을 운영하는 것과 공개 팀을 운영하는 것은 약간 다르다.</p><p>공개 팀을 운영할 때는 모든 개발자가 프로젝트의 공유 저장소에 직접적으로 쓰기 권한을 가지지 않는다. 그래서 프로젝트의 관리자는 몇 가지 일을 더 해줘야 한다. Fork를 지원하는 Git 호스팅에서 Fork를 통해 프로젝트에 기여하는 법을 예제를 통해 살펴본다. Git 호스팅 사이트(Github, BitBucket, repo.or.cz, Gitlab 등) 대부분 Fork 기능을 지원하며 프로젝트 관리자는 보통 Fork 하는 것으로 프로젝트를 운영한다. 다른 방식으로 이메일과 Patch를 사용하는 방식도 있는데 뒤이어 살펴본다.</p><blockquote><p><code class="language-plaintext highlighter-rouge">rebase -i</code> 명령을 사용하면 여러 커밋을 하나의 커밋으로 합치거나 프로젝트의 관리자가 수정사항을 쉽게 이해하도록 커밋을 정리할 수 있다. <a href="https://git-scm.com/book/ko/v2/ch00/_rewriting_history">히스토리 단장하기</a> 에서 대화식으로 Rebase 하는 방법을 살펴본다.</p></blockquote><p>프로젝트의 웹사이트로 가서 Fork 버튼을 누르면 원래 프로젝트 저장소에서 갈라져 나온, 쓰기 권한이 있는 저장소가 하나 만들어진다. 그러면 로컬에서 수정한 커밋을 Fork 한 저장소에 Push 할 수 있게 된다. 그 저장소를 로컬 저장소의 리모트 저장소로 등록하자. 이름은 <code class="language-plaintext highlighter-rouge">myfork</code>로 하자.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git remote add myfork &lt;remote-url&gt;
</pre></table></code></div></div><p>이제 등록한 리모트 저장소에 Push 한다. 작업하던 내용을 로컬 저장소의 <code class="language-plaintext highlighter-rouge">master</code> 브랜치에 Merge 한 후 Push 하는 것 보다 리모트 브랜치에 바로 Push 하는 방식이 훨씬 간단하다. 이렇게 하는 이유는 관리자가 토픽 브랜치를 프로젝트에 포함시키고 싶지 않을 때 토픽 브랜치를 Merge 하기 이전 상태로 master 브랜치를 되롤릴 필요가 없기 때문이다. 관리자가 토픽 브랜치를 Merge 하든 Rebase 하든 Cherry-Pick 하든지 간에 결국 다시 관리자의 저장소를 Pull 할 때는 토픽 브랜치의 내용이 들어 있을 것이다 (<code class="language-plaintext highlighter-rouge">cherry-pick</code> 명령은 <a href="https://git-scm.com/book/ko/v2/ch00/_rebase_cherry_pick">Rebase와 Cherry-Pick 워크플로</a> 에서 자세히 다룬다).</p><p>다음과 같이 작업 내용을 Push 할 수 있다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c"># 로컬 master에 Merge 하지 않고 바로 리모트 브랜치에 Push</span>
<span class="nv">$ </span>git push <span class="nt">-u</span> myfork featureA
</pre></table></code></div></div><p>Fork 한 저장소에 Push 하고 나면 프로젝트 관리자에게 이 내용을 알려야 한다. 이것을 <strong>Pull Request</strong> 라고 한다. Git 호스팅 사이트에서 관리자에게 보낼 메시지를 생성하거나 <code class="language-plaintext highlighter-rouge">git request-pull</code> 명령으로 이메일을 수동으로 만들 수 있다. GitHub의 Pull Request 기능을 통해 메시지를 만들 수도 있다.</p><p><code class="language-plaintext highlighter-rouge">git request-pull &lt;base-branch&gt; &lt;remote-url&gt;</code> 명령은 아규먼트를 두 개 입력받는다.</p><ul><li><code class="language-plaintext highlighter-rouge">&lt;base-branch&gt;</code> : 작업한 토픽 브랜치의 Base 브랜치<li><code class="language-plaintext highlighter-rouge">&lt;remote-url&gt;</code> : 토픽 브랜치가 위치한 저장소 URL</ul><p>이 명령은 토픽 브랜치 수정사항을 요약한 내용을 결과로 보여준다. 예를 들어 Jessica가 John에게 Pull 요청을 보내는 상황을 살펴보자. Jessica는 토픽 브랜치에 두 번 커밋을 하고 Fork 한 저장소에 Push 했다. 그리고 아래와 같이 실행한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git request-pull origin/master myfork
The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
Jessica Smith <span class="o">(</span>1<span class="o">)</span>:
        added a new <span class="k">function

</span>are available <span class="k">in </span>the git repository at:

  git://githost/simplegit.git featureA

Jessica Smith <span class="o">(</span>2<span class="o">)</span>:
      add limit to log <span class="k">function
      </span>change log output to 30 from 25

 lib/simplegit.rb |   10 +++++++++-
 1 files changed, 9 insertions<span class="o">(</span>+<span class="o">)</span>, 1 deletions<span class="o">(</span>-<span class="o">)</span>
</pre></table></code></div></div><p>관리자에게 이 내용을 보낸다. 이 내용에는 토픽 브랜치가 어느 시점에 갈라져 나온 것인지(<code class="language-plaintext highlighter-rouge">commit 1edee6b</code>), 수정 사항이 어떤지, Pull 하려면 어떤 저장소의 어떤 브랜치에 접근해야 하는지에 대한 내용(<code class="language-plaintext highlighter-rouge">git://githost/simplegit.git</code>, <code class="language-plaintext highlighter-rouge">featureA</code>)이 있다.</p><p>프로젝트 관리자가 아니라고 해도 보통 <code class="language-plaintext highlighter-rouge">origin/master</code> 를 추적하는 <code class="language-plaintext highlighter-rouge">master</code> 브랜치는 가지고 있다. 그래도 토픽 브랜치를 만들고 일을 하면 관리자가 수정 내용을 거부할 때 쉽게 버릴 수 있다. 토픽 브랜치를 만들어서 주제별로 독립적으로 일을 하는 동안에도 주 저장소의 <code class="language-plaintext highlighter-rouge">master</code> 브랜치는 계속 수정된다. 하지만 주 저장소 브랜치의 최근 커밋 이후로 Rebase 하면 깨끗하게 Merge 할 수 있다.</p><p>그리고 다른 주제의 일을 하려고 할 때는 앞서 Push 한 토픽 브랜치에서 시작하지 말고 주 저장소의 <code class="language-plaintext highlighter-rouge">master</code> 브랜치로부터 만들어야 한다. 다음과 같다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git switch <span class="nt">-c</span> featureB origin/master
  ... 작업 ...
<span class="nv">$ </span>git commit
<span class="nv">$ </span>git push myfork featureB
<span class="nv">$ </span>git request-pull origin/master myfork
  ... Pull Request를 관리자에게 전달 ...
  ... 관리자가 Pull Request 승인 후 Merge ...
<span class="nv">$ </span>git fetch origin
</pre></table></code></div></div><p>각 토픽 브랜치는 일종의 실험실이라고 할 수 있다. 각 토픽은 서로 방해하지 않고 독립적으로 수정하고 Rebase 할 수 있다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/featureB 수정 작업이 끝난 직후 저장소의 모습.png" alt="featureB 수정 작업이 끝난 직후 저장소의 모습" data-proofer-ignore> <em>featureB 수정 작업이 끝난 직후 저장소의 모습</em></p><p>프로젝트 관리자가 사람들의 수정 사항을 Merge 하고 나서 Jessica의 브랜치를 Merge 하려고 할 때 충돌이 날 수도 있다. 그러면 Jessica가 자신의 브랜치를 origin/master에 Rebase 해서 충돌을 해결하고 다시 Pull Request를 보낸다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git switch featureA
<span class="nv">$ </span>git rebase origin/master
<span class="nv">$ </span>git push <span class="nt">-f</span> myfork featureA
</pre></table></code></div></div><p>위 명령들을 실행하고 나면 히스토리는 다음과 같다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/FeatureA에 대한 Rebase가 적용된 후의 모습.png" alt="FeatureA에 대한 Rebase가 적용된 후의 모습" data-proofer-ignore> <em>FeatureA에 대한 Rebase가 적용된 후의 모습</em></p><p>브랜치를 Rebase 해 버렸기 때문에 Push 할 때 <code class="language-plaintext highlighter-rouge">-f</code> 옵션을 주고 강제로 기존 서버에 있던 <code class="language-plaintext highlighter-rouge">featureA</code> 브랜치의 내용을 덮어 써야 한다. 아니면 새로운 브랜치를(예를 들어 <code class="language-plaintext highlighter-rouge">featureAv2</code>) 서버에 Push 해도 된다.</p><p>또 다른 시나리오를 하나 더 살펴보자. 프로젝트 관리자는 <code class="language-plaintext highlighter-rouge">featureB</code> 브랜치의 내용은 좋지만, 상세 구현은 다르게 하고 싶다. 관리자는 <code class="language-plaintext highlighter-rouge">featureB</code> 담당자에게 상세 구현을 다르게 해달라고 요청한다. <code class="language-plaintext highlighter-rouge">featureB</code> 담당자는 하는 김에 <code class="language-plaintext highlighter-rouge">featureB</code> 브랜치를 프로젝트의 최신 master 브랜치 기반으로 옮긴다. 먼저 <code class="language-plaintext highlighter-rouge">origin/master</code> 브랜치에서 <code class="language-plaintext highlighter-rouge">featureBv2</code> 브랜치를 새로 하나 만들고, <code class="language-plaintext highlighter-rouge">featureB</code> 의 커밋들을 모두 Squash 해서 Merge 하고, 만약 충돌이 발생하면 상세 구현을 수정하고 새 브랜치를 Push 한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git switch <span class="nt">-c</span> featureBv2 origin/master
<span class="nv">$ </span>git merge <span class="nt">--squash</span> featureB
  ... 상세 구현 수정 작업 ...
<span class="nv">$ </span>git commit
<span class="nv">$ </span>git push myfork featureBv2
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">--squash</code> 옵션은 현재 브랜치에 Merge 할 때 해당 브랜치의 커밋을 모두 커밋 하나로 합쳐서 Merge 한다. 이 때 Merge 커밋은 만들지 않는다. 다른 브랜치에서 수정한 사항을 전부 가져오는 것은 똑같다. 하지만 새로 만들어지는 커밋은 부모가 하나이고 커밋을 기록하기 전에 좀 더 수정할 기회도 있다. 수정한 사항을 전부 가져오면서 그 전에 추가적으로 수정할 내용이 있으면 수정하고 Merge 할 수 있다. 게다가 새로 만들어지는 커밋은 부모가 하나다. <code class="language-plaintext highlighter-rouge">--no-commit</code> 옵션을 추가하면 커밋을 합쳐 놓고 자동으로 커밋하지 않는다.</p><p>수정을 마치면 관리자에게 <code class="language-plaintext highlighter-rouge">featureBv2</code> 브랜치를 확인해 보라고 메시지를 보낸다.</p><p><img data-src="/assets/img/2022-01-13/Git/Contributing to a Project/featureBv2 브랜치를 커밋한 이후 저장소 모습.png" alt="featureBv2 브랜치를 커밋한 이후 저장소 모습" data-proofer-ignore> <em>featureBv2 브랜치를 커밋한 이후 저장소 모습</em></p><h2 id="대규모-공개-프로젝트와-이메일을-통한-관리"><span class="mr-2">대규모 공개 프로젝트와 이메일을 통한 관리</span><a href="#대규모-공개-프로젝트와-이메일을-통한-관리" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><hr /><p>대규모 프로젝트는 보통 수정사항이나 Patch를 수용하는 자신만의 규칙을 마련해놓고 있다. 프로젝트마다 규칙은 서로 다를 수 있으므로 각 프로젝트의 규칙을 미리 알아둘 필요가 있다. 오래된 대규모 프로젝트는 대부분 메일링리스트를 통해서 Patch를 받아들이는데 예제를 통해 살펴본다.</p><p>토픽 브랜치를 만들어 수정하는 작업은 앞서 살펴본 바와 거의 비슷하지만, Patch를 제출하는 방식이 다르다. 프로젝트를 Fork 하여 Push 하는 것이 아니라 커밋 내용을 메일로 만들어 개발자 메일링리스트에 제출한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git checkout <span class="nt">-b</span> topicA
  ... 작업 ...
<span class="nv">$ </span>git commit
  ... 작업 ...
<span class="nv">$ </span>git commit
</pre></table></code></div></div><p>커밋을 두 번 하고 메일링리스트에 보내 보자. <code class="language-plaintext highlighter-rouge">git format-patch</code> 명령으로 메일링리스트에 보낼 mbox 형식의 파일을 생성한다. 각 커밋은 하나씩 이메일 메시지로 생성되는데 커밋 메시지의 첫 번째 라인이 제목이 되고 Merge 메시지 내용과 Patch 자체가 메일 메시지의 본문이 된다. 이 방식은 수신한 이메일에 들어 있는 Patch를 바로 적용할 수 있어서 좋다. 메일 속에는 커밋의 모든 내용이 포함된다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git format-patch <span class="nt">-M</span> origin/master
0001-add-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">format-patch</code> 명령을 실행하면 생성한 파일 이름을 보여준다. <code class="language-plaintext highlighter-rouge">-M</code> 옵션은 이름이 변경된 파일이 있는지 살펴보라는 옵션이다. 각 파일의 내용은 아래와 같다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">cat </span>0001-add-limit-to-log-function.patch
From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
From: Jessica Smith &lt;jessica@example.com&gt;
Date: Sun, 6 Apr 2008 10:17:23 <span class="nt">-0700</span>
Subject: <span class="o">[</span>PATCH 1/2] add limit to log <span class="k">function

</span>Limit log functionality to the first 20

<span class="nt">---</span>
 lib/simplegit.rb |    2 +-
 1 files changed, 1 insertions<span class="o">(</span>+<span class="o">)</span>, 1 deletions<span class="o">(</span>-<span class="o">)</span>

diff <span class="nt">--git</span> a/lib/simplegit.rb b/lib/simplegit.rb
index 76f47bc..f9815f1 100644
<span class="nt">---</span> a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ <span class="nt">-14</span>,7 +14,7 @@ class SimpleGit
   end

   def log<span class="o">(</span>treeish <span class="o">=</span> <span class="s1">'master'</span><span class="o">)</span>
-    <span class="nb">command</span><span class="o">(</span><span class="s2">"git log #{treeish}"</span><span class="o">)</span>
+    <span class="nb">command</span><span class="o">(</span><span class="s2">"git log -n 20 #{treeish}"</span><span class="o">)</span>
   end

   def ls_tree<span class="o">(</span>treeish <span class="o">=</span> <span class="s1">'master'</span><span class="o">)</span>
<span class="nt">--</span>
2.1.0
</pre></table></code></div></div><p>메일링리스트에 이메일을 보내기 전에 각 Patch 파일을 손으로 고칠 수 있다. <code class="language-plaintext highlighter-rouge">---</code> 라인과 Patch가 시작되는 라인(<code class="language-plaintext highlighter-rouge">diff --git</code> 로 시작하는 라인) 사이에 내용을 추가하면 다른 개발자는 읽을 수 있지만, 나중에 Patch에 적용되지는 않는다.</p><p>특정 메일 프로그램을 사용하거나 이메일을 보내는 명령어로 메일링리스트에 보낼 수 있다. 붙여 넣기로 위의 내용이 그대로 들어가지 않는 메일 프로그램도 있다. 사용자 편의를 위해 공백이나 라인 바꿈 문자 등을 넣어 주는 메일 프로그램은 원본 그대로 들어가지 않는다. 다행히 Git에는 Patch 메일을 그대로 보낼 수 있는 도구가 있다. IMAP 프로토콜로 보낸다. 저자가 사용하는 방법으로 Gmail을 사용하여 Patch 메일을 전송하는 방법을 살펴보자. 추가로 Git 프로젝트의 <code class="language-plaintext highlighter-rouge">Documentation/SubmittingPatches</code> 문서의 마지막 부분을 살펴보면 다양한 메일 프로그램으로 메일을 보내는 방법을 설명한다.</p><p>메일을 보내려면 먼저 <code class="language-plaintext highlighter-rouge">~/.gitconfig</code> 파일에서 이메일 부분 설정한다. <code class="language-plaintext highlighter-rouge">git config</code> 명령으로 추가할 수도 있고 직접 파일을 열어서 추가할 수도 있다. 아무튼, 아래와 같이 설정을 한다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="o">[</span>imap]
  folder <span class="o">=</span> <span class="s2">"[Gmail]/Drafts"</span>
  host <span class="o">=</span> imaps://imap.gmail.com
  user <span class="o">=</span> user@gmail.com
  pass <span class="o">=</span> YX]8g76G_2^sFbd
  port <span class="o">=</span> 993
  sslverify <span class="o">=</span> <span class="nb">false</span>
</pre></table></code></div></div><p>IMAP 서버가 SSL을 사용하지 않으면 마지막 두 라인은 필요 없고 host에서 <code class="language-plaintext highlighter-rouge">imaps://</code> 대신 <code class="language-plaintext highlighter-rouge">imap://</code> 로 한다. 이렇게 설정하면 <code class="language-plaintext highlighter-rouge">git imap-send</code> 명령으로 Patch 파일을 IMAP 서버의 Draft 폴더에 이메일로 보낼 수 있다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nv">$ </span><span class="nb">cat</span> <span class="k">*</span>.patch |git imap-send
Resolving imap.gmail.com... ok
Connecting to <span class="o">[</span>74.125.142.109]:993... ok
Logging <span class="k">in</span>...
sending 2 messages
100% <span class="o">(</span>2/2<span class="o">)</span> <span class="k">done</span>
</pre></table></code></div></div><p>이후 Gmail의 Draft 폴더로 가서 To 부분을 메일링리스트의 주소로 변경하고 CC 부분에 해당 메일을 참고해야 하는 관리자나 개발자의 메일 주소를 적고 실제로 전송한다.</p><p>SMTP 서버를 이용해서 Patch를 보낼 수도 있다. 먼저 SMTP 서버를 설정해야 한다. <code class="language-plaintext highlighter-rouge">git config</code> 명령으로 하나씩 설정할 수도 있지만 아래와 같이 <code class="language-plaintext highlighter-rouge">~/.gitconfig</code> 파일의 sendemail 섹션을 손으로 직접 고쳐도 된다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="o">[</span>sendemail]
  smtpencryption <span class="o">=</span> tls
  smtpserver <span class="o">=</span> smtp.gmail.com
  smtpuser <span class="o">=</span> user@gmail.com
  smtpserverport <span class="o">=</span> 587
</pre></table></code></div></div><p>이렇게 설정하면 <code class="language-plaintext highlighter-rouge">git send-email</code> 명령으로 패치를 보낼 수 있다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nv">$ </span>git send-email <span class="k">*</span>.patch
0001-added-limit-to-log-function.patch
0002-changed-log-output-to-30-from-25.patch
Who should the emails appear to be from? <span class="o">[</span>Jessica Smith &lt;jessica@example.com&gt;]
Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;
Who should the emails be sent to? jessica@example.com
Message-ID to be used as In-Reply-To <span class="k">for </span>the first email? y
</pre></table></code></div></div><p>명령을 실행하면 아래와 같이 서버로 Patch를 보내는 내용이 화면에 나타난다.</p><div class="language-bash highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="복사되었습니다!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="o">(</span>mbox<span class="o">)</span> Adding cc: Jessica Smith &lt;jessica@example.com&gt; from
  <span class="se">\l</span>ine <span class="s1">'From: Jessica Smith &lt;jessica@example.com&gt;'</span>
OK. Log says:
Sendmail: /usr/sbin/sendmail <span class="nt">-i</span> jessica@example.com
From: Jessica Smith &lt;jessica@example.com&gt;
To: jessica@example.com
Subject: <span class="o">[</span>PATCH 1/2] added limit to log <span class="k">function
</span>Date: Sat, 30 May 2009 13:29:15 <span class="nt">-0700</span>
Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;
X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
In-Reply-To: &lt;y&gt;
References: &lt;y&gt;

Result: OK
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/git/'>Git</a>, <a href='/categories/workflow/'>Workflow</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/workflow/" class="post-tag no-text-decoration" >Workflow</a> <a href="/tags/git/" class="post-tag no-text-decoration" >Git</a> <a href="/tags/vcs/" class="post-tag no-text-decoration" >VCS</a> <a href="/tags/dvcs/" class="post-tag no-text-decoration" >DVCS</a> <a href="/tags/github/" class="post-tag no-text-decoration" >Github</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 이 기사는 저작권자의 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 라이센스를 따릅니다.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">공유하기</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Git] 분산 환경에서 프로젝트에 기여하기 - Sunhyeok Choe&amp;url=https://sunhyeokchoe.github.io/posts/Contributing-to-a-Project/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Git] 분산 환경에서 프로젝트에 기여하기 - Sunhyeok Choe&amp;u=https://sunhyeokchoe.github.io/posts/Contributing-to-a-Project/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://sunhyeokchoe.github.io/posts/Contributing-to-a-Project/&amp;text=[Git] 분산 환경에서 프로젝트에 기여하기 - Sunhyeok Choe" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="링크 복사하기" data-title-succeed="링크가 복사되었습니다!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">최근 업데이트</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Growl-Notification/">[WPF] 팝업 알림창 MVVM 패턴으로 구현하기</a><li><a href="/posts/Contributing-to-a-Project/">[Git] 분산 환경에서 프로젝트에 기여하기</a><li><a href="/posts/Working-with-Remotes/">[Git] 리모트 저장소</a><li><a href="/posts/Branch-Management/">[Git] 브랜치 관리</a><li><a href="/posts/Branching-Workflows/">[Git] 브랜치 워크플로</a></ul></div><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dvcs/">DVCS</a> <a class="post-tag" href="/tags/git/">Git</a> <a class="post-tag" href="/tags/github/">Github</a> <a class="post-tag" href="/tags/vcs/">VCS</a> <a class="post-tag" href="/tags/git-branch/">git branch</a> <a class="post-tag" href="/tags/commit-history/">Commit History</a> <a class="post-tag" href="/tags/git-commit/">git commit</a> <a class="post-tag" href="/tags/git-merge/">git merge</a> <a class="post-tag" href="/tags/git-remote/">git remote</a> <a class="post-tag" href="/tags/git-switch/">git switch</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">바로가기</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>관련된 글</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Distributed-Workflows/"><div class="card-body"> <em class="timeago small" data-ts="1641987780" > 2022-01-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Git] Centralized, Integration-Manager and Benevolent dictator workflow</h3><div class="text-muted small"><p> 이번 글에서는 프로젝트 기여자 또는 수정사항을 취합하는 관리자의 관점에서 작업물을 프로젝트에 어떻게 포함시킬지와 수많은 개발자가 수행한 일을 취합하고 프로젝트를 운영하는 방법을 배운다. 분산 환경에서의 워크플로 중앙집중형 버전 관리 시스템과는 달리 Git은 분산형이다. Git은 구조가 매우 유연하기 때문에 여러 개발자가 협업하는 과정을 더 다양...</p></div></div></a></div><div class="card"> <a href="/posts/Basic-Branching-and-Merging/"><div class="card-body"> <em class="timeago small" data-ts="1641982740" > 2022-01-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Git] 브랜치와 Merge 기초</h3><div class="text-muted small"><p> 실제 개발환경에서 겪을 만한 예제를 하나 살펴보자. 브랜치와 Merge는 보통 이런 식으로 진행한다. 작업 중인 웹사이트가 있다. 새로운 이슈를 처리할 새 Branch를 하나 생성한다. 새로 만든 Branch에서 작업을 진행한다. 이때 어떤 문제가 생겨서 그것을 해결하는 Hotfix 브랜치를 먼저 만들어야 한다. 그러면 아래와 같이 ...</p></div></div></a></div><div class="card"> <a href="/posts/Branch-Management/"><div class="card-body"> <em class="timeago small" data-ts="1641983640" > 2022-01-12 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[Git] 브랜치 관리</h3><div class="text-muted small"><p> 어떻게 충돌을 해결했고 좀 더 확인해야 하는 부분은 무엇이고 왜 그렇게 해결했는지에 대해서 자세하게 기록한다. 자세한 기록은 나중에 이 Merge 커밋을 이해하는데 도움을 준다. 브랜치 관리 지금까지 브랜치를 만들고, Merge 하고, 삭제하는 방법에 대해서 살펴봤다. 브랜치를 관리하는 데 필요한 다른 명령도 살펴보자. git branch 명...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Distributed-Workflows/" class="btn btn-outline-primary" prompt="이전 글"><p>[Git] Centralized, Integration-Manager and Benevolent dictator workflow</p></a> <a href="/posts/Growl-Notification/" class="btn btn-outline-primary" prompt="다음 글"><p>[WPF] 팝업 알림창 MVVM 패턴으로 구현하기</p></a></div><script src="https://utteranc.es/client.js" repo="SunhyeokChoe/SunhyeokChoe.github.io" issue-term="url" crossorigin="anonymous" async> </script> <script type="text/javascript"> $(function() { const origin = "https://utteranc.es"; const iframe = "iframe.utterances-frame"; const lightTheme = "github-light"; const darkTheme = "github-dark"; let initTheme = lightTheme; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches)) { initTheme = darkTheme; } addEventListener("message", (event) => { let theme; /* credit to <https://github.com/utterance/utterances/issues/170#issuecomment-594036347> */ if (event.origin === origin) { /* page initial */ theme = initTheme; } else if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { /* global theme mode changed */ const mode = event.data.message; theme = (mode === ModeToggle.DARK_MODE ? darkTheme : lightTheme); } else { return; } const message = { type: "set-theme", theme: theme }; const utterances = document.querySelector(iframe).contentWindow; utterances.postMessage(message, origin); }); }); </script></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/SunhyeokChoe">SunhyeokChoe</a>. <span data-toggle="tooltip" data-placement="top" title="명시되지 않는 한 이 사이트의 블로그 게시물은 작성자의 Creative Commons Attribution 4.0 International(CC BY 4.0) 라이선스에 따라 사용이 허가되었습니다.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">인기 태그</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/dvcs/">DVCS</a> <a class="post-tag" href="/tags/git/">Git</a> <a class="post-tag" href="/tags/github/">Github</a> <a class="post-tag" href="/tags/vcs/">VCS</a> <a class="post-tag" href="/tags/git-branch/">git branch</a> <a class="post-tag" href="/tags/commit-history/">Commit History</a> <a class="post-tag" href="/tags/git-commit/">git commit</a> <a class="post-tag" href="/tags/git-merge/">git merge</a> <a class="post-tag" href="/tags/git-remote/">git remote</a> <a class="post-tag" href="/tags/git-switch/">git switch</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">검색 결과가 없습니다.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/ko.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ /* start/end delimiter pairs for in-line math */ ['$','$'], ['\\(','\\)'] ], displayMath: [ /* start/end delimiter pairs for display math */ ['$$', '$$'], ['\\[', '\\]'] ] } }; </script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-0ZQ0CWNMX0"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-0ZQ0CWNMX0'); }); </script>
