[ { "title": "2. oneM2M 애플리케이션 개발 절차 (1)", "url": "/posts/oneM2M-application-development-procedure-(1)/", "categories": "IoT, oneM2M", "tags": "IoT, oneM2M", "date": "2022-02-19 03:19:18 +0900", "snippet": "원격 조명 제어 유스케이스 개요원세종 군은 하루 일과를 마친 후 지친 몸을 이끌고 집으로 귀가했다. 집에 혼자 살고 있기 때문에 귀가했을 때 집 안에 있는 불은 모두 꺼져있는 상황이다. oneM2M 사물 인터넷 서비스를 사용하지 않았던 한달 전까지만 해도, 원세종 군은 귀가 후에 거실, 주방, 화장실 등의 불을 일일이 켜고, 취침 전에는 다시 모든 실내등들을 일일이 찾아다니며 꺼야만 했다. 그러나, 한달 전 oneM2M 기반 스마트홈 서비스에 가입하면서 부터 스마트폰을 이용한 사물인터넷 원격 조명 제어 서비스를 이용함으로써 집에 들어가서 손가락 하나로 집 안의 모든 조명을 원격으로 제어할 수 있게 된다.위의 예시를 바탕으로 요구사항을 도출해보자. 조명은 집에 배치되어 있으며, Home Gateway에 연결되어 있다. 조명은 무선 접근 제어 인터페이스를 통하여 oneM2M Service Platform과 상호작용을 할 수 있다. Home Gateway는 조명을 검색 후 본인 Home Gateway에 연결한다. Home Gateway는 조명과 oneM2M Service Platform 사이에 위치하며, 상호간의 통신 기능을 제공한다. oneM2M Service Platform는 조명과 Home Gateway를 등록/검색/관리할 수 있다. oneM2M Service Platform는 조명을 그룹관리할 수 있다. oneM2M Service Platform는 알림 서비스 등 공통 서비스 기능(CSF)을 제공한다. Application Service는 스마트폰에 내장되어 있다. Application Service는 Home Gateway에 연결되어 있는 조명들을 검색할 수 있다. Application Service는 조명 상태를 변경시키는 명령어를 전송할 수 있다. Application Service는 조명 상태를 조회하는 명령어를 전송할 수 있다.아키텍처 설계 ADN-AE1: 조명 Light #1에 내장된 애플리케이션으로서 조명을 제어하고 Mca 참조 포인트를 통하여 Home Gateway MN-CSE와 상호작용하는 기능을 가지고 있다. ADN-AE2: 조명 Light #2에 내장된 애플리케이션으로서 조명을 제어하고 Mca 참조 포인트를 통하여 Home Gateway MN-CSE와 상호작용하는 기능을 가지고 있다. IN-AE: 스마트폰 디바이스에 내장된 애플리케이션으로서 Mca 참조 포인트를 통해서 oneM2M Service Platform인 IN-CSE와 직접 상호작용하여 조명 Light #1과 Light #2를 원격으로 제어하는 기능을 가지고 있다. MN-AE: 홈 게이트웨이 MN-CSE에 내장되어 있으며 Mca 참조 포인트를 통해서 MN-CSE와 상호작용하는 게이트웨이 애플리케이션이다.기능 설계: 등록 (Registration)등록(Registration)은 M2M 서비스를 사용하기 위해 AE 또는 CSE를 등록해야 한다. Originator (요청자) Receiver(Registrar) (수용자) ADN-AE MN-CSE, IN-CSE ASN-AE ASN-CSE MN-AE MN-CSE IN-AE IN-CSE ASN-CSE MN-CSE, IN-CSE MN-CSE MN-CSE, IN-CSE 기능 설계: 구독 (SUB - Subscription &amp;amp; Notification)구독(Subscription)은 애플리케이션간(AE) 데이터 교환에 유용하게 쓰이는 기능이다. CSE 내부에는 많은 데이터/서비스가 리소스의 형태로 저장되어 있고, 애플리케이션은 이러한 리소스를 통하여 데이터들을 읽고 쓰는 등의 사용을 할 수 있다. 애플리케이션이 특정 리소스에 관심이 있어 해당 리소스의 상태가 변경될 경우 자동으로 이러한 정보를 알림 받고자 할 경우 CSE가 제공하는 구독 기능을 이용할 수 있다. 속성 설명 eventNotificationCriteria Subscribed-to 리소스에 발생하는 Event 중 특정 조건을 만족하는Notification을 수신하고자 할 때 설정 expirationCounter 해당 Counter 만큼의 Notification 전송시 Subscription 리소스 삭제됨 notificationURI Notification이 전송되는 URI batchNotify 특정 시간/개수의 Notification을 통합하여 Batch Notification으로수신하고자 할 때 설정 rateLimit 특정 시간 동안 특정 개수 이상의 Notification 수신을 제한하기위해 설정 notificationEventCat Notification에 설정되는 QoS 카테고리 정보 pendingNotification Reachability 및 Schedule에 의해 전송되지 못한 Notification을 재전송하기 위한 Policy 정보 notificationStoragePriority Notification이 바로 전송되지 않고 저장될 때 저장 우선 순위 정보 notificationContentType Notification 메시지에 포함되는 데이터 구성(E.g., Modificated Attribute Only, Whole Resource) References 2강 oneM2M 애플리케이션 개발 절차(1)" }, { "title": "1. oneM2M 기술규격 및 기술문서 소개", "url": "/posts/oneM2M-technical-standards-and-technical-documents/", "categories": "IoT, oneM2M", "tags": "IoT, oneM2M", "date": "2022-02-19 00:05:08 +0900", "snippet": "개요oneM2M은 에너지, 교통, 국방, 공공서비스 등 산업별로 종속적이고 폐쇄적으로 운영되는, 파편화된 서비스 플랫폼 개발 구조를 벗어나 응용서비스 인프라(플랫폼) 환경을 통합하고 공유하기 위한 사물인터넷 공통서비스 플랫폼 개발을 위해 발족된 사실상 표준화 단체이다.전세계 지역별 표준 개발 기구인 TTA(한국), ETSI(유럽), ATIS/TIA(북미), CCSA(중국), ARIB/TTC(일본) 등 7개의 SDO(Standard Development Organization)가 공동으로 설립했다.oneM2M 표준이 적용된 인프라 형태 Domain Node Description InfrastructureDomain InfrastructureNode (IN) 인프라 도메인에 위치한 IN-CSE를 포함하는 서버 기기를 의미함. IN은 서비스 제공자 당 한 개의 IN을 지원하는 것으로 정의되며,IN은 한 개의 CSE로만 구성이 되거나 1개 이상의 AE를 포함하는형태로 구성될 수 있다. Field Domain Middle Node (MN) 필드 도메인에 위치한 MN-CSE를 포함하는 논리적 기기로,일반적으로 여러 센서나 엑추에이터들이 연결되는 게이트웨이가이에 해당한다. MN은 한 개의 CSE로 구성되거나,하나의 CSE에 1개 이상의 AE를 포함하는 형태로 구성될 수 있다.   Application ServiceNode (ASN) 필드 도메인에 위치한 ASN-CSE와 ASN-AE를 포함하고 있는논리적 기기이다. ASN은 한 개의 CSE와 1개 이상의 AE를 포함하는형태로 구성된다. M2M 디바이스라고 생각하면 된다.   Application DedicatedNode (ADN) 필드 도메인에 위치한 ADN-AE를 포함하고 CSE를 포함하지 않는논리적 기기이다. ADN은 CSE가 1개 이상의 AE를 포함한다.센서나 엑츄에이터같이 리소스가 부족한 디바이스라고 생각하면된다. Entity Description Application Entity (AE) M2M 서비스를 제공하기 위한 애플리케이션 기능을 포함하는 논리적인엔티티를 의미한다. 각각의 AE는 유일한 AE 식별자인 AE-ID로 구별된다.애플리케이션이라고 생각하면 된다. Common Service Entity (CSE) oneM2M 서비스 플랫폼에서 공통적으로 제공되어야 하는 서비스 기능을제공하는 부분으로서, 컴퓨터 시스템에서 미들웨어 소프트웨어에 해당한다.oneM2M에서 정의한 CSE에는 총 12개의 Common Service Function (CSF)공통 서비스 기능을 포함하고 있다. 미들웨어라고 생각하면 된다. Network Service Entity (NSE) CSE가 위치한 미들웨어 하부 네트워크 서비스(underlying network service)에대한 추상화 영역으로 CSE에게 네트워크 서비스를 제공한다. 공통 서비스 기능 (Common Service Function, CSF)공통 서비스 엔티티에 포함되는 다양한 공통 서비스 기능들은 12가지로 구성되어 있으며, 이러한 기능들은 자원(Resources) 기반으로 Mcc, Mca, Mcn 참조 포인트들을 통해 제공된다.Common Service Entity (CSE) CSF Description Registration CSE 혹은 AE를 등록하는 기능 Discovery 리소스에 포함되어 있는 정보를 검색하는 기능 Security 보안 연결 제공 및 인증/권한 설정 기능 Group Management (GMG) 그룹 멤버 리소스를 관리하는 기능 Data Management &amp;amp; Repository (DMR) 데이터 저장 및 관리 기능 Subscription &amp;amp; Notification (Sub/noti) 리소스 변경에 대한 구독/알림 기능 Device Management (DMG) 디바이스 관리 기능 Network Service Exposure/Service Ex+Triggering (NSSE) 네트워크 연동 기능 Location 위치정보 제공 기능 Communication Management/Delivery Handling (CMDH) 데이터 전달 서비스를 제공하는 기능 Service Charging &amp;amp; Accounting (SCA) oneM2M 서비스 플랫폼을 통해서 제공되는서비스의 과금 체계 및 방법에 대한 기능 Application and Service Layer Management (ASM) IN, MN, ASN, AND에 위치한 AE, CSE 소프트웨어를관리하는 기능 Reference Point Description M2M Communicationwith AE (Mca) Mca는 AE와 CSE 간의 API 통신을 위한 연결 포인트이다. M2M Communicationwith CSE (Mcc) Mcc는 CSE와 다른 CSE간의 통신 연결 포인트이다. M2M Communicationwith NSE (Mcn) Mcn은 CSE와 NSE의 통신 연결 포인트이며, NSE에서 제공되는네트워크 서비스 기능을 이용할 수 있는 연결 포인트이다. M2M Communicationwith CSE of Different M2M Service Provider Mcc’는 서로 다른 서비스 제공자에 종속적인 CSE간의 포인트를가리키며, 서비스 제공자 간 CSE 사이의 통신을 지원하는연결 포인트이다. 간략한 아키텍처 참조 모델 3 가지 레이어간략한 아키텍처 참조 모델 3 가지 레이어아키텍처 참조 모델아키텍처 참조 모델특징 NoDN과 연결되는 노드는 반드시 하나 이상의 AE를 갖는다. IN, MN 등 데이터 흐름만을 제어하는 노드는 AE를 갖거나 갖지 않을 수 있다. ADN의 경우 AE가 게이트웨이(MN)를 거치지 않고 바로 IN의 CSE와 Mca로 연결될 수 있다. ASN의 경우 CSE가 게이트웨이를 거치지 않고 바로 IN의 CSE와 Mcc로 연결될 수 있다. CSE를 가지는 MN간 Mcc로 연결될 수 있다. (MN-CSE ↔ IN-CSE or MN-CSE ↔ MN-CSE) ADN-AE → MN-CSE → IN-CSE 연결 방식이 가장 일반적인 형태라고 볼 수 있다. oneM2M 규격을 따르지 않는 장치들(NoDN)도 실제 규격에는 명시되어 있지 않지만, proxy를 통해 IN, MN, ASN에 연결할 수 있다.Interworking Proxy Entity(IPE)를 규격에 넣고 정의하고 있지만, IoT 관련 규격이 전세계적으로 다양하므로 빠른 대응 및 Realse는 어려워 현재 연동 테스트 단계에 있다.References 1강 oneM2M 기술규격 및 기술문서 소개 (Youtube)" }, { "title": "[WPF] 팝업 알림창 MVVM 패턴으로 구현하기", "url": "/posts/Growl-Notification/", "categories": "C#, WPF", "tags": "WPF, MVVM, Popup Notification", "date": "2022-02-18 21:51:18 +0900", "snippet": "WPF 앱에서 특정 이벤트 발생시 화면 구석에 Popup Notification이 띄워지도록 해봅시다. 소스는 Growl Alike WPF Notifications 글을 참고해 만들었습니다. MVVM 패턴에 맞도록 변환했고, 앱 전역에서 호출할 수 있도록 정적 Singleton Wrapper 클래스를 정의하였으며, 외부에서 메시지 창 출력 요청시 메시지 타입, 이미지 타입, 커스텀 메시지 등 손쉽게 호출할 수 있도록 타입 기반으로 분리해 놓았습니다. 그리고 데스크탑 우상단이 아닌 앱 기준 우상단에 팝업창이 나타나도록 했습니다(다중 모니터를 사용하는 환경에서 앱이 최초 실행된 모니터에서만 팝업창이 나타나므로).팝업 알림창 최종 결과물 예시해당 소스에서는 default로 알림창 발생시 fade-in 효과로 2초 동안 서서히 나타나도록 되어있고, 6초동안 머물러 있다가 2초 동안 fade-out 되도록 되어 있습니다. 또한, 사용자가 fade-in 혹은 fade-out 중인 상태의 메시지 창 위에 마우스를 올리면 fade-in/out 효과가 사라지고 완전히 나타나게 됩니다. 이러한 애니메이션 효과(또는 디자인)는 입맛에 맞게 직접 수정해 사용하시면 됩니다.클래스 구조|-- Views |-- GrowlNotificationsView.xaml |-- GrowlNotificationsView.xaml.cs|-- ViewModels |-- GrowlNotificationsViewModel.cs|-- Models |-- Notificates |-- Notification.cs |-- Notificator.cs |-- NotificatorWrapper.cs |-- Structures |-- NotificationType.cs|-- Interfaces |-- IWindowFunc.cs※ GrowlNotificationsViewModel, Notificator, Notification 클래스에서 상속받는 ViewModelBase 클래스는 INotifyPropertyChanged 인터페이스를 구현하는 클래스입니다. RaisePropertyChanged 메서드는 따로 구현해 주시기 바랍니다.Views: GrowlNotificationsView.xaml &amp;amp; GrowlNotificationsView.xaml.cs UserControl이 아닌 Window 형태 DataContext는 GrowlNotificationsViewModel.cs ItemsControl에 DataContext의 Notifications가 바인딩됨&amp;lt;!-- **GrowlNotificationsView.xaml** --&amp;gt;&amp;lt;Window x:Class=&quot;__PROJECT_NAMESPACE__&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:model=&quot;clr-namespace:__PROJECT_NAMESPACE__.Models.Notificates&quot; mc:Ignorable=&quot;d&quot; Title=&quot;GrowlNotifications&quot; Height=&quot;630&quot; Width=&quot;330&quot; ShowActivated=&quot;False&quot; AllowsTransparency=&quot;True&quot; WindowStyle=&quot;None&quot; ShowInTaskbar=&quot;False&quot; Background=&quot;Transparent&quot; UseLayoutRounding=&quot;True&quot;&amp;gt; &amp;lt;Window.Resources&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;NormalBorderBrush&quot; Color=&quot;Black&quot; /&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;DefaultedBorderBrush&quot; Color=&quot;Black&quot; /&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;DisabledForegroundBrush&quot; Color=&quot;#888&quot; /&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;DisabledBackgroundBrush&quot; Color=&quot;#EEE&quot; /&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;DisabledBorderBrush&quot; Color=&quot;#AAA&quot; /&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;WindowBackgroundBrush&quot; Color=&quot;#FFF&quot; /&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;SelectedBackgroundBrush&quot; Color=&quot;#DDD&quot; /&amp;gt; &amp;lt;Style x:Key=&quot;ButtonFocusVisual&quot;&amp;gt; &amp;lt;Setter Property=&quot;Control.Template&quot;&amp;gt; &amp;lt;Setter.Value&amp;gt; &amp;lt;ControlTemplate&amp;gt; &amp;lt;Border&amp;gt; &amp;lt;Rectangle Margin=&quot;2&quot; StrokeThickness=&quot;1&quot; Stroke=&quot;#60000000&quot; StrokeDashArray=&quot;1 2&quot;/&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/ControlTemplate&amp;gt; &amp;lt;/Setter.Value&amp;gt; &amp;lt;/Setter&amp;gt; &amp;lt;/Style&amp;gt; &amp;lt;LinearGradientBrush x:Key=&quot;CloseNormal&quot; StartPoint=&quot;0.5,0&quot; EndPoint=&quot;0.5,1&quot;&amp;gt; &amp;lt;GradientStop Color=&quot;#2b2c2e&quot; Offset=&quot;0.0&quot;/&amp;gt; &amp;lt;GradientStop Color=&quot;#28292b&quot; Offset=&quot;1.0&quot;/&amp;gt; &amp;lt;/LinearGradientBrush&amp;gt; &amp;lt;LinearGradientBrush x:Key=&quot;CloseOver&quot; StartPoint=&quot;0.5,0&quot; EndPoint=&quot;0.5,1&quot;&amp;gt; &amp;lt;GradientStop Color=&quot;#68717d&quot; Offset=&quot;0.0&quot;/&amp;gt; &amp;lt;GradientStop Color=&quot;#565d66&quot; Offset=&quot;1.0&quot;/&amp;gt; &amp;lt;/LinearGradientBrush&amp;gt; &amp;lt;SolidColorBrush x:Key=&quot;ClosePressed&quot; Color=&quot;#1f1f1f&quot; /&amp;gt; &amp;lt;!-- 닫기 버튼 스타일 --&amp;gt; &amp;lt;Style x:Key=&quot;CloseButton&quot; TargetType=&quot;{x:Type Button}&quot;&amp;gt; &amp;lt;Setter Property=&quot;SnapsToDevicePixels&quot; Value=&quot;true&quot;/&amp;gt; &amp;lt;Setter Property=&quot;OverridesDefaultStyle&quot; Value=&quot;true&quot;/&amp;gt; &amp;lt;Setter Property=&quot;FocusVisualStyle&quot; Value=&quot;{StaticResource ButtonFocusVisual}&quot;/&amp;gt; &amp;lt;Setter Property=&quot;MinHeight&quot; Value=&quot;16&quot;/&amp;gt; &amp;lt;Setter Property=&quot;MinWidth&quot; Value=&quot;16&quot;/&amp;gt; &amp;lt;Setter Property=&quot;Cursor&quot; Value=&quot;Hand&quot;/&amp;gt; &amp;lt;Setter Property=&quot;Template&quot;&amp;gt; &amp;lt;Setter.Value&amp;gt; &amp;lt;ControlTemplate TargetType=&quot;{x:Type Button}&quot;&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;Border x:Name=&quot;Border&quot; CornerRadius=&quot;3&quot; BorderThickness=&quot;0&quot; ClipToBounds=&quot;False&quot; Background=&quot;{StaticResource CloseNormal}&quot; BorderBrush=&quot;{StaticResource NormalBorderBrush}&quot;&amp;gt; &amp;lt;Border.Effect&amp;gt; &amp;lt;DropShadowEffect ShadowDepth=&quot;0&quot; Opacity=&quot;.4&quot; BlurRadius=&quot;5&quot; Color=&quot;Black&quot;/&amp;gt; &amp;lt;/Border.Effect&amp;gt; &amp;lt;Grid&amp;gt; &amp;lt;Image Source=&quot;pack://application:,,,/Resources/close.png&quot; IsHitTestVisible=&quot;False&quot; Margin=&quot;2&quot;&amp;gt; &amp;lt;Image.Effect&amp;gt; &amp;lt;DropShadowEffect Direction=&quot;90&quot; ShadowDepth=&quot;1&quot; BlurRadius=&quot;1&quot;/&amp;gt; &amp;lt;/Image.Effect&amp;gt; &amp;lt;/Image&amp;gt; &amp;lt;ContentPresenter HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot; RecognizesAccessKey=&quot;True&quot;/&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;ControlTemplate.Triggers&amp;gt; &amp;lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&amp;gt; &amp;lt;Setter TargetName=&quot;Border&quot; Property=&quot;Background&quot; Value=&quot;{StaticResource CloseOver}&quot; /&amp;gt; &amp;lt;/Trigger&amp;gt; &amp;lt;Trigger Property=&quot;IsPressed&quot; Value=&quot;True&quot;&amp;gt; &amp;lt;Setter TargetName=&quot;Border&quot; Property=&quot;Background&quot; Value=&quot;{StaticResource ClosePressed}&quot; /&amp;gt; &amp;lt;/Trigger&amp;gt; &amp;lt;Trigger Property=&quot;IsKeyboardFocused&quot; Value=&quot;true&quot;&amp;gt; &amp;lt;Setter TargetName=&quot;Border&quot; Property=&quot;BorderBrush&quot; Value=&quot;{StaticResource DefaultedBorderBrush}&quot; /&amp;gt; &amp;lt;/Trigger&amp;gt; &amp;lt;Trigger Property=&quot;IsDefaulted&quot; Value=&quot;true&quot;&amp;gt; &amp;lt;Setter TargetName=&quot;Border&quot; Property=&quot;BorderBrush&quot; Value=&quot;{StaticResource DefaultedBorderBrush}&quot; /&amp;gt; &amp;lt;/Trigger&amp;gt; &amp;lt;Trigger Property=&quot;IsEnabled&quot; Value=&quot;false&quot;&amp;gt; &amp;lt;Setter TargetName=&quot;Border&quot; Property=&quot;Background&quot; Value=&quot;{StaticResource DisabledBackgroundBrush}&quot; /&amp;gt; &amp;lt;Setter TargetName=&quot;Border&quot; Property=&quot;BorderBrush&quot; Value=&quot;{StaticResource DisabledBorderBrush}&quot; /&amp;gt; &amp;lt;Setter Property=&quot;Foreground&quot; Value=&quot;{StaticResource DisabledForegroundBrush}&quot;/&amp;gt; &amp;lt;/Trigger&amp;gt; &amp;lt;/ControlTemplate.Triggers&amp;gt; &amp;lt;/ControlTemplate&amp;gt; &amp;lt;/Setter.Value&amp;gt; &amp;lt;/Setter&amp;gt; &amp;lt;/Style&amp;gt; &amp;lt;Storyboard x:Key=&quot;CollapseStoryboard&quot;&amp;gt; &amp;lt;DoubleAnimation From=&quot;100&quot; To=&quot;0&quot; Storyboard.TargetProperty=&quot;Height&quot; Duration=&quot;0:0:1&quot;/&amp;gt; &amp;lt;/Storyboard&amp;gt; &amp;lt;!-- DataType을 Notification.cs로 지정 --&amp;gt; &amp;lt;DataTemplate x:Key=&quot;MessageTemplate&quot; DataType=&quot;model:Notification&quot;&amp;gt; &amp;lt;Grid x:Name=&quot;NotificationWindow&quot; Tag=&quot;{Binding Path=Id}&quot; Background=&quot;Transparent&quot; SizeChanged=&quot;NotificationWindowSizeChanged&quot;&amp;gt; &amp;lt;Border Name=&quot;border&quot; Background=&quot;#252525&quot; BorderThickness=&quot;0&quot; CornerRadius=&quot;1&quot; Margin=&quot;1, 5&quot;&amp;gt; &amp;lt;Border.Effect&amp;gt; &amp;lt;DropShadowEffect ShadowDepth=&quot;0&quot; Opacity=&quot;0.8&quot; BlurRadius=&quot;10&quot;/&amp;gt; &amp;lt;/Border.Effect&amp;gt; &amp;lt;Grid Height=&quot;70&quot; Width=&quot;280&quot; Margin=&quot;6&quot;&amp;gt; &amp;lt;Grid.RowDefinitions&amp;gt; &amp;lt;RowDefinition Height=&quot;Auto&quot;&amp;gt;&amp;lt;/RowDefinition&amp;gt; &amp;lt;RowDefinition Height=&quot;*&quot;&amp;gt;&amp;lt;/RowDefinition&amp;gt; &amp;lt;/Grid.RowDefinitions&amp;gt; &amp;lt;Grid.ColumnDefinitions&amp;gt; &amp;lt;ColumnDefinition Width=&quot;Auto&quot;&amp;gt;&amp;lt;/ColumnDefinition&amp;gt; &amp;lt;ColumnDefinition Width=&quot;*&quot;&amp;gt;&amp;lt;/ColumnDefinition&amp;gt; &amp;lt;/Grid.ColumnDefinitions&amp;gt; &amp;lt;!-- 좌측 메인 이미지 --&amp;gt; &amp;lt;Image Grid.RowSpan=&quot;2&quot; Source=&quot;{Binding Path=ImageUrl}&quot; Margin=&quot;0, 4, 12, 4&quot; Width=&quot;60&quot;&amp;gt;&amp;lt;/Image&amp;gt; &amp;lt;!-- 제목 --&amp;gt; &amp;lt;TextBlock Grid.Column=&quot;1&quot; Text=&quot;{Binding Path=Title}&quot; TextOptions.TextRenderingMode=&quot;ClearType&quot; TextOptions.TextFormattingMode=&quot;Display&quot; Foreground=&quot;White&quot; FontFamily=&quot;Arial&quot; FontSize=&quot;14&quot; FontWeight=&quot;Bold&quot; VerticalAlignment=&quot;Center&quot; Margin=&quot;2,4,4,2&quot; TextWrapping=&quot;Wrap&quot; TextTrimming=&quot;CharacterEllipsis&quot; /&amp;gt; &amp;lt;!-- 닫기 버튼 --&amp;gt; &amp;lt;Button x:Name=&quot;CloseButton&quot; Grid.Column=&quot;1&quot; Width=&quot;16&quot; Height=&quot;16&quot; HorizontalAlignment=&quot;Right&quot; Margin=&quot;0&quot; Style=&quot;{StaticResource CloseButton}&quot; /&amp;gt; &amp;lt;!-- 본문 --&amp;gt; &amp;lt;TextBlock Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; Text=&quot;{Binding Path=Message}&quot; TextOptions.TextRenderingMode=&quot;ClearType&quot; TextOptions.TextFormattingMode=&quot;Display&quot; Foreground=&quot;White&quot; FontFamily=&quot;Arial&quot; VerticalAlignment=&quot;Center&quot; Margin=&quot;2,2,8,6&quot; TextWrapping=&quot;Wrap&quot; TextTrimming=&quot;CharacterEllipsis&quot; /&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;/Border&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;DataTemplate.Triggers&amp;gt; &amp;lt;EventTrigger RoutedEvent=&quot;Window.Loaded&quot; SourceName=&quot;NotificationWindow&quot;&amp;gt; &amp;lt;BeginStoryboard x:Name=&quot;FadeInStoryBoard&quot;&amp;gt; &amp;lt;Storyboard&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;NotificationWindow&quot; From=&quot;0.01&quot; To=&quot;1&quot; Storyboard.TargetProperty=&quot;Opacity&quot; Duration=&quot;0:0:1&quot;/&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;NotificationWindow&quot; From=&quot;1&quot; To=&quot;0&quot; Storyboard.TargetProperty=&quot;Opacity&quot; Duration=&quot;0:0:2&quot; BeginTime=&quot;0:0:6&quot;/&amp;gt; &amp;lt;/Storyboard&amp;gt; &amp;lt;/BeginStoryboard&amp;gt; &amp;lt;/EventTrigger&amp;gt; &amp;lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&amp;gt; &amp;lt;Trigger.EnterActions&amp;gt; &amp;lt;SeekStoryboard Offset=&quot;0:0:3&quot; BeginStoryboardName=&quot;FadeInStoryBoard&quot; /&amp;gt; &amp;lt;PauseStoryboard BeginStoryboardName=&quot;FadeInStoryBoard&quot; /&amp;gt; &amp;lt;/Trigger.EnterActions&amp;gt; &amp;lt;Trigger.ExitActions&amp;gt; &amp;lt;SeekStoryboard Offset=&quot;0:0:3&quot; BeginStoryboardName=&quot;FadeInStoryBoard&quot; /&amp;gt; &amp;lt;ResumeStoryboard BeginStoryboardName=&quot;FadeInStoryBoard&quot;&amp;gt;&amp;lt;/ResumeStoryboard&amp;gt; &amp;lt;/Trigger.ExitActions&amp;gt; &amp;lt;/Trigger&amp;gt; &amp;lt;EventTrigger RoutedEvent=&quot;Button.Click&quot; SourceName=&quot;CloseButton&quot;&amp;gt; &amp;lt;BeginStoryboard&amp;gt; &amp;lt;Storyboard&amp;gt; &amp;lt;DoubleAnimation Storyboard.TargetName=&quot;NotificationWindow&quot; From=&quot;1&quot; To=&quot;0&quot; Storyboard.TargetProperty=&quot;(Grid.Opacity)&quot; Duration=&quot;0:0:0&quot;/&amp;gt; &amp;lt;/Storyboard&amp;gt; &amp;lt;/BeginStoryboard&amp;gt; &amp;lt;/EventTrigger&amp;gt; &amp;lt;Trigger SourceName=&quot;NotificationWindow&quot; Property=&quot;Opacity&quot; Value=&quot;0&quot;&amp;gt; &amp;lt;Setter TargetName=&quot;NotificationWindow&quot; Property=&quot;Visibility&quot; Value=&quot;Hidden&quot;&amp;gt;&amp;lt;/Setter&amp;gt; &amp;lt;Trigger.EnterActions&amp;gt; &amp;lt;BeginStoryboard Storyboard=&quot;{StaticResource CollapseStoryboard}&quot;/&amp;gt; &amp;lt;/Trigger.EnterActions&amp;gt; &amp;lt;/Trigger&amp;gt; &amp;lt;/DataTemplate.Triggers&amp;gt; &amp;lt;/DataTemplate&amp;gt; &amp;lt;/Window.Resources&amp;gt; &amp;lt;!-- DataContext는 Code-Behind에서 정의됐음 DataContext: GrowlNotificationsViewModel은 ItemsControl의 DataContext ItmesSource: GrowlNotificationsViewModel에서 Notification 소스에 바인딩 ItemTemplate: 각 메시지 아이템의 속성 (각각 다른 값을 지님) --&amp;gt; &amp;lt;ItemsControl x:Name=&quot;NotificationsControl&quot; FocusVisualStyle=&quot;{x:Null}&quot; ItemsSource=&quot;{Binding Notifications}&quot; ItemTemplate=&quot;{StaticResource MessageTemplate}&quot; /&amp;gt;&amp;lt;/Window&amp;gt;// **GrowlNotificationsView.xaml.cs**namespace __PROJECT_NAMESPACE__{ using System; using System.Windows; using System.Windows.Controls; using __PROJECT_NAME__.Models.Notificates; using __PROJECT_NAME__.ViewModels.Interfaces; using __PROJECT_NAME__.ViewModels.Windows; using __PROJECT_NAME__.Models.Structures; public partial class GrowlNotificationsView : Window { #region fields /// &amp;lt;summary&amp;gt; Top margin. &amp;lt;/summary&amp;gt; int _topOffset = 20; /// &amp;lt;summary&amp;gt; Left margin. &amp;lt;/summary&amp;gt; int _leftOffset = 335; #endregion fields #region ctors public GrowlNotificationsView() { DataContext = new GrowlNotificationsViewModel(); Initialized += GrowlNotificationsView_Loaded; InitializeComponent(); this.Top = App.Current.MainWindow.Top + _topOffset; this.Left = App.Current.MainWindow.Left + App.Current.MainWindow.Width - _leftOffset; } #endregion ctors #region methods /// &amp;lt;summary&amp;gt; /// MainWIndow의 Location 값이 변동됐을 때 MainWindow의 Top, Left 값과 offset 값을 활용해 우상단에 고정되도록 값 조정. /// &amp;lt;/summary&amp;gt; public void SetLocation() { this.Top = App.Current.MainWindow.Top + _topOffset; this.Left = App.Current.MainWindow.Left + App.Current.MainWindow.Width - _leftOffset; } /// &amp;lt;summary&amp;gt; /// MainWindow의 Width, Height 값이 변동됐을 때 MainWindow의 Top, Left 값과 offset 값을 활용해 우상단에 고정되도록 값 조정. /// &amp;lt;/summary&amp;gt; public void SetActualLocation() { if (App.Current.MainWindow.WindowState.Equals(WindowState.Maximized)) { this.Top = _topOffset; // 두 개 이상의 모니터를 쓰는 환경에서 메인 모니터의 좌측 서브 모니터로 앱을 옮긴 경우 위치 조정 this.Left = App.Current.MainWindow.Left &amp;lt; 0 ? -_leftOffset : App.Current.MainWindow.ActualWidth - _leftOffset; return; } this.Top = App.Current.MainWindow.Top + _topOffset; this.Left = App.Current.MainWindow.Left + App.Current.MainWindow.ActualWidth - _leftOffset; } /// &amp;lt;summary&amp;gt; /// GrowlNotificationsView가 렌더된 후 DataContext의 Show, Hide에 /// 창 닫기, 열기 메서드를 익명함수로 넘겨 DataContext가 Show, Hide를 호출할 수 있도록 합니다. /// &amp;lt;/summary&amp;gt; private void GrowlNotificationsView_Loaded(object sender, EventArgs e) { if (DataContext is IWindowFunc vm) { try { vm.Show = () =&amp;gt; { this.Show(); }; vm.Hide = () =&amp;gt; { this.Hide(); }; } catch (Exception) { NotificatorWrapper.AddNotification(new Notification(MessageType.custom, &quot;[GrowlNotificationsView.xaml.cs] Show() &amp;amp; Hide() 호출 에러 발생.&quot;, ImageType.error)); } } } /// &amp;lt;summary&amp;gt; Grid의 SizeChanged 이벤트 &amp;lt;/summary&amp;gt; private void NotificationWindowSizeChanged(object sender, SizeChangedEventArgs e) { if (e.NewSize.Height != 0.0) return; int gridTagId = int.Parse((sender as Grid).Tag.ToString()); NotificatorWrapper.RemoveNotification(gridTagId); } #endregion methods }}Notification이 새로 추가되면 고유 ID를 할당받습니다. 이 고유한 ID는 Notifications 컬렉션에서 Notification 요소를 제거할 때 필요합니다. View에서 팝업창이 하나 사라질 때, 즉 Collapsed 상태가 되면 Height가 0이 됩니다. View의 Code-Behind 영역에서 NotificationWindowSizeChanged 메서드를 통해 Height가 0인 것을 알아차렸을 때(팝업창 하나가 사라짐을 알았을 때) 요소 하나를 제거하도록 합니다.ViewModels: GrowlNotificationsViewModel.cs 뷰의 뷰모델로서, Notification들을 담는 Notifications 컬렉션을 프로퍼티로 참조해 뷰에 바인딩 Notificator 객체가 뷰 Window를 Show 혹은 Hide 할 수 있도록 Action 델리게이트를 인터페이스로 전달받음namespace __PROJECT_NAMESPACE__{ using System; using __PROJECT_NAME__.Models.Notificates; using __PROJECT_NAME__.ViewModels.Interfaces; /// &amp;lt;summary&amp;gt; /// Notificator.cs의 Notifications &amp;amp; buffer 컬랙션에 담길 Model 데이터 클래스 /// &amp;lt;/summary&amp;gt; internal class GrowlNotificationsViewModel : ViewModelBase, IWindowFunc { #region fields /// &amp;lt;summary&amp;gt; /// NotificationWrapper-&amp;gt;Notification.Notifications ObservableCollection를 참조하는 프로퍼티. /// View와 바인딩되어 있는 Notifications 프로퍼티는 Notificator내의 notifications 객체를 참조하는 형식이다. /// &amp;lt;/summary&amp;gt; private Notifications _Notifications = null; #endregion fields #region ctors /// &amp;lt;summary&amp;gt; /// MainWindow가 렌더링된 시점에 _growlNotificationsView(GrowlNotificationsView type) 객체 생성. 생성시 코드 플로우는 다음과 같다. /// 1. _growlNotificationsView의 기본생성자 호출 /// 2. DataContext에 뷰모델 객체 GrowlNotificationsViewModel() 바인딩 /// 3. InitializeComponent() 호출 /// 4. GrowlNotificationsView.xaml 코드가 실행되어 각 Element에 대응되는 클래스 생성된 후 렌더링 /// 5. GrowlNotificationsView.xaml의 최하단에 ItemsControl의 속성 ItemsSource에 팝업 메시지가 담긴 ObservableCollection 객체 Notifications 바인딩 /// ItemsControl의 속성 ItemTemplate에 key 이름이 &quot;MessageTemplate&quot;인 DataTemplate로 지정해 해당 템플릿에서 정의한 스타일 및 애니메이션 기반으로 메시지가 출력되도록 함 /// &amp;lt;/summary&amp;gt; public GrowlNotificationsViewModel() { _Notifications ??= NotificatorWrapper.GetNotifications(); // this에 대한 참조를 Notificator에 주입 (Show(), Hide() 호출 위함) NotificatorWrapper.InjectDependency(this); } #endregion ctors #region properties /// &amp;lt;summary&amp;gt; /// Singleton Notificator.Notifications 객체 주소를 참조하는 프로퍼티. /// &amp;lt;/summary&amp;gt; public Notifications Notifications { get =&amp;gt; _Notifications; set { if (_Notifications != value) { _Notifications = value; RaisePropertyChanged(nameof(Notifications)); } } } #region GrowlNotificationsView Window Show() &amp;amp; Hide() // GrowlNotificationsView의 Window가 Loaded 상태에 놓여 GrowlNotificationsView_Loaded가 실행됐을 때, // 이 Action 델리게이트에 this.Show()를 포함하는 람다 코드 전달 public Action Show { get; set; } public Action Hide { get; set; } #endregion GrowlNotificationsView Window Show() &amp;amp; Hide() #endregion properties }}Models: Notification.cs GrowlNotificationsView에 컬렉션 형태로 바인딩 될 Model 클래스 팝업창의 기본적인 메타데이터 포함ex) Title, MsgType, Message, ImageUrl, Id 외부에서 NotificatorWrapper.AddNotification 및 NotificatorWrapper.RemoveNotification 을 호출할 때 파라미터로 활용됨namespace __PROJECT_NAMESPACE__{ using System.Linq; using System.Collections.ObjectModel; using __PROJECT_NAME__.Models.Structures; /// &amp;lt;summary&amp;gt; Notification을 담을 컬렉션 &amp;lt;/summary&amp;gt; internal class Notifications : ObservableCollection&amp;lt;Notification&amp;gt; { } /// &amp;lt;summary&amp;gt; /// Notificator.cs의 Notifications &amp;amp; buffer 컬랙션에 담길 Model 데이터 클래스 /// &amp;lt;/summary&amp;gt; internal class Notification : ViewModelBase { #region fields private string _Message; /// &amp;lt;summary&amp;gt; /// 외부에서 AddNotification 호출시 MessageType을 정의하지 않을 경우 /// Custom 메시지로 간주하므로 반드시 Message를 입력해야 함 /// &amp;lt;/summary&amp;gt; private MessageType _MsgType = MessageType.custom; private int _Id; private string _ImageUrl; private string _Title; #endregion fields #region ctors /// &amp;lt;summary&amp;gt; /// 메시지 생성자. /// default of imgType = ImageType.info /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;msgType&quot;&amp;gt; 메시지 타입 &amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;msg&quot;&amp;gt; 메시지 &amp;lt;/param&amp;gt; /// &amp;lt;param name=&quot;imgType&quot;&amp;gt; 이미지 타입 &amp;lt;/param&amp;gt; public Notification(MessageType msgType, string msg = null, ImageType imgType = (ImageType)0) { string mt = msgType.ToString(); if (msgType == MessageType.custom) { if (string.IsNullOrEmpty(msg)) throw new System.NotImplementedException(&quot;[Notification.cs] 메시지타입이 custom이나, message가 비어있습니다.&quot;); Message = msg; } else Message = EnumHelper.GetDescription(msgType); /* * info, warn 그리고 error 이 세 가지의 타입만으론 부족해 더 많은 타입을 추가해야 한다면 * 타입을 한 단계 더 높게 추상화 하시면 if-else 문을 제거하실 수 있습니다. */ if (NotificationType.infoList.Contains(mt)) { Title = ImageType.info.ToString(); ImageUrl = EnumHelper.GetDescription(ImageType.info); } else if (NotificationType.warningList.Contains(mt)) { Title = ImageType.warn.ToString(); ImageUrl = EnumHelper.GetDescription(ImageType.warn); } else if (NotificationType.errorList.Contains(mt)) { Title = ImageType.error.ToString(); ImageUrl = EnumHelper.GetDescription(ImageType.error); } else // MessageType.custom { Title = imgType.ToString(); ImageUrl = EnumHelper.GetDescription(imgType); } } public Notification() { } #endregion ctors #region properties /// &amp;lt;summary&amp;gt; Notification의 본문 메시지 &amp;lt;/summary&amp;gt; public string Message { get { return _Message; } set { if (_Message == value) return; _Message = value; RaisePropertyChanged(nameof(Message)); } } /// &amp;lt;summary&amp;gt; Notification의 메시지 타입 &amp;lt;/summary&amp;gt; public MessageType MsgType { get { return _MsgType; } set { if (_MsgType == value) return; MsgType = value; RaisePropertyChanged(nameof(MsgType)); } } /// &amp;lt;summary&amp;gt; Grid의 Tag ID &amp;lt;/summary&amp;gt; public int Id { get { return _Id; } set { if (_Id == value) return; _Id = value; RaisePropertyChanged(nameof(Id)); } } /// &amp;lt;summary&amp;gt; Notification의 이미지 경로 &amp;lt;/summary&amp;gt; public string ImageUrl { get { return _ImageUrl; } set { if (_ImageUrl == value) return; _ImageUrl = value; RaisePropertyChanged(nameof(ImageUrl)); } } /// &amp;lt;summary&amp;gt; Notification의 타이틀 제목 &amp;lt;/summary&amp;gt; public string Title { get { return _Title; } set { if (_Title == value) return; _Title = value; RaisePropertyChanged(nameof(Title)); } } #endregion properties }}Notification.cs 클래스에서 48번째 라인부터 사용하는 EnumHelper.GetDescription 메서드는 enum 값에 붙은 Description string 값을 얻게 해주는 역할을 합니다. 코드는 다음과 같습니다.namespace __PROJECT_NAMESPACE__{ using System; using System.ComponentModel; using System.Reflection; public static class EnumHelper { /// &amp;lt;summary&amp;gt; /// Enum의 특정 인덱스의 Description 반환 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;en&quot;&amp;gt; description을 받아올 enum 인덱스 &amp;lt;/param&amp;gt; public static string GetDescription(Enum en) { Type type = en.GetType(); MemberInfo[] memInfo = type.GetMember(en.ToString()); if (memInfo != null &amp;amp;&amp;amp; memInfo.Length &amp;gt; 0) { // 해당 인덱스의 Description raw text 추출 object[] attrs = memInfo[0].GetCustomAttributes(typeof(DescriptionAttribute), false); if (attrs != null &amp;amp;&amp;amp; attrs.Length &amp;gt; 0) { return ((DescriptionAttribute)attrs[0]).Description; } } return en.ToString(); } }}Models: Notificator.cs Notification을 담는 ObservableCollection _notifications 객체(최대 5개)와 그 5개를 넘는 요소를 임시로 담아놓는 ObservableCollection _buffer 객체(버퍼 역할) 포함 Notification을 두 컬렉션에 Boundary check 해가며 Add, Delete 수행하는 로직 포함namespace __PROJECT_NAMESPACE__{ using System; using System.Linq; using __PROJECT_NAME__.Models.Structures; using __PROJECT_NAME__.ViewModels.Interfaces; internal class Notificator : ViewModelBase, IDisposable { #region fields private static readonly log4net.ILog logger = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType); /// &amp;lt;summary&amp;gt; 최대 메시지 수 &amp;lt;/summary&amp;gt; private const byte MAX_NOTIFICATIONS = 5; /// &amp;lt;summary&amp;gt; 최대 버퍼 메시지 수 &amp;lt;/summary&amp;gt; private const byte MAX_BUFFER_SIZE = 8; /// &amp;lt;summary&amp;gt; 메시지 카운트 &amp;lt;/summary&amp;gt; private int _count; /// &amp;lt;summary&amp;gt; /// Notification 메시지들이 담긴 ObservableCollection. /// GrowlNotificationsView의 ItemsControl에 바인딩됨 /// &amp;lt;/summary&amp;gt; public static Notifications _notifications = new Notifications(); /// &amp;lt;summary&amp;gt; /// 팝업창을 닫기 위해 GrowlNotificationsView의 /// Show, Hide 델리게이트 참조 /// &amp;lt;/summary&amp;gt; private static IWindowFunc _growlNotificationsViewModel = null; /// &amp;lt;summary&amp;gt; /// &quot;if) count &amp;gt; MAX_NOTIFICATIONS == true&quot; 일 경우 /// 담을 buffer ObservableCollection /// &amp;lt;/summary&amp;gt; private Notifications _buffer = new Notifications(); /// &amp;lt;summary&amp;gt; 중복 호출 검색 &amp;lt;/summary&amp;gt; private bool _disposedValue = false; #endregion fields #region methods /// &amp;lt;summary&amp;gt; Notificator의 Notifications를 Get &amp;lt;/summary&amp;gt; public Notifications GetNotifications() { return _notifications; } /// &amp;lt;summary&amp;gt; /// GrowlNotificationsViewModel 객체를 Injection 받는 메서드. /// 본 클래스에서 팝업창 Show(), Hide() 활용 가능 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;vm&quot;&amp;gt; Show, Hide 액션 프로퍼티 &amp;lt;/param&amp;gt; public void InjectDependency(IWindowFunc vm) { _growlNotificationsViewModel = vm; } /// &amp;lt;summary&amp;gt; /// Notifications ObervableCollection에 Notification 객체 enqueue. /// UI Thread와 현재 Thread의 상이함(Cross-Thread issue)을 해결하기 위해 /// AppDomain의 Dispatcher thread에 delegate 코드 위임 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;notification&quot;&amp;gt; 팝업창 Model &amp;lt;/param&amp;gt; private void Add(Notification notification) { App.Current.Dispatcher.Invoke(new Action(() =&amp;gt; { _notifications.Add(notification); })); } /// &amp;lt;summary&amp;gt; /// Notifications에서 노드 하나 Remove /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;notification&quot;&amp;gt; 팝업창 Model &amp;lt;/param&amp;gt; private void Remove(Notification notification) { App.Current.Dispatcher.Invoke(new Action(() =&amp;gt; { _notifications.Remove(notification); })); } /// &amp;lt;summary&amp;gt; /// GrowlNotificationsView Window를 Show /// &amp;lt;/summary&amp;gt; private void Show() { App.Current.Dispatcher.Invoke(new Action(() =&amp;gt; { _growlNotificationsViewModel.Show(); })); } /// &amp;lt;summary&amp;gt; /// GrowlNotificationsView Window를 Hide /// &amp;lt;/summary&amp;gt; private void Hide() { App.Current.Dispatcher.Invoke(new Action(() =&amp;gt; { _growlNotificationsViewModel.Hide(); })); } /// &amp;lt;summary&amp;gt; /// 메시지를 버퍼에 추가. /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;notification&quot;&amp;gt; 팝업창 Model &amp;lt;/param&amp;gt; private void AddToBuffer(Notification notification) { if (!CheckLimitation()) return; _buffer.Add(notification); } /// &amp;lt;summary&amp;gt; /// Notifications 큐 컬렉션에 Notification 추가. /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;notification&quot;&amp;gt;&amp;lt;/param&amp;gt; public void AddNotification(Notification notification) { try { notification.Id = _count++; if (_notifications.Count + 1 &amp;gt; MAX_NOTIFICATIONS) AddToBuffer(notification); else Add(notification); // notifications가 있을 경우 window를 띄움 if (_notifications.Count &amp;gt; 0) Show(); } catch (Exception ex) { System.Diagnostics.Debug.Print(ex.ToString()); logger.Error($&quot;Notificator 에러 발생. \\n{ex}\\n&quot;); } } /// &amp;lt;summary&amp;gt; /// Notifications 큐 컬렉션에 Notification 제거. /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;gridTagId&quot;&amp;gt; 제거할 Notification Model ID &amp;lt;/param&amp;gt; public void RemoveNotification(int gridTagId) { // 제거해야 하는 Notification 쿼리 Notification nodeToDelete = _notifications.First(n =&amp;gt; n.Id == gridTagId); if (nodeToDelete == null) throw new NotImplementedException(&quot;[Notificator.cs] nodeToDelete == null&quot;); if (_notifications.Contains(nodeToDelete)) Remove(nodeToDelete); if (_buffer.Count &amp;gt; 0) { Add(_buffer[0]); if (_buffer.Count &amp;gt; 0) _buffer.RemoveAt(0); } // 더이상 보여줄 notifications가 없을 경우 윈도우 닫음 if (_notifications.Count &amp;lt; 1) Hide(); } private bool CheckLimitation() { try { if ((_buffer.Count + 1) &amp;gt; MAX_BUFFER_SIZE) { throw new Exception(&quot;작업 요청이 너무 많습니다. 잠시 후 다시 시도해 주세요.&quot;, new System.InvalidOperationException()); } return true; } catch (Exception ex) { // buffer의 맨 앞 요소 제거 후 위 Exception 메시지 추가 _buffer.Clear(); NotificatorWrapper.AddNotification(new Notification(MessageType.custom, ex.Message, ImageType.error)); return false; } } #endregion methods #region IDisposable Support public void Dispose() { Dispose(true); } protected virtual void Dispose(bool disposing) { if (!_disposedValue) { if (disposing) { _notifications = null; _buffer = null; } _disposedValue = true; } } #endregion IDisposable Support }}Models: NotificatorWrapper.cs Notificator를 캡슐화 Notificator를 외부에서 호출할 수 있도록 static으로 만들었으며, 유일한 객체를 가지므로 Singleton 역할을 함 (Redundancy DCL) MainWindow OnClosing 시점에 Raise 되는 메서드 내 초입에서 Dispose 호출해 메모리 명시적 수집. (프로그램이 닫혔는데도 메모리상 static 객체가 동적 객체를 지속해서 참조하는 행위 방지)namespace __PROJECT_NAMESPACE__{ using System; using System.Threading.Tasks; using __PROJECT_NAME__.ViewModels.Interfaces; internal class NotificatorWrapper { #region fields private static NotificatorWrapper _instance; private Notificator Origin { get; set; } private static readonly object lockObj = new object(); #endregion fields #region ctors private NotificatorWrapper() { Origin = new Notificator(); } #endregion ctors #region properties private static NotificatorWrapper Instance { get { // double-checked locking if (_instance == null) { lock (lockObj) { if (_instance == null) { _instance = new NotificatorWrapper(); } } } return _instance; } } #endregion properties #region methods /// &amp;lt;summary&amp;gt; /// GrowlNotificationsViewModel 객체를 Injection 받는 메서드. /// Notificator 클래스에서 팝업창 Show(), Hide() 할 수 있도록 주입 /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;vm&quot;&amp;gt; Show, Hide 액션 프로퍼티 &amp;lt;/param&amp;gt; public void InjectDependency(IWindowFunc vm) { Instance.Origin.InjectDependency(vm); } /// &amp;lt;summary&amp;gt; /// Notificator의 Notifications를 return하여 참조할 수 있도록 함. /// &amp;lt;/summary&amp;gt; public static Notifications GetNotifications() { return Instance.Origin.GetNotifications(); } /// &amp;lt;summary&amp;gt; /// Notifications 큐 컬렉션에 Notification 추가. /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;notification&quot;&amp;gt;&amp;lt;/param&amp;gt; public static void AddNotification(Notification notification) { // Invoke to Thread Pool Thread to avoid overhead using fire &amp;amp; forget Task.Run(new Action(() =&amp;gt; Instance.Origin.AddNotification(notification) )).ConfigureAwait(false); } /// &amp;lt;summary&amp;gt; /// Notifications 큐 컬렉션에서 Notification 제거. /// &amp;lt;/summary&amp;gt; /// &amp;lt;param name=&quot;gridTagId&quot;&amp;gt;&amp;lt;/param&amp;gt; public static void RemoveNotification(int gridTagId) { Task.Run(new Action(() =&amp;gt; Instance.Origin.RemoveNotification(gridTagId) )).ConfigureAwait(false); } public static void Release() { Instance.Origin.Dispose(); _instance = null; } #endregion methods }}팝업창을 띄우려면 다음과 같이 Wrapper 객체의 AddNotification 메서드를 호출하면 됩니다.// 사용자 정의 메시지 팝업NotificatorWrapper.AddNotification(new Notification(MessageType.custom, $&quot;[EXE:Communicator] {errMsg}&quot;, ImageType.error));NotificatorWrapper.AddNotification( new Notification(MessageType.custom, $&quot;An unexpected error occurred. see /logs/global/[{DateTime.Now:yyyy.mm.dd}]global.txt file.&quot;, ImageType.error));// 메시지 타입에 따른 메시지 팝업NotificatorWrapper.AddNotification(new Notification(MessageType.noPortAvailable));NotificatorWrapper.AddNotification(new Notification(MessageType.noSlaveScanned));IWindowFunc.cs Notificator 객체가 GrowlNotificationsViewModel 객체의 Window 창을 보여주거나 가릴 수 있도록 액션 프로퍼티 Show, Hide를 노출한 인터페이스namespace __PROJECT_NAMESPACE__{ using System; internal interface IWindowFunc { /// &amp;lt;summary&amp;gt; Window Show()를 호출하는 메서드. &amp;lt;/summary&amp;gt; Action Show { get; set; } /// &amp;lt;summary&amp;gt; Window Hide()를 호출하는 메서드. &amp;lt;/summary&amp;gt; Action Hide { get; set; } /// &amp;lt;summary&amp;gt; Window OnClosing 시 호출되는 메서드. &amp;lt;/summary&amp;gt; void OnClosing(); }}NotificationType.cs 알림에 대한 메시지 타입들을 enum 형태로 저장 Notificator 클래스와 Add, Remove하는 외부 클래스에서 참조됨namespace __PROJECT_NAMESPACE__{ using System.ComponentModel; public enum MessageType { // 아래 enum 타입에 없는 경우 커스텀 메시지로 분기 custom, [Description(&quot;연결에 성공했습니다.&quot;)] connectionSuccess, [Description(&quot;타임아웃이 발생했습니다.&quot;)] timeout, [Description(&quot;포트에 접근할 수 없습니다.&quot;)] portOccupied, // etc... } public enum ImageType { [Description(&quot;pack://application:,,,/Resources/info.png&quot;)] info, /* 알림 */ [Description(&quot;pack://application:,,,/Resources/warning.png&quot;)] warn, /* 주의 */ [Description(&quot;pack://application:,,,/Resources/error.png&quot;)] error, /* 경고 */ // etc... } /// &amp;lt;summary&amp;gt; MessageType에 따른 ImageType 그룹핑 &amp;lt;/summary&amp;gt; public static class NotificationType { /// &amp;lt;summary&amp;gt; Info 그룹 &amp;lt;/summary&amp;gt; public static string[] infoList = { &quot;portOccupied&quot;, &quot;noPortAvailable&quot;, &quot;modbus_aleadyConnected&quot;, &quot;modbus_connected&quot;, }; /// &amp;lt;summary&amp;gt; Warning 그룹 &amp;lt;/summary&amp;gt; public static string[] warningList = { &quot;timeout&quot;, &quot;modbus_slaveError_read&quot;, &quot;modbus_slaveError_write&quot;, &quot;rxLimitDetected&quot;, }; /// &amp;lt;summary&amp;gt; Error 그룹 &amp;lt;/summary&amp;gt; public static string[] errorList = { &quot;modbus_crcError&quot;, &quot;modbus_connectionFailed&quot;, &quot;serial_initError&quot;, }; // etc... }}App.xaml.cs팝업창은 글로벌 영역에서 생성되어야 하므로 App.xaml.cs 에서 생성합니다.// ... App 렌더링 완료 직후 ...// 팝업 윈도우 생성. _mainWindow의 Left, Top, Width를 참조하므로 메인윈도우 생성 후 생성_growlNotificationsView = new GrowlNotificationsView();/* * _growlNotificationsView 윈도우의 소유권을 _mainWindow로 넘김 * (참조: https://docs.microsoft.com/ko-kr/dotnet/api/system.windows.window.owner?view=netcore-3.1) */_growlNotificationsView.Owner = _mainWindow;글 초입에 말씀 드렸듯이 PC 화면 우상단에 anchor되는 것이 아닌 프로그램 우상단에 anchor되도록 구현합니다./// &amp;lt;summary&amp;gt;/// 메인윈도우 Top, Left 위치 변동 감지시 팝업창 위치를/// 메인윈도우 우상단에 고정되도록 조정/// &amp;lt;/summary&amp;gt;/// &amp;lt;param name=&quot;sender&quot;&amp;gt; AppDomain &amp;lt;/param&amp;gt;private void MainWindow_LocationChanged(object sender, EventArgs e){ var window = sender as Window; // MainWindow가 Maximized 상태가 아닌 경우에만 변경해야 함 if (!window.WindowState.Equals(WindowState.Maximized)) _growlNotificationsView?.SetLocation();}/// &amp;lt;summary&amp;gt;/// 메인윈도우 ActualWidth, ActualHeight 너비 변동 감지시/// 팝업창 위치를 메인윈도우 우상단에 고정되도록 조정/// &amp;lt;/summary&amp;gt;/// &amp;lt;param name=&quot;sender&quot;&amp;gt; AppDomain &amp;lt;/param&amp;gt;private void MainWindow_SizeChanged(object sender, SizeChangedEventArgs e){ _growlNotificationsView?.SetActualLocation();}앱 종료 시에도 지속적으로 값을 참조하는 hanging 문제를 피하기 위해 앱 종료(App.OnClosing) 시점에 명시적으로 _growlNotifiactionsView.Close() 를 호출하도록 합니다._growlNotificationsView.Close();References Growl Alike WPF Notifications" }, { "title": "[Git] 분산 환경에서 프로젝트에 기여하기", "url": "/posts/Contributing-to-a-Project/", "categories": "Git, Workflow", "tags": "Workflow, Git, VCS, DVCS, Github", "date": "2022-01-13 18:20:58 +0900", "snippet": "기여하는 방식에 영향을 끼치는 변수가 다음과 같이 몇 가지 있다. 활발히 기여하는 개발자의 수가 몇인지 선택한 워크플로가 무엇인지 각 개발자에게 접근 권한을 어떻게 부여했는지 외부에서도 기여할 수 있는지 (접근 권한)첫 번째로 살펴볼 변수는 활발히 활동하는 개발자의 수이다. 이 활발한 개발자에 대한 기준은 얼마나 잦은 빈도로 코드를 쏟아내 기여하는가이다. 대부분 둘, 셋 정도의 개발자가 하루에 몇 번 커밋을 하고 활발하지 않은 프로젝트는 더 띄엄띄엄 할 것이다. 하지만, 아주 큰 프로젝트는 수백, 수천 명의 개발자가 하루에도 수십, 수백 개의 커밋을 만들어 낸다. 개발자가 많으면 많을수록 코드를 깔끔하게 적용하거나 Merge 하기 어려워진다. 어떤 커밋은 다른 개발자가 이미 기여한 내용일 경우 불필요해지기도 하고 때론 서로 충돌이 발생한다. 어떻게 해야 코드를 최신으로 유지하면서 원하는 대로 수정할 수 있을까?두 번째 변수는 프로젝트에서 선택한 워크플로가 무엇인가이다. 예시는 다음과 같다. 모든 개발자가 메인 저장소에 쓰기 권한을 갖는 중앙집중형 방식인가? 프로젝트에 모든 Patch를 검사하고 통합하는 관리자가 따로 있는가? 모든 수정사항을 개발자끼리 검토하고 승인하는가? 자신이 그저 돕는게 아니라 어떤 책임을 맡고 있는가? 중간 관리자가 있어서 그들에게 먼저 알려야 하는가?세 번째 변수는 접근 권한이다. 프로젝트에 쓰기 권한이 있어서 직접적으로 수정이 가능한 경우나 읽기만 가능한 경우에 따라서 프로젝트에 기여하는 방식이 매우 달라진다. 예시는 다음과 같다. 쓰기 권한이 없다면 어떻게 수정 사항을 프로젝트에 반영할 수 있을까? 수정사항을 적용하는 정책이 프로젝트에 있는가? 얼마나 많은 시간을 프로젝트에 할애하는가? 얼마나 자주 기여하는가?이런 저런 상황에 따라 프로젝트에 기여하는 방식과 워크플로가 달라진다. 간단한 것부터 복잡한 것까지 예제를 통해 각 상황을 살펴보면 실제 프로젝트에 필요한 워크플로를 선택하는 데 도움이 될 것이다.커밋 가이드라인프로젝트에 기여하기에 앞서 먼저 커밋 메시지 형식에 대한 주의사항을 알아보자. 커밋 메시지를 잘 작성하는 가이드라인을 알아두면 다른 개발자와 협업하는 데 도움이 많이 된다. 참고할 만한 좋은 팁들은 공식문서 SubmittingPatches에 있다.무엇보다도 먼저 공백문자를 깨끗하게 정리하고 커밋해야 한다. Git은 공백문자를 검사해볼 수 있는 간단한 명령을 제공한다. 커밋을 하기 전에 git diff --check 명령으로 공백문자에 대한 오류를 확인할 수 있다.git diff --check 결과커밋 하기 전에 공백문자를 검사하면 의미없는 공백이 불필요하게 커밋되는 것을 막을 수 있다.그리고 각 커밋은 논리적으로 구분되는 Changeset이다. 최대한 수정사항을 한 주제로 요약할 수 있어야 하고 여러 가지 이슈에 대한 수정사항을 하나의 커밋에 담지 않아야 한다. 작업 내용을 최대한 분할하고, 각 커밋마다 적절한 메시지를 작성한다. 같은 파일의 다른 부분을 수정하는 경우 git add -patch 명령을 통해 한 부분씩 나누어 Stage 해야 한다. 여러 번 나누어 커밋하면 다른 동료가 수정된 코드를 확인해야 할 때 코드 이해가 훨씬 수월해진다.마지막으로 명심해야 할 점은 커밋 메시지 구성이다. 좋은 커밋 메시지를 작성하는 습관은 Git을 사용하는 데 많은 도움이 된다. 일반적으로 커밋 메시지를 작성할 때 사용하는 규칙이 있으며 다음과 같다. 첫 라인에 50자가 넘지 않는 아주 간략한 메시지를 적어 해당 커밋을 요약한다. 다음 한 라인은 비우고 그 다음 라인부터 커밋을 자세히 설명한다.예를 들어 Git 개발 프로젝트에서는 개발 동기와 구현 상황의 제약 조건이나 상황 등을 자세하게 요구한다. 현재형 표현을 사용하는 것이 좋다. 명령문으로 시작하는 것도 좋은 방법이다.예를 들어 “I added tests for (테스트를 추가함)” 보다는 “Add tests for (테스트 추가)”가 적합하다.아래 내용은 Tim Pope가 작성한 커밋 메시지 템플릿이다.영문 50글자 이하의 간략한 수정 요약자세한 설명. 영문 72글자 이상이 되면라인 바꿈을 하고 이어지는 내용을 작성한다.특정 상황에서는 첫 번째 라인이 이메일메시지의 제목이 되고 나머지는 메일내용이 된다. 빈 라인은 본문과 요약을구별해주기에 중요하다(본문 전체를 생략하지 않는 한).이어지는 내용도 한 라인 띄우고 쓴다. - 목록 표시도 사용할 수 있다. - 보통 &#39;-&#39; 나 &#39;*&#39; 표시를 사용해서 목록을 표현하고 표시 앞에 공백 하나, 각 목록 사이에는 빈 라인 하나를 넣는데, 이건 상황에 따라 다르다.메시지를 이렇게 작성하면 함께 일하는 사람은 물론이고 본인에게도 매우 유용하다. Git 개발 프로젝트에는 잘 쓰인 커밋 메시지가 많으므로 적절한 프로젝트를 내려받아서 git log --no-merges 명령으로 꼭 살펴보기를 권한다.비공개 소규모 팀두 세 명으로 이루어진 비공개 프로젝트가 가장 간단한 프로젝트일 것이다. “비공개” 라고 함은 소스코드가 외부에서 접근할 수 없게끔 공개되지 않은 것을 말한다.이런 환경에서는 보통 Subversion 같은 중앙집중형 버전 관리 시스템에서 사용하던 방식을 사용한다. 물론 Git의 오프라인 커밋 기능이나 브랜치 Merge 기능을 이용하긴 하지만 크게 다르지 않다.가장 큰 차이점은 서버가 아닌 클라이언트 쪽에서 Merge 한다는 점이다. 두 개발자가 저장소를 공유하는 시나리오를 살펴보자. 개발자인 John는 저장소를 Clone 하고 파일을 수정하고 나서 로컬에 커밋한다.※ 예제에서 Git이 출력하는 메시지 템플릿 중 일부는 ‘…’로 줄이고 생략했다.# John 컴퓨터$ git clone john@githost:simplegit.gitCloning into &#39;simplegit&#39;......$ cd simplegit/$ vim lib/simplegit.rb$ git commit -am &#39;remove invalid default value&#39;[master 738ee87] remove invalid default value 1 files changed, 1 insertions(+), 1 deletions(-)개발자인 Jessica도 저장소를 Clone 하고 나서 파일을 하나 새로 추가하고 커밋한다.# Jessica 컴퓨터$ git clone jessica@githost:simplegit.gitCloning into &#39;simplegit&#39;......$ cd simplegit/$ vim TODO$ git commit -am &#39;add reset task&#39;[master fbff5bc] add reset task 1 files changed, 1 insertions(+), 0 deletions(-)Jessica는 서버에 커밋을 Push 한다.# Jessica 컴퓨터$ git push origin master...To jessica@githost:simplegit.git 1edee6b..fbff5bc master -&amp;gt; masterPush 명령을 실행하고 난 결과 중 마지막 줄은 유용한 정보를 보여준다. 마지막 줄의 기본 형식은 &amp;lt;oldref&amp;gt;..&amp;lt;newref&amp;gt; fromref -&amp;gt; toref 이다. 각 단어의 의미는 다음과 같다. oldref : 이전 레퍼런스 해시 newref : 새 레퍼런스 해시 fromref : Push 명령에서 사용한 로컬 레퍼런스 이름 toref : Push로 업데이트한 리모트 레퍼런스 이름이어지는 내용에서 지금 설명한 Push 명령 출력 결과가 여러번 등장하므로 위같은 메시지 포멧을 이해하고 있으면 다양한 상태에서 정확하게 어떤 일이 벌어지는가를 쉽게 이해할 수 있게 된다. 자세한 내용은 공식문서 git-push를 참고한다.다시 예제 내용으로 돌아와 John도 내용을 변경하고 커밋을 만든 후 서버로 커밋을 Push 하려 한다.# John 컴퓨터$ git push origin masterTo john@githost:simplegit.git ! [rejected] master -&amp;gt; master (non-fast forward)error: failed to push some refs to &#39;john@githost:simplegit.git&#39;Jessica의 Push한 내용으로 인해, John의 커밋은 서버에서 거절된다. Subversion을 사용했던 사람은 이 부분을 이해하는 것이 중요하다. 같은 파일을 수정한 것도 아닌데 왜 Push가 거절되는 걸까? Subversion에서는 서로 다른 파일을 수정하는 이런 Merge 작업은 자동으로 서버가 처리한다. 하지만 Git은 로컬에서 먼저 Merge 해야 한다. 다시 말해 John은 Push 하기 전에 Jessica가 수정한 커밋을 Fetch 하고 Merge 해야 한다는 말이다. 왜 먼저 원격 저장소를 Fetch를 해야 할까? John의 로컬 저장소의 master 브랜치가 원격 저장소의 origin/master 브랜치보다 커밋이 하나 뒤쳐져 있기 때문에 Push 를 하면 덮어써야만 하는 형태가 되기 때문에 Git은 실수로 남의 작업물에 덮어쓰는 불상사를 막을 뿐이다 (덮어쓰는 형태로 강제로 Push 할 순 있다. git push -f &amp;lt;remote-name&amp;gt; &amp;lt;branch name&amp;gt; 명령을 사용하면 된다).이를 위해 John은 Jessica의 작업 내용을 아래와 같이 Fetch 한다. 아래 명령은 Jessica의 작업 내용을 내려받긴 하지만 Merge 까지 하지는 않는다.$ git fetch origin...From john@githost:simplegit + 049d078...fbff5bc master -&amp;gt; origin/masterFetch 하고 나면 John의 로컬 저장소는 아래와 같이 된다.Fetch 하고 난 John의 저장소Fetch 한 작업 내용을 로컬 브랜치에 Merge 하자.$ git merge origin/masterMerge made by the &#39;recursive&#39; strategy. TODO | 1 + 1 files changed, 1 insertions(+), 0 deletions(-)Merge 후 John의 브랜치는 아래와 같은 상태가 된다.origin/master 브랜치를 Merge 하고 난 후 John의 저장소3-Way 방식으로 새 커밋을 생성해 Merge 된 것을 알 수 있다. 자신의 코드와 내려받은 코드가 정상 작동됨을 확인한 후 원격 저장소에 Push 한다.$ git push origin master...To john@githost:simplegit.git fbff5bc..72bbc59 master -&amp;gt; master이제 John의 저장소는 아래와 같이 되었다.Push 하고 난 후 John의 저장소리모트 트래킹 브랜치(origin/master)가 새로 생성된 커밋을 가리키도록 업데이트 되었다.이번에 Jessica는 토픽 브랜치를 하나 생성한다. issue54 브랜치를 만들고 세 번에 걸쳐서 커밋한다. 아직 John의 커밋을 Fetch 하지 않은 상황이기 때문에 히스토리는 아래와 같은 상황이 된다.Jessica의 토픽 브랜치Jessica는 John이 새로 Push 했다는 것을 알게 되어 하던 작업을 멈추고 John의 작업 내용을 살펴보려고 한다. 하지만 아직 Jessica는 John의 변경사항을 가지고 있지 않은 상태이다. 아래 명령으로 John이 Push 한 커밋을 모두 내려받는다.# Jessica 컴퓨터$ git fetch origin...From jessica@githost:simplegit fbff5bc..72bbc59 master -&amp;gt; origin/masterJessica의 저장소는 아래와 같은 상태가 된다.John의 커밋을 Fetch 한 후 Jessica의 저장소이제 orgin/master 와 Merge 할 차례다. Jessica는 토픽 브랜치에서의 작업을 마치고 어떤 내용이 Merge 되는지 git log 명령으로 확인한다.$ git log --no-merges issue54..origin/mastercommit 738ee872852dfaa9d6634e0dea7a324040193016Author: John Smith &amp;lt;jsmith@example.com&amp;gt;Date: Fri May 29 16:01:27 2009 -0700 remove invalid default valueissue54..origin/master 문법은 히스토리를 검색할 때 뒤의 브랜치(origin/master)에 속한 커밋 중 앞의 브랜치(issue54)에 속하지 않은 커밋을 검색하는 문법이다. 자세한 내용은 범위로 커밋 가리키기에서 다룬다.앞의 명령에 따라 히스토리를 검색한 결과 John이 생성하고 Jessica가 Merge 하지 않은 커밋을 하나 찾았다. origin/master 브랜치를 Merge 하게 되면 검색된 커밋 하나가 로컬 작업에 Merge 될 것이다.Merge 할 내용을 확인한 Jessica는 자신이 작업한 내용과 John이 Push 한 작업(origin/master)을 master 브랜치에 Merge 하고 Push 한다.issue54 토픽 브랜치에 쌓은 모든 내용을 합치려면, 우선 master 브랜치로 이동해야 한다.$ git switch masterSwitched to branch &#39;master&#39;Your branch is behind &#39;origin/master&#39; by 2 commits, and can be fast-forwarded.Jessica는 먼저 issue54 브랜치를 Merge 한다(origin/master, issue54 둘 중 아무거나 먼저 Merge 해도 된다).$ git merge issue54Updating fbff5bc..4af4298Fast forward README | 1 + lib/simplegit.rb | 6 +++++- 2 files changed, 6 insertions(+), 1 deletions(-)보다시피 Fast-forward Merge 이기 때문에 명령 실행 결과는 별 문제가 없다. origin/master에 쌓여있던 John의 작업 내용을 다음과 같이 실행하여 Jessica는 Merge 작업을 완료할 수 있다.$ git merge origin/masterAuto-merging lib/simplegit.rbMerge made by the &#39;recursive&#39; strategy. lib/simplegit.rb | 2 +- 1 files changed, 1 insertions(+), 1 deletions(-)Merge 가 잘 되면 아래와 같은 상태가 된다.John의 커밋을 Merge 후 Jessica의 저장소origin/master 브랜치가 Jessica의 master 브랜치로 나아갈(reachable) 수 있기 때문에 Push는 성공한다(물론 John이 그 사이에 Push 하지 않았다면).이제 원격 저장소에 Push 한다.$ git push origin master...To jessica@githost:simplegit.git 72bbc59..8059c15 master -&amp;gt; master두 개발자의 커밋을 성공적으로 Merge 한 결과는 아래와 같다.Jessica가 서버로 Push 하고 난 후의 저장소매우 간단한 상황의 예제를 살펴보았다. 토픽 브랜치에서 수정하고 로컬의 master 브랜치에 Merge 한다. 작업한 내용을 공유 저장소에 Push 하고자 할 때는 우선 origin/master 브랜치를 Fetch 하고 Merge 해야 한다. 그리고 나서 Merge 한 결과를 다시 서버로 Push 한다. 이런 워크플로가 일반적이며 아래와 같이 나타낼 수 있다.소규모 팀에서 사용하는 워크플로비공개 대규모 팀이제 비공개 대규모 팀에서의 워크플로를 알아본다. 이런 상황에서는 보통 팀을 여러 개로 나눈다. 각각의 작은 팀이 서로 어떻게 Merge 하는지를 살펴보자.John과 Jessica는 featureA 기능을 함께 작업하게 됐다. Jessica는 Josie와 함께 featureB 기능도 작업하고 있는 상황이다. 이런 상황이라면 회사는 Integration-Manager 워크플로를 선택하는 게 좋다. 작은 팀이 수행한 결과물은 Integration-Manager가 Merge 하고 공유 저장소의 master 브랜치를 업데이트한다. 팀 마다 브랜치를 하나씩 만들고 Integration-Manager는 그 브랜치를 Pull 해서 Merge 한다.두 팀에 모두 속한 Jessica의 작업 순서를 살펴보자. 우선 Jessica는 저장소를 Clone 하고 featureA 작업을 먼저 한다. featureA 브랜치를 만들고 수정하고 커밋한다.# Jessica 컴퓨터$ git switch -c featureASwitched to a new branch &#39;featureA&#39;$ vim lib/simplegit.rb$ git commit -am &#39;add limit to log function&#39;[featureA 3300904] add limit to log function 1 files changed, 1 insertions(+), 1 deletions(-)수정한 내용을 John과 공유하기 위해 featureA 브랜치를 서버로 Push 한다. Integration-Manager만 master 브랜치를 업데이트할 수 있기 때문에 master 브랜치로 Push를 할 수 없고 다른 브랜치로 John과 공유한다.$ git push -u origin featureA...To jessica@githost:simplegit.git * [new branch] featureA -&amp;gt; featureAJessica는 자신이 한 일을 featureA 라는 브랜치로 Push 했다는 것을 John에게 알린다. John의 피드백을 기다리는 동안 Jessica는 Josie와 함께 작업하기 위해 서버의 master 브랜치를 기반으로 새로운 브랜치를 하나 만든다.$ git fetch origin$ git switch -c featureB origin/masterSwitched to a new branch &#39;featureB&#39;몇 가지 작업을 하고 featureB 브랜치에 커밋한다.$ vim lib/simplegit.rb$ git commit -am &#39;made the ls-tree function recursive&#39;[featureB e5b0fdc] made the ls-tree function recursive 1 files changed, 1 insertions(+), 1 deletions(-)$ vim lib/simplegit.rb$ git commit -am &#39;add ls-files&#39;[featureB 8512791] add ls-files 1 files changed, 5 insertions(+), 0 deletions(-)그럼 Jessica의 저장소는 아래와 같다.Jessica의 저장소작업을 마치고 Push 하려고 했는데 Jesie가 이미 featureB 작업을 하고 서버에 featureBee 브랜치로 Push 했다는 이메일을 받았다. Jessica는 Jesie의 작업을 먼저 Merge 해야만 Push 할 수 있다.Merge 하기 위해서 우선 Fetch 한다.$ git fetch origin...From jessica@githost:simplegit * [new branch] featureBee -&amp;gt; origin/featureBeeJessica가 featureB 브랜치에서 작업중일 때, Fetch 해 온 브랜치를 featureB 브랜치에 Merge 한다.$ git merge origin/featureBeeAuto-merging lib/simplegit.rbMerge made by the &#39;recursive&#39; strategy. lib/simplegit.rb | 4 ++++ 1 files changed, 4 insertions(+), 0 deletions(-)이 시점에서 Jessica는 Merge 한 featureB 작업을 서버로 Push 할 때 서버의 featureB 브랜치로 Push 하지 않고 이미 Josie가 생성한 featureBee 로 작업 내용을 Push 하고자 한다.$ git push -u origin featureB:featureBee...To jessica@githost:simplegit.git fba9af8..cd685d1 featureB -&amp;gt; featureBee이것은 refspec 이란 것을 사용하는 것인데 Refspec 에서 자세하게 설명한다. 명령에서 사용한 u 옵션은 --set-upstream 옵션의 짧은 표현인데 브랜치를 추적하도록 설정해서 이후 Push 나 Pull 할 때 좀 더 편하게 사용할 수 있다.John이 몇 가지 작업을 하고 나서 featureA 에 Push 했고 확인해 달라는 내용의 이메일을 보내왔다. Jessica는 John의 작업 내용을 확인하기 위해 다시 한 번 Fetch 한다.$ git fetch origin...From jessica@githost:simplegit 3300904..aad881d featureA -&amp;gt; origin/featureAJessica의 로컬 featureA 브랜치와 Fetch 해 온 John의 작업내용이 같은 featureA 브랜치 상에서 어떤 것이 업데이트됐는지 git log 명령으로 확인한다.$ git log featureA..origin/featureAcommit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6Author: John Smith &amp;lt;jsmith@example.com&amp;gt;Date: Fri May 29 19:57:33 2009 -0700 changed log output to 30 from 25확인을 마치면 로컬의 featureA 브랜치로 John의 작업 내용을 다음과 같이 Merge 한다.$ git switch featureASwitched to branch &#39;featureA&#39;$ git merge origin/featureAUpdating 3300904..aad881dFast forward lib/simplegit.rb | 10 +++++++++-1 files changed, 9 insertions(+), 1 deletions(-)Jessica는 일부 수정하고, featureA 브랜치에 커밋하고, 수정한 내용을 다시 서버로 Push 한다.$ git commit -am &#39;small tweak&#39;[featureA 774b3ed] small tweak 1 files changed, 1 insertions(+), 1 deletions(-)$ git push...To jessica@githost:simplegit.git 3300904..774b3ed featureA -&amp;gt; featureA위와 같은 작업을 마치고 나면 Jessica의 저장소는 아래와 같은 모습이 된다.마지막 Push 하고 난 후의 Jessica의 저장소그럼 featureA 와 featureBee 브랜치가 프로젝트의 메인 브랜치로 Merge 할 준비가 되었다고 Integration-Manager에게 알린다. Integration-Manager가 두 브랜치를 모두 Merge 하고 난 후에 메인 브랜치를 Fetch 하면 아래와 같은 모양이 된다.두 브랜치가 메인 브랜치에 Merge 된 후의 저장소수많은 팀의 작업을 동시에 진행하고 나중에 Merge 하는 기능을 사용하려고 다른 버전 관리 시스템에서 Git으로 바꾸는 조직들이 많아지고 있다. 팀은 자신의 브랜치로 작업하지만, 메인 브랜치에 영향을 끼치지 않는다는 점이 Git의 장점이다. 아래는 이런 워크플로를 나타내고 있다.Managed 팀의 워크플로공개 프로젝트 Fork비공개 팀을 운영하는 것과 공개 팀을 운영하는 것은 약간 다르다.공개 팀을 운영할 때는 모든 개발자가 프로젝트의 공유 저장소에 직접적으로 쓰기 권한을 가지지 않는다. 그래서 프로젝트의 관리자는 몇 가지 일을 더 해줘야 한다. Fork를 지원하는 Git 호스팅에서 Fork를 통해 프로젝트에 기여하는 법을 예제를 통해 살펴본다. Git 호스팅 사이트(Github, BitBucket, repo.or.cz, Gitlab 등) 대부분 Fork 기능을 지원하며 프로젝트 관리자는 보통 Fork 하는 것으로 프로젝트를 운영한다. 다른 방식으로 이메일과 Patch를 사용하는 방식도 있는데 뒤이어 살펴본다. rebase -i 명령을 사용하면 여러 커밋을 하나의 커밋으로 합치거나 프로젝트의 관리자가 수정사항을 쉽게 이해하도록 커밋을 정리할 수 있다. 히스토리 단장하기 에서 대화식으로 Rebase 하는 방법을 살펴본다.프로젝트의 웹사이트로 가서 Fork 버튼을 누르면 원래 프로젝트 저장소에서 갈라져 나온, 쓰기 권한이 있는 저장소가 하나 만들어진다. 그러면 로컬에서 수정한 커밋을 Fork 한 저장소에 Push 할 수 있게 된다. 그 저장소를 로컬 저장소의 리모트 저장소로 등록하자. 이름은 myfork로 하자.$ git remote add myfork &amp;lt;remote-url&amp;gt;이제 등록한 리모트 저장소에 Push 한다. 작업하던 내용을 로컬 저장소의 master 브랜치에 Merge 한 후 Push 하는 것 보다 리모트 브랜치에 바로 Push 하는 방식이 훨씬 간단하다. 이렇게 하는 이유는 관리자가 토픽 브랜치를 프로젝트에 포함시키고 싶지 않을 때 토픽 브랜치를 Merge 하기 이전 상태로 master 브랜치를 되롤릴 필요가 없기 때문이다. 관리자가 토픽 브랜치를 Merge 하든 Rebase 하든 Cherry-Pick 하든지 간에 결국 다시 관리자의 저장소를 Pull 할 때는 토픽 브랜치의 내용이 들어 있을 것이다 (cherry-pick 명령은 Rebase와 Cherry-Pick 워크플로 에서 자세히 다룬다).다음과 같이 작업 내용을 Push 할 수 있다.# 로컬 master에 Merge 하지 않고 바로 리모트 브랜치에 Push$ git push -u myfork featureAFork 한 저장소에 Push 하고 나면 프로젝트 관리자에게 이 내용을 알려야 한다. 이것을 Pull Request 라고 한다. Git 호스팅 사이트에서 관리자에게 보낼 메시지를 생성하거나 git request-pull 명령으로 이메일을 수동으로 만들 수 있다. GitHub의 Pull Request 기능을 통해 메시지를 만들 수도 있다.git request-pull &amp;lt;base-branch&amp;gt; &amp;lt;remote-url&amp;gt; 명령은 아규먼트를 두 개 입력받는다. &amp;lt;base-branch&amp;gt; : 작업한 토픽 브랜치의 Base 브랜치 &amp;lt;remote-url&amp;gt; : 토픽 브랜치가 위치한 저장소 URL이 명령은 토픽 브랜치 수정사항을 요약한 내용을 결과로 보여준다. 예를 들어 Jessica가 John에게 Pull 요청을 보내는 상황을 살펴보자. Jessica는 토픽 브랜치에 두 번 커밋을 하고 Fork 한 저장소에 Push 했다. 그리고 아래와 같이 실행한다.$ git request-pull origin/master myforkThe following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:Jessica Smith (1): added a new functionare available in the git repository at: git://githost/simplegit.git featureAJessica Smith (2): add limit to log function change log output to 30 from 25 lib/simplegit.rb | 10 +++++++++- 1 files changed, 9 insertions(+), 1 deletions(-)관리자에게 이 내용을 보낸다. 이 내용에는 토픽 브랜치가 어느 시점에 갈라져 나온 것인지(commit 1edee6b), 수정 사항이 어떤지, Pull 하려면 어떤 저장소의 어떤 브랜치에 접근해야 하는지에 대한 내용(git://githost/simplegit.git, featureA)이 있다.프로젝트 관리자가 아니라고 해도 보통 origin/master 를 추적하는 master 브랜치는 가지고 있다. 그래도 토픽 브랜치를 만들고 일을 하면 관리자가 수정 내용을 거부할 때 쉽게 버릴 수 있다. 토픽 브랜치를 만들어서 주제별로 독립적으로 일을 하는 동안에도 주 저장소의 master 브랜치는 계속 수정된다. 하지만 주 저장소 브랜치의 최근 커밋 이후로 Rebase 하면 깨끗하게 Merge 할 수 있다.그리고 다른 주제의 일을 하려고 할 때는 앞서 Push 한 토픽 브랜치에서 시작하지 말고 주 저장소의 master 브랜치로부터 만들어야 한다. 다음과 같다.$ git switch -c featureB origin/master ... 작업 ...$ git commit$ git push myfork featureB$ git request-pull origin/master myfork ... Pull Request를 관리자에게 전달 ... ... 관리자가 Pull Request 승인 후 Merge ...$ git fetch origin각 토픽 브랜치는 일종의 실험실이라고 할 수 있다. 각 토픽은 서로 방해하지 않고 독립적으로 수정하고 Rebase 할 수 있다.featureB 수정 작업이 끝난 직후 저장소의 모습프로젝트 관리자가 사람들의 수정 사항을 Merge 하고 나서 Jessica의 브랜치를 Merge 하려고 할 때 충돌이 날 수도 있다. 그러면 Jessica가 자신의 브랜치를 origin/master에 Rebase 해서 충돌을 해결하고 다시 Pull Request를 보낸다.$ git switch featureA$ git rebase origin/master$ git push -f myfork featureA위 명령들을 실행하고 나면 히스토리는 다음과 같다.FeatureA에 대한 Rebase가 적용된 후의 모습브랜치를 Rebase 해 버렸기 때문에 Push 할 때 -f 옵션을 주고 강제로 기존 서버에 있던 featureA 브랜치의 내용을 덮어 써야 한다. 아니면 새로운 브랜치를(예를 들어 featureAv2) 서버에 Push 해도 된다.또 다른 시나리오를 하나 더 살펴보자. 프로젝트 관리자는 featureB 브랜치의 내용은 좋지만, 상세 구현은 다르게 하고 싶다. 관리자는 featureB 담당자에게 상세 구현을 다르게 해달라고 요청한다. featureB 담당자는 하는 김에 featureB 브랜치를 프로젝트의 최신 master 브랜치 기반으로 옮긴다. 먼저 origin/master 브랜치에서 featureBv2 브랜치를 새로 하나 만들고, featureB 의 커밋들을 모두 Squash 해서 Merge 하고, 만약 충돌이 발생하면 상세 구현을 수정하고 새 브랜치를 Push 한다.$ git switch -c featureBv2 origin/master$ git merge --squash featureB ... 상세 구현 수정 작업 ...$ git commit$ git push myfork featureBv2--squash 옵션은 현재 브랜치에 Merge 할 때 해당 브랜치의 커밋을 모두 커밋 하나로 합쳐서 Merge 한다. 이 때 Merge 커밋은 만들지 않는다. 다른 브랜치에서 수정한 사항을 전부 가져오는 것은 똑같다. 하지만 새로 만들어지는 커밋은 부모가 하나이고 커밋을 기록하기 전에 좀 더 수정할 기회도 있다. 수정한 사항을 전부 가져오면서 그 전에 추가적으로 수정할 내용이 있으면 수정하고 Merge 할 수 있다. 게다가 새로 만들어지는 커밋은 부모가 하나다. --no-commit 옵션을 추가하면 커밋을 합쳐 놓고 자동으로 커밋하지 않는다.수정을 마치면 관리자에게 featureBv2 브랜치를 확인해 보라고 메시지를 보낸다.featureBv2 브랜치를 커밋한 이후 저장소 모습대규모 공개 프로젝트와 이메일을 통한 관리대규모 프로젝트는 보통 수정사항이나 Patch를 수용하는 자신만의 규칙을 마련해놓고 있다. 프로젝트마다 규칙은 서로 다를 수 있으므로 각 프로젝트의 규칙을 미리 알아둘 필요가 있다. 오래된 대규모 프로젝트는 대부분 메일링리스트를 통해서 Patch를 받아들이는데 예제를 통해 살펴본다.토픽 브랜치를 만들어 수정하는 작업은 앞서 살펴본 바와 거의 비슷하지만, Patch를 제출하는 방식이 다르다. 프로젝트를 Fork 하여 Push 하는 것이 아니라 커밋 내용을 메일로 만들어 개발자 메일링리스트에 제출한다.$ git checkout -b topicA ... 작업 ...$ git commit ... 작업 ...$ git commit커밋을 두 번 하고 메일링리스트에 보내 보자. git format-patch 명령으로 메일링리스트에 보낼 mbox 형식의 파일을 생성한다. 각 커밋은 하나씩 이메일 메시지로 생성되는데 커밋 메시지의 첫 번째 라인이 제목이 되고 Merge 메시지 내용과 Patch 자체가 메일 메시지의 본문이 된다. 이 방식은 수신한 이메일에 들어 있는 Patch를 바로 적용할 수 있어서 좋다. 메일 속에는 커밋의 모든 내용이 포함된다.$ git format-patch -M origin/master0001-add-limit-to-log-function.patch0002-changed-log-output-to-30-from-25.patchformat-patch 명령을 실행하면 생성한 파일 이름을 보여준다. -M 옵션은 이름이 변경된 파일이 있는지 살펴보라는 옵션이다. 각 파일의 내용은 아래와 같다.$ cat 0001-add-limit-to-log-function.patchFrom 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001From: Jessica Smith &amp;lt;jessica@example.com&amp;gt;Date: Sun, 6 Apr 2008 10:17:23 -0700Subject: [PATCH 1/2] add limit to log functionLimit log functionality to the first 20--- lib/simplegit.rb | 2 +- 1 files changed, 1 insertions(+), 1 deletions(-)diff --git a/lib/simplegit.rb b/lib/simplegit.rbindex 76f47bc..f9815f1 100644--- a/lib/simplegit.rb+++ b/lib/simplegit.rb@@ -14,7 +14,7 @@ class SimpleGit end def log(treeish = &#39;master&#39;)- command(&quot;git log #{treeish}&quot;)+ command(&quot;git log -n 20 #{treeish}&quot;) end def ls_tree(treeish = &#39;master&#39;)--2.1.0메일링리스트에 이메일을 보내기 전에 각 Patch 파일을 손으로 고칠 수 있다. --- 라인과 Patch가 시작되는 라인(diff --git 로 시작하는 라인) 사이에 내용을 추가하면 다른 개발자는 읽을 수 있지만, 나중에 Patch에 적용되지는 않는다.특정 메일 프로그램을 사용하거나 이메일을 보내는 명령어로 메일링리스트에 보낼 수 있다. 붙여 넣기로 위의 내용이 그대로 들어가지 않는 메일 프로그램도 있다. 사용자 편의를 위해 공백이나 라인 바꿈 문자 등을 넣어 주는 메일 프로그램은 원본 그대로 들어가지 않는다. 다행히 Git에는 Patch 메일을 그대로 보낼 수 있는 도구가 있다. IMAP 프로토콜로 보낸다. 저자가 사용하는 방법으로 Gmail을 사용하여 Patch 메일을 전송하는 방법을 살펴보자. 추가로 Git 프로젝트의 Documentation/SubmittingPatches 문서의 마지막 부분을 살펴보면 다양한 메일 프로그램으로 메일을 보내는 방법을 설명한다.메일을 보내려면 먼저 ~/.gitconfig 파일에서 이메일 부분 설정한다. git config 명령으로 추가할 수도 있고 직접 파일을 열어서 추가할 수도 있다. 아무튼, 아래와 같이 설정을 한다.[imap] folder = &quot;[Gmail]/Drafts&quot; host = imaps://imap.gmail.com user = user@gmail.com pass = YX]8g76G_2^sFbd port = 993 sslverify = falseIMAP 서버가 SSL을 사용하지 않으면 마지막 두 라인은 필요 없고 host에서 imaps:// 대신 imap:// 로 한다. 이렇게 설정하면 git imap-send 명령으로 Patch 파일을 IMAP 서버의 Draft 폴더에 이메일로 보낼 수 있다.$ cat *.patch |git imap-sendResolving imap.gmail.com... okConnecting to [74.125.142.109]:993... okLogging in...sending 2 messages100% (2/2) done이후 Gmail의 Draft 폴더로 가서 To 부분을 메일링리스트의 주소로 변경하고 CC 부분에 해당 메일을 참고해야 하는 관리자나 개발자의 메일 주소를 적고 실제로 전송한다.SMTP 서버를 이용해서 Patch를 보낼 수도 있다. 먼저 SMTP 서버를 설정해야 한다. git config 명령으로 하나씩 설정할 수도 있지만 아래와 같이 ~/.gitconfig 파일의 sendemail 섹션을 손으로 직접 고쳐도 된다.[sendemail] smtpencryption = tls smtpserver = smtp.gmail.com smtpuser = user@gmail.com smtpserverport = 587이렇게 설정하면 git send-email 명령으로 패치를 보낼 수 있다.$ git send-email *.patch0001-added-limit-to-log-function.patch0002-changed-log-output-to-30-from-25.patchWho should the emails appear to be from? [Jessica Smith &amp;lt;jessica@example.com&amp;gt;]Emails will be sent from: Jessica Smith &amp;lt;jessica@example.com&amp;gt;Who should the emails be sent to? jessica@example.comMessage-ID to be used as In-Reply-To for the first email? y명령을 실행하면 아래와 같이 서버로 Patch를 보내는 내용이 화면에 나타난다.(mbox) Adding cc: Jessica Smith &amp;lt;jessica@example.com&amp;gt; from \\line &#39;From: Jessica Smith &amp;lt;jessica@example.com&amp;gt;&#39;OK. Log says:Sendmail: /usr/sbin/sendmail -i jessica@example.comFrom: Jessica Smith &amp;lt;jessica@example.com&amp;gt;To: jessica@example.comSubject: [PATCH 1/2] added limit to log functionDate: Sat, 30 May 2009 13:29:15 -0700Message-Id: &amp;lt;1243715356-61726-1-git-send-email-jessica@example.com&amp;gt;X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirtyIn-Reply-To: &amp;lt;y&amp;gt;References: &amp;lt;y&amp;gt;Result: OK" }, { "title": "[Git] Centralized, Integration-Manager and Benevolent dictator workflow", "url": "/posts/Distributed-Workflows/", "categories": "Git, Workflow", "tags": "Workflow, Git, VCS, DVCS, Github", "date": "2022-01-12 20:43:00 +0900", "snippet": "이번 글에서는 프로젝트 기여자 또는 수정사항을 취합하는 관리자의 관점에서 작업물을 프로젝트에 어떻게 포함시킬지와 수많은 개발자가 수행한 일을 취합하고 프로젝트를 운영하는 방법을 배운다.분산 환경에서의 워크플로중앙집중형 버전 관리 시스템과는 달리 Git은 분산형이다. Git은 구조가 매우 유연하기 때문에 여러 개발자가 협업하는 과정을 더 다양하게 구성할 수 있다. 중앙집중형 버전 관리 시스템에서 각 개발자는 중앙 저장소를 중심으로 뻗어 나온 하나의 노드일 뿐이다. 하지만 Git에서는 각 개발자의 저장소가 하나의 노드이기도 하고 중앙 저장소 같은 역할도 할 수 있다. 즉, 모든 개발자는 다른 개발자의 저장소에 작업한 내용을 전송하거나, 다른 개발자들이 본인의 프로젝트에 참여할 수 있도록 본인이 운영하는 저장소의 위치 공개 및 권한을 부여할 수도 있다. 이러한 특징은 팀이 프로젝트를 운영할 때 다양한 워크플로를 적용시킬 수 있도록 해준다. 이런 유연성을 살려 저장소를 운영하는 몇 가지 방식을 소개한다. 각 방식의 장단점을 살펴보고 그 방식 중 하나를 고르거나 여러 가지를 적절히 섞어 사용하면 된다.Centralized Workflow중앙집중형 시스템에서는 보통 중앙집중형 협업 모델이라는 한 가지 방식의 워크플로밖에 없다. 중앙 저장소는 딱 하나 있고 변경 사항은 모두 이 중앙 저장소에 저장된다. 개발자는 이 중앙 저장소를 중심으로 작업하게 된다.Centralized Workflow중앙집중형 워크플로에서 개발자 세 명이 저장소를 Clone 하고 각자 작업을 진행하는 상황을 생각해보자. 한 개발자가 자신이 한 일을 커밋하고 나서 아무 문제 없이 서버에 Push 한다. 그러면 다른 개발자는 자신의 일을 커밋하고 Push 하기 전에 첫 번째 개발자가 한 일을 먼저 Merge 해야 한다. Merge를 해야 첫 번째 개발자가 작업한 내용을 덮어쓰지 않는다. 이런 개념은 Subversion과 같은 중앙집중형 버전 관리 시스템에서 사용하는 방식이고 Git에서도 당연히 이런 워크플로를 사용할 수 있다.팀의 규모가 작거나 이미 중앙집중형에 적응한 상황이라면 이 워크플로에 따라 Git을 도입하여 사용할 수 있다. 중앙 저장소를 하나 만들고 개발자 모두에게 Push 권한을 부여한다. 모두에게 Push 권한을 부여해도 Git은 한 개발자가 다른 개발자의 작업 내용을 덮어쓰도록 허용하지 않는다. 철수랑 영희가 동시에 같은 부분을 수정하는 상황을 생각해보자. 철수가 먼저 작업을 끝내고 수정한 내용을 서버로 Push 했다. 영희도 마찬가지로 작업을 마치고 수정한 내용을 서버로 Push 하려 하지만 서버가 받아주지 않는다. 서버에는 이미 철수가 수정한 내용이 추가되었기 때문에 Push 하기 전에 Fetch로 받아서 Merge 한 후 Push 할 수 있다. 이런 개념은 중앙집중형 워크플로에 익숙한 개발자들도 거부감 없이 도입할 수 있다.작은 팀만 이렇게 일할 수 있는건 아니다. Git이 제공하는 브랜치 관리 모델을 사용하면 수백명의 개발자가 한 프로젝트 안에서 다양한 브랜치를 만들어서 함께 작업하는 것도 쉽다.Integration-Manager WorkflowGit을 사용하면 리모트 저장소를 여러 개 운영할 수 있다. 다른 개발자는 읽기만 가능하고 자신은 읽기 쓰기 모두 가능한 공개 저장소를 만드는 방식도 가능하다. 이 방식의 워크플로에는 보통 프로젝트를 대표하는 공식 저장소가 있다. 기여자는 우선 공식 저장소를 Clone 하고 수정하고 나서 자신의 저장소에 Push 한다. 그 다음에 프로젝트 Integration-Manager(통합을 수행하는 관리자)에게 기여자의 저장소에서 Pull 하라고 요청한다. 그러면 Integration-Manager는 기여자의 저장소를 리모트 저장소로 등록하고, 로컬에서 기여물을 테스트하고, 프로젝트 메인 브랜치에 Merge 하고, 그 내용을 다시 프로젝트 메인 저장소에 Push 한다. 이런 과정은 다음과 같다.Integration-Manager Workflow 기여자는 메인 저장소를 Clone 하고 수정한다. 기여자는 자신의 저장소에 Push 하고 Integration-Manager가 접근할 수 있도록 공개해 놓는다. 기여자는 Integration-Manager에게 변경사항을 적용해 줄 것을 요청한다. Integration-Manager는 기여자의 저장소를 리모트 저장소로 등록하고 수정사항을 Merge 하여 테스트한다. Integration-Manager는 Merge 한 사항을 메인 저장소에 Push 한다.이 방식의 장점은 기여자와 Integration-Manager가 각자의 상황에 맞춰 프로젝트를 진행할 수 있다는 점이다. 기여자는 자신의 저장소와 브랜치에서 수정 작업을 계속해 나갈 수 있고 수정사항이 반영될 때까지 기다릴 필요가 없다. 그리고 Integration-Manager는 여유를 가지고 필요에 따라 기여자가 Push 해 놓은 커밋을 적절한 시점에 Merge 한다.Dictator and Lieutenants Workflow이 방식은 여러개의 저장소를 운영하는 방식을 변형한 구조를 갖는다. 보통 수백 명의 개발자가 참여하는 아주 큰 프로젝트를 운영할 때 이 방식을 사용한다. Linux 커널 프로젝트가 대표적이다. 여러 명의 Integration-Manager가 저장소에서 자신이 맡은 부분만을 담당하는데 이들을 Lieutenants 라고 부른다. 모든 Lieutenant는 최종 관리자 아래에 있으며 이 최종 관리자를 Benevolent Dictator 라고 부른다. Benevolent Dictator는 Lieutenant의 저장소를 가져와 공식 저장소에 Push 하고 모든 프로젝트 참여자는 이 공식 저장소에서 반드시 Pull 해야 한다. 이러한 워크플로는 다음과 같다.Benevolent dictator Workflow 개발자는 코드를 수정하고 master 브랜치를 기준으로 자신의 토픽 브랜치를 Rebase 한다. 여기서 master 브랜치란 공식 저장소의 브랜치를 말한다. Lieutenant들은 개발자들의 수정사항을 자신이 관리하는 master 브랜치에 Merge 한다. Dictator는 Lieutenant의 master 브랜치를 자신의 master 브랜치로 Merge 한다. Dictator는 자신의 master 브랜치를 Push 하며 다른 모든 개발자는 Dictator의 master 브랜치를 기준으로 Rebase 한다.이 방식이 일반적이지는 않지만 깊은 계층 구조를 가지는 환경이나 규모가 큰 프로젝트에서는 매우 쓸모 있다. 프로젝트 리더가 모든 코드를 통합하기 전에 코드를 부분부분 통합하도록 여러 명의 Lieutenant에게 위임한다.워크플로 요약이 세 가지 워크플로가 Git 같은 분산 버전 관리 시스템에서 주로 사용하는 것들이다. 사실 이런 워크플로뿐만 아니라 다양한 변종 워크플로가 실제로 사용된다. 어떤 방식을 선택하고 혹은 조합해야 하는 지 살짝 감이 잡힐 것이다. 앞으로 몇 가지 구체적 사례를 들고 우리가 다양한 환경에서 각 역할을 어떻게 수행하는지 살펴본다. 이어지는 내용에서 프로젝트에 참여하고 기여할 때 작업 패턴이 어떠한지 몇 가지 살펴보기로 한다." }, { "title": "[Git] Rebase 기초", "url": "/posts/Rebasing/", "categories": "Git, Branch", "tags": "git rebase, git merge, Git, VCS, DVCS, Github", "date": "2022-01-12 20:04:00 +0900", "snippet": "한 브랜치에서 다른 브랜치를 합치는 방법으로는 두 가지가 있다. 하나는 Merge 이고 다른 하나는 Rebase 이다. 이 절에서는 Rebase가 무엇인지, 어떻게 사용하는지, 좋은 점은 무엇인지, 어떤 상황에서 사용하고 어떤 상황에서는 사용하지 말아야 하는지 알아 본다.앞에서 설명한 “Merge 기초” 절에서 살펴본 예제로 다시 돌아가 보자. 두 개의 나누어진 브랜치의 모습을 볼 수 있다.두 개의 브랜치로 나누어진 커밋 히스토리이 두 브랜치를 합치는 가장 쉬운 방법은 앞에서 살펴본 대로 git merge 명령을 사용하는 것이다. 두 브랜치의 마지막 커밋 두 개(C3, C4)와 공통 조상(C2)을 참조하여 3-way Merge로 새로운 커밋을 만들어 낸다.나뉜 브랜치를 Merge 하기위와 비슷한 결과를 만드는 다른 방식을 알아보자. C3에서 변경된 사항을 Patch로 만들고 이를 다시 C4에 적용시키는 방법이 있다. Git에서는 이런 방식을 Rebase 라고 한다. git rebase 명령으로 한 브랜치에서 변경된 사항을 다른 브랜치에 적용할 수 있다.위의 예제는 아래와 같은 명령으로 Rebase 한다.$ git switch experiment$ git rebase masterFirst, rewinding head to replay your work on top of it...Applying: added staged command위 내용을 설명하자면 일단 두 브랜치가 나뉘기 전의 공통 커밋(C2)으로 이동하고 그 커밋부터 지금 Checkout 한 브랜치가 가리키는 커밋(C4)까지 diff를 차례로 만들어 어딘가에 임시로 저장해 놓는다. Rebase 할 브랜치(experiment)가 합쳐질 브랜치(master)가 가리키는 커밋을 가리키게 하고 아까 저장해 놓았던 변경사항을 차례로 적용한다.C4의 변경사항을 C3에 적용하는 Rebase 과정그리고 master 브랜치를 C4’ 커밋에 Fast-forward 시킨다.$ git switch master$ git merge experimentmaster 브랜치를 C4’ 커밋에 Fast-forward 시키기C4’로 표시된 커밋 내용은 Merge 예제에서 살펴본 C5 커밋 내용과 동일할 것이다. Merge 이든 Rebase 든 합치는 관점에서는 서로 다를 게 없다. Rebase가 좀 더 깔끔한 커밋 히스토리를 만든다는 차이만 있을 뿐이다. Rebase 한 브랜치의 Log를 살펴보면 히스토리가 선형적이다. 일을 병렬로 동시에 진행해도 Rebase 하고 나면 모든 작업이 차례로 수행된 것처럼 보이게 된다.Rebase는 보통 리모트 브랜치에 커밋을 깔끔하게 적용하고 싶을 때 사용한다. 아마 이렇게 Rebase 하는 리모트 브랜치는 직접 관리하는 것이 아니라 그냥 참여하는 브랜치일 것이다. 메인 프로젝트에 Patch를 보낼 준비가 되면 하는 것이 Rebase 니까 브랜치에서 하던 일을 완전히 마치고 origin/master로 Rebase 한다. 이렇게 Rebase 하고 나면 프로젝트 관리자는 어떠한 통합작업도 할 필요가 없게 된다. 그저 master 브랜치를 Fast-forward 시키면 된다.Rebase를 하든지, Merge를 하든지 최종 결과물은 같고 커밋 히스토리만 다르다는 점이 중요하다.Rebase의 경우 브랜치의 변경사항을 순서대로 다른 브랜치에 적용하면서 합치고, Merge의 경우 두 브랜치의 최종 결과만을 가지고 합친다.Rebase 활용Rebase는 단순히 브랜치를 합치는 것만 아니라 다른 용도로도 사용할 수 있다.특정 토픽 브랜치에서 갈라져 나온 토픽 브랜치가 있는 히스토리를 생각해보자. server 브랜치를 만들어서 서버 기능을 추가하고 그 브랜치에서 다시 client 브랜치를 만들어 클라이언트 기능을 추가한다. 마지막으로 server 브랜치로 돌아가서 몇 가지 기능을 더 추가한다.특정 토픽 브랜치(server의 C3 커밋)에서 갈라져 나온 토픽 브랜치(client의 C8)이때 테스트가 덜 진행된 server 브랜치는 그대로 두고 client 브랜치만 master 브랜치로 합치려는 상황을 생각해 보자. server와는 아무 관련이 없는 client 커밋은 C8, C9 이다. 이 두 커밋을 master 브랜치에 적용하기 위해 --onto 옵션을 사용하여 아래와 같은 명령을 실행한다.$ git rebase --onto master server client이 명령은 master 브랜치부터 server 브랜치와 client 브랜치의 공통 조상(C2)까지의 커밋을 client 브랜치에서 없애고 싶을 때 사용한다. client 브랜치에서만 변경된 패치를 만들어 master 브랜치에서 client 브랜치를 기반으로 새로 만들어 적용한다. 조금 복잡하긴 해도 꽤 쓸모 있다.특정 토픽 브랜치(C3)에서 갈라져 나온 토픽 브랜치(C8, C9)를 Rebase 하기이제 master 브랜치로 돌아가서 client 브랜치 위치로 Fast-forward 시킨다.$ git switch master$ git merge clientmaster 브랜치를 client 브랜치 위치로 이동server 브랜치에서 작업이 다 끝나면 git rebase &amp;lt;basebranch-name&amp;gt; &amp;lt;topicbranch-name&amp;gt; 라는 명령으로 바로 server 브랜치를 master 브랜치로 Rebase 할 수 있다. 이 명령은 토픽 브랜치(server)를 Checkout 하고 베이스 브랜치(master)에 Rebase 한다.$ git rebase master servermaster 브랜치에 server 브랜치의 수정 사항 적용server 브랜치의 수정사항을 master 브랜치에 적용했다.이제 master 브랜치를 server 브랜치 위치로 Fast-forward 시킨다.$ git switch master$ git merge server모든 것이 master 브랜치에 통합됐기 때문에 더 이상 필요하지 않은 client, server 브랜치는 삭제해도 된다.$ git branch -d client$ git branch -d server최종 커밋 히스토리브랜치를 삭제해도 커밋 히스토리에 위와 같이 같이 여전히 남아 있는 것을 확인할 수 있다.Rebase의 위험성Rebase는 장점이 많은 기능이지만 단점이 없는 것은 아니니 조심해야 한다. 그 주의사항은 아래 한 문장으로 표현할 수 있다.이미 공개 저장소에 Push 한 커밋을 Rebase하지 말라이 지침만 지키면 Rebase를 하는 데 문제 될 것은 없을 것이다. 다만, 본인 부주의로 인해 이 주의사항을 지키지 않았을 경우 함께 협업하는 사람들로부터 수많은 삿대질과 욕을 배불리 먹어 장수하게 되는 기적이 올 것이다.Rebase는 기존 커밋을 그대로 사용하는 것이 아니라 내용은 같지만 새로운 커밋을 만든다. 새 커밋을 서버에 Push 하고 동료 중 누군가가 그 커밋을 Pull 해서 작업을 한다고 하자. 그런데 그 커밋을 git rebase 로 바꿔서 Push 해버리면 동료가 다시 Push 했을 때 동료는 다시 Merge 해야 한다. 그리고 동료가 Merge 한 내용을 Pull 하면 내 코드는 엉망진창이 된다.이미 저장소에 Push 한 커밋을 Rebase 하면 어떤 결과가 초래되는지 예제를 통해 알아보자. 중앙 저장소에서 Clone 하고 일부 수정을 하면 커밋 히스토리는 아래와 같이 된다.리모트 저장소를 Clone 하고 일부 수정함이제 팀원 중 누군가 커밋, Merge 하고 나서 서버에 Push 한다. 이 리모트 브랜치를 Fetch, Merge 하면 히스토리는 아래와 같이 된다.리모트 저장소를 Fetch 한 후 Merge 함그런데 Push 했던 팀원은 Merge 한 일을 되돌리고 다시 Rebase 한다. 서버의 히스토리를 새로 덮어씌우려면 git push 명령에 --force 혹은 -f 옵션을 사용해야 한다. 이후 저장소에서 Fetch 하고 나면 아래 그림과 같은 상태가 된다.한 팀원이 다른 팀원이 의존하는 커밋을 없애고 Rebase 한 커밋을 다시 Push 함이렇게 되면 히스토리가 짬뽕이 된다. git pull로 서버의 내용을 가져와서 Merge 하면 같은 내용의 수정사항을 포함한 Merge 커밋이 아래와 같이 만들어진다.같은 Merge를 다시 Merge하여 중복 커밋 발생git log로 히스토리를 확인해보면 저자, 커밋 날짜, 메시지가 완전히 동일한 커밋 두 개(C4, C4’)가 있다. 이렇게 되면 혼란스럽다. C4와 C6는 포함되지 말았어야 할 커밋이다. 애초에 서버로 데이터를 보내기 전에 Rebase로 커밋을 선형으로 정리했어야 했다.Rebase 한 것을 다시 Rebase 하기만약 이러한 상황에 처했을 때 유용한 Git 기능이 하나 있다. 어떤 팀원이 강제로 내가 한 일을 덮어썼다고 하자. 그러면 내가 했던 일이 무엇이고 덮어쓴 내용이 무엇인지 알아내야 한다.커밋 SHA-1 체크섬 외에도 Git은 커밋에 Patch 할 내용으로 SHA-1 체크섬을 한 번 더 구한다. 이 값은 “patch-id” 라고 한다.덮어쓴 커밋을 받아서 그 커밋을 기준으로 Rebase 할 때 Git은 원래 누가 작성한 코드인지 잘 찾아 낸다. 그래서 Patch가 원래대로 잘 적용된다.예를 들어 앞서 살펴본 예제 중 한 팀원이 다른 팀원이 의존하는 커밋을 없애고 Rebase 한 커밋을 다시 Push 한 상황에서 Merge 하는 대신 git rebase teamone/master 명령을 실행하면 Git은 아래와 같은 작업을 한다. 현재 브랜치에만 포함된 커밋을 결정한다. (C2, C3, C4, C6, C7) Merge 커밋이 아닌 것을 결정한다. (C2, C3, C4) 이 중 Merge 할 브랜치에 덮어쓰이지 않은 커밋을 결정한다. (C2, C3) 결정한 커밋을 teamone/master 브랜치에 적용한다.강제로 덮어쓴 브랜치에 Rebase 하기다시 Merge 한 결과는 엉망이였지만, Rebase 한 결과는 선형으로 깔끔하게 정리된 히스토리를 볼 수 있게 된다.동료가 생성했던 C4와 C4’ 커밋 내용이 완전히 같을 때만 이렇게 동작된다. 커밋 내용이 아예 다르거나 비슷하다면 커밋이 두 개 생긴다(같은 내용이 두 번 커밋될 수 있기 때문에 깔끔하지 않다).git pull 명령을 실행할 때 옵션을 붙여서 git pull --rebase 로 Rebase 할 수도 있다. 물론 git fetch 와 git rebase teamone/master 이 두 명령을 직접 순서대로 실행해도 결과는 같다.git pull 명령을 실행할 때 기본적으로 --rebase 옵션이 적용되도록 pull.rebase 설정을 추가할 수 있다. git config --global pull.rebase true 명령으로 추가한다.Push 하기 전에 정리하려고 Rebase 하는 것은 괜찮다. 또 절대 공개하지 않고 혼자 Rebase 하는 경우도 괜찮다. 하지만, 이미 공개하여 사람들이 사용하는 커밋을 Rebase 하면 틀림없이 문제가 생긴다.나중에 후회하지 말고 git pull --rebase 로 문제를 미리 방지할 수 있다는 것을 같이 작업하는 동료와 모두 함께 공유하기 바란다.Rebase vs. MergeMerge와 Rebase가 어떠한 기능을 하는지 여러 예제를 통해 간단히 살펴보았다. 지금쯤 이런 의문이 들 것으로 생각한다.“둘 중 무엇을 쓰는 게 좋지?” 이 질문에 대한 답을 찾기 전에 히스토리의 의미에 대해서 잠깐 다시 생각해보자.히스토리를 보는 관점 중에 하나는 작업한 내용의 기록으로 보는 것이 있다. 작업한 내용을 기록한 문서이고, 각 기록은 각각의 의미를 가지며, 변경할 수 없다. 이런 관점에서 커밋 히스토리를 변경한다는 것은 역사를 부정하는 꼴이 된다. 언제 무슨 일이 있었는지 기록에 대해 거짓말을 하게 되는 것이다. 이렇게 했을 때 지저분하게 수많은 Merge 커밋이 히스토리에 남게 되면 문제가 없을까? 역사는 후세를 위해 기록하고 보존해야 한다.또 다른 관점으로는 히스토리를 프로젝트가 어떻게 진행되었나에 대한 이야기로도 볼 수 있다. 소프트웨어를 주의 깊게 편집하는 방법이나 세세한 작업 내용을 초벌부터 공개하고 싶지 않을 수 있다. 나중에 다른 사람에게 들려주기 좋게 Rebase 나 filter-branch 같은 도구로 프로젝트의 진행 이야기를 다듬으면 좋다.Merge 나 Rebase 중 무엇이 나은가에 관한 질문은 다시 생각해봐도 답이 그리 간단치 않다. Git은 매우 강력한 도구이고 기능이 많아 히스토리를 잘 쌓을 수 있지만, 모든 팀과 모든 이가 처한 상황은 모두 다르다. 예제를 통해 Merge나 Rebase가 무엇이고 어떤 의미인지 배웠다. 이 둘을 어떻게 사용할지는 각자의 상황과 판단에 달렸다.일반적인 해답을 굳이 드리자면 로컬 브랜치에서 작업할 때는 히스토리를 정리하기 위해서 Rebase 할 수도 있지만, 리모트 등 어딘가에 Push로 내보낸 커밋에 대해서는 절대 Rebase 하지 말아야 한다는 것이다." }, { "title": "[Git] 리모트 브랜치", "url": "/posts/Remote-Branches/", "categories": "Git, Branch", "tags": "Git Tracking Branch, git remote, git branch, Git, VCS, DVCS, Github", "date": "2022-01-12 19:46:00 +0900", "snippet": "리모트 브랜치리모트의 Refs는 리모트 저장소에 있는 포인터이자 레퍼런스이며 리모트 저장소에 있는 브랜치, 태그 등등을 의미한다. git ls-remote &amp;lt;remote-name&amp;gt; 명령으로 특정 리모트 혹은 모든 리모트 Refs를 조회할 수 있다. git remote show &amp;lt;remote-name&amp;gt; 명령은 특정 혹은 모든 리모트 브랜치의 정보를 보여준다. 리모트 Refs가 있지만 보통은 리모트 트래킹 브랜치를 사용한다.리모트 트래킹 브랜치는 브랜치를 추적하는 레퍼런스이며 브랜치다. 리모트 트래킹 브랜치는 로컬에 있지만 임의로 움직일 수 없다. 리모트 서버에 연결할 때마다 리모트의 브랜치 업데이트 내용에 따라서 자동으로 갱신될 뿐이다. 리모트 트래킹 브랜치는 일종의 북마크라고 할 수 있다. 리모트 저장소에 마지막으로 연결했던 순간에 브랜치가 무슨 커밋을 가리키고 있는지를 나타낸다.리모트 트래킹 브랜치의 이름은 &amp;lt;remote-name&amp;gt;/&amp;lt;branch-name&amp;gt; 형식으로 되어 있다. 예를 들어 리모트 저장소 origin의 master 브랜치를 보고 싶다면 origin/master 라는 이름으로 브랜치를 확인하면 된다. 다른 팀원과 함께 어떤 이슈를 해결해 나아갈 때 그 팀원이 iss53 브랜치를 서버로 Push했고 당신도 로컬에 iss53 브랜치가 있다고 가정하자. 이때 서버의 iss53 브랜치가 가리키는 커밋은 로컬에서 origin/iss53이 가리키는 커밋이다.다소 헷갈릴 수 있으니 다음 예제를 살펴보자. git.ourcompany.com 이라는 Git 서버가 있고 이 서버의 저장소를 하나 Clone 하면 Git은 자동으로 origin 이라는 이름을 붙인다. origin으로부터 저장소 데이터를 모두 내려받고 master 브랜치를 가리키는 포인터를 만든다. 이 포인터는 origin/master 라고 부르고 멋대로 조종할 수 없다. 그리고 Git은 로컬의 master 브랜치가 리모트의 origin/master 브랜치를 가리키게 한다. 이제 이 master 브랜치에서 작업을 시작할 수 있다. origin의 의미 브랜치 이름으로 많이 사용하는 master 라는 이름이 괜히 특별한 의미를 가지는 게 아닌 것처럼 origin도 특별한 의미가 있는 것은 아니다. git init 명령이 자동으로 만들기 때문에 사용하는 이름인 master 와 마찬가지로 origin 도 git clone 명령이 자동으로 만들어주는 리모트 이름이다. git clone -o mooyaho 라고 옵션을 주고 명령을 실행하면 mooyaho/master 라고 사용자가 지정한 리모트 이름을 생성해준다.Clone 이후 서버와 로컬의 master 브랜치로컬 저장소에서 어떤 작업을 진행하고 있는데 다른 팀원이 git.ourcompany.com 서버에 Push하여 master 브랜치를 업데이트했다. 그러면 그 순간부터 팀원 간의 히스토리는 서로 달라지게 된다. 서버 저장소로부터 어떤 데이터도 주고받지 않아서 origin/master 포인터는 그대로다.로컬과 리모트 서버의 커밋 히스토리는 독립적임리모트 서버로부터 저장소 정보를 동기화하려면 git fetch origin 명령을 사용한다. 명령을 실행하면 origin 서버의 주소 정보(이 예에서는 git.ourcompany.com)를 찾아서 현재 로컬 저장소에는 없는 새로운 정보가 있으면 모두 내려받고, 받은 데이터를 로컬 저장소에 업데이트하고 나서 origin/master 포인터의 위치를 최신 커밋으로 이동시킨다.git fetch 명령은 리모트 브랜치 정보를 업데이트리모트 저장소를 여러 개 운영하는 상황을 이해할 수 잇도록 개발용으로 사용할 Git 저장소를 팀 내부에 하나 추가해 보자. 이 저장소의 주소는 git.team1.ourcompany.com 이며 git remote add 명령으로 현재 작업 중인 프로젝트에 팀의 저장소를 추가한다. 이름을 teamone 으로 짓고 긴 서버 주소 대신 사용한다.서버를 리모트 저장소로 추가서버 추가 후 git fetch teamone 명령으로 teamone 서버의 최신 데이터를 모두 내려받는다. 그러나 명령을 실행해도 teamone 서버의 데이터는 모두 origin 서버에도 있는 것들이라서 아무것도 내려받지 않는다. 하지만 이 명령은 리모트 트래킹 브랜치 teamone/master가 teamone 서버의 master 브랜치가 가리키는 커밋을 가리키게 한다.teamone/master 의 리모트 트래킹 브랜치Push 하기로컬 브랜치를 서버에 보내려면 해당 서버에 쓰기 권한이 있어야 한다. 그리고 로컬 브랜치는 자동으로 리모트 저장소로 보내지는 것이 아닌 개발자가 직접 명시적으로 브랜치를 Push 해야 서버에 반영된다. 따라서 로컬 브랜치를 서버에 보내지 않고 로컬에만 두는 비공개 브랜치를 활용할 수도 있다. 또는 다른 사람과 협업하기 위한 토픽 브랜치만 전송할 수도 있다.serverfix라는 브랜치를 다른 사람과 공유하기 위해 서버에 Push 해보자. 명령은 git push &amp;lt;remote-name&amp;gt; &amp;lt;branch-name&amp;gt; 이다.$ git push origin serverfixCounting objects: 24, done.Delta compression using up to 8 threads.Compressing objects: 100% (15/15), done.Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.Total 24 (delta 2), reused 0 (delta 0)To https://github.com/schacon/simplegit * [new branch] serverfix -&amp;gt; serverfixGit은 serverfix 브랜치 이름을 refs/heads/serverfix:refs/heads/serverfix로 확장한다. 이것은 로컬 브랜치 serverfix를 서버로 Push 하는데 리모트의 serverfix 브랜치로 업데이트 한다는 것을 의미한다. 나중에 refs/heads/의 뜻을 자세히 알아볼 것이기에 일단 넘어가도록 하자.git push origin serverfix:serverfix 와 같은 명령을 통해 Push 하는 것도 같은 의미인데 이것은 “로컬의 serverfix 브랜치를 리모트 저장소의 serverfix 브랜치로 Push 하라” 라는 뜻이다. 이러한 명령은 로컬 브랜치의 이름과 리모트 서버의 브랜치 이름이 다를 때 사용한다.리모트 저장소에 serverfix라는 이름 대신 다른 이름을 사용하려면 git push origin serverfix:mooyaho 처럼 사용하면 된다. 리모트 저장소에 접근할 때마다 암호를 매번 입력할 필요는 없다.HTTPS URL로 시작하는 리모트 저장소를 사용한다면 아마도 Push 나 Pull을 할 때 인증을 위한 사용자 이름이나 암호를 묻는 것을 볼 수 있다. Git이 이 정보를 서버로 전달해서 권한을 확인하기 위함이다. 매번 암호를 입력하는 작업이 번거롭다면 ”credential cache” 기능을 이용할 수 있다.이 기능을 활성화하면 Git은 몇 분 동안 입력한 사용자 이름과 암호를 저장해둔다. 이 기능을 활성화하려면 git config --global credential.helper cache 명령을 실행하여 환경설정을 추가한다. 이 기능이 제공하는 다른 옵션에 관한 자세한 설명은 Credential 저장소를 참고하자.저장소를 Fetch 하고 나서 서버에 있는 serverfix 브랜치에 접근할 때 origin/serverfix 라는 이름으로 접근할 수 있다.$ git fetch originremote: Counting objects: 7, done.remote: Compressing objects: 100% (2/2), done.remote: Total 3 (delta 0), reused 3 (delta 0)Unpacking objects: 100% (3/3), done.From https://github.com/schacon/simplegit * [new branch] serverfix -&amp;gt; origin/serverfix여기서 짚고 넘어가야 할 점이 있다. Fetch 명령을 통해 리모트 트래킹 브랜치를 내려받는다고 해서 로컬 저장소에 수정할 수 있는 브랜치가 자동으로 생성되는 것이 아니다. 다시 말해 serverfix 브랜치가 생기는 것이 아닌 그저 수정 불가능한 origin/serverfix 브랜치 포인터가 생기는 것이다.새로 받은 브랜치의 내용을 Merge 하려면 git merge origin/serverfix 명령을 사용한다. 만약 Merge하지 않고 리모트 트래킹 브랜치에서 시작하는 새 브랜치를 로컬에 생성하려면 아래와 같은 명령을 사용한다.$ git switch -c serverfix origin/serverfixSwitched to a new branch &#39;serverfix&#39;Branch &#39;serverfix&#39; set up to track remote branch &#39;serverfix&#39; from &#39;origin&#39;.origin/serverfix 에서 시작하고 수정할 수 있는 serverfix 라는 로컬 브랜치가 만들어졌다.브랜치 추적리모트 트래킹 브랜치를 로컬 브랜치로 Checkout 하면 자동으로 트래킹 브랜치가 만들어진다. 트래킹 하는 대상 브랜치를 Upstream 브랜치라고 부른다. 트래킹 브랜치는 리모트 브랜치와 연결되어 있는 로컬 브랜치다. 트래킹 브랜치에서 git pull 명령을 내리면 리모트 저장소로부터 데이터를 내려받아 연결된 리모트 브랜치와 자동으로 Merge 한다.서버로부터 저장소를 Clone 하면 Git은 자동으로 로컬 master 브랜치를 리모트 origin/master 브랜치의 트래킹 브랜치로 만든다. 트래킹 브랜치를 직접 만들 수 있는데 리모트를 origin이 아닌 다른 리모트로 할 수도 있고, 브랜치도 master가 아닌 다른 브랜치로 추적할 수 있다.git switch -c &amp;lt;branch-name&amp;gt; &amp;lt;remote-name&amp;gt;/&amp;lt;branch-name&amp;gt; 명령으로 간단히 트래킹 브랜치를 만들고 리모트 브랜치를 트래킹하도록 할 수 있다.리모트 저장소 tr의 fbaddfiles 브랜치를 추적하는 로컬 트래킹 브랜치 fbaddfiles 생성다음과 같이 --track 옵션을 사용하여 로컬 브랜치 이름을 자동으로 생성할 수도 있다.리모트 저장소 tr의 브랜치명을 참조해 feature_division 로컬 트래킹 브랜치 생성이 명령은 매우 자주 쓰이므로 더 생략할 수 있다. 리모트 브랜치에는 존재하나 로컬 브랜치에는 존재하지 않는 경우 Git은 트래킹 브랜치를 자동으로 만들어 준다.※ git branch 명령의 -a 옵션은 현재 리모트 저장소와 로컬 저장소의 모든 브랜치를 보여준다.로컬에는 없으나 리모트에는 존재하는 브랜치에 대한 트래킹 브랜치 자동 생성리모트 브랜치와 다른 이름으로 브랜치를 만들고 싶은 경우 로컬 브랜치의 이름을 다음과 같이 다르게 지정해보자.tr/gh-pages를 추적하는 mooyaho 트래킹 브랜치가 생성됨이미 로컬에 존재하는 브랜치가 리모트의 특정 브랜치를 추적하게 하려면 git branch 명령에 -u 혹은 --set-upstream-to 옵션을 붙이면 된다.로컬 브랜치 mooyaho는 리모트 tr의 bisect 브랜치를 추적하게 됨git branch -vv 명령을 통해 mooyaho 브랜치가 tr/bisect 브랜치를 추적 중임을 알 수 있다.리모트 브랜치 bisect를 추적 중인 로컬 트래킹 브랜치 mooyaho Upstream 별명 트래킹 브랜치를 설정했다면 트래킹 브랜치 이름을 @{upstream} 이나 @{u} 로 짧게 대체하여 사용할 수 있다. master 브랜치가 origin/master 브랜치를 추적하는 경우라면 git merge origin/master 명령과 git merge @{u} 명령을 똑같이 사용할 수 있다.트래킹 브랜치가 현재 어떻게 설정되어 있는지 확인하려면 git branch 명령에 -vv 옵션을 사용한다. 이 명령은 로컬 브랜치 목록과 로컬 브랜치가 추적하고 있는 리모트 브랜치도 함께 보여준다. 게다가 로컬 브랜치가 앞서가는지 뒤쳐지는지에 대한 내용도 보여준다.로컬 브랜치 상세 정보 조회위의 결과를 보면 master 브랜치는 origin/master 리모트 브랜치를 추적하고 있다는 것을 알 수 있고 “ahead” 표시를 통해 로컬 브랜치가 커밋 1개 앞서 있다(리모트 브랜치에는 없는 커밋이 로컬에는 존재)는 것을 알 수 있다.로컬 브랜치 중 mooyaho 브랜치는 bisect 이라는 tr 리모트 서버의 브랜치를 추적하고 있으며 커밋 3개 앞서 있고 동시에 커밋 16개 뒤쳐져 있다. 어떤 의미냐면 mooyaho 브랜치에서 서버로 보내지 않은 커밋이 1개, 서버의 브랜치에서 로컬 브랜치로 Merge 하지 않은 커밋이 16개 있다는 말이다.br_version2, iss53, testing 브랜치는 추적하는 리모트 브랜치가 없는 상태이다.여기서 중요한 점은 명령을 실행한 시점의 결과는 마지막으로 데이터를 서버에서 가져온(Fetch or Pull) 시점을 바탕으로 계산한다는 점이다. 단순히 이 명령만으론 서버의 최신 데이터를 반영하지는 않으며 로컬에 저장된 서버의 캐시 데이터를 사용한다. 현재 시점에서 최신 데이터로 추적 상황을 알아보려면 먼저 서버로부터 최신 데이터를 받아온 후에 추적 상황을 확인해야 한다. 아래처럼 세미콜론을 통해 두 명령을 이어서 사용하는 것이 적당하겠다.$ git fetch --all; git branch -vv 여기서 세미콜론(;)은 git의 고유 명령이 아닌 Unix 체계의 명령이다.세미콜론 앞의 명령어 실행을 마칠 때까지 기다린 후 이후의 명령어를 수행한다. 이는 동기식으로 진행되므로 두 명령어가 겹쳐 실행되는 경우는 없다.그리고 앞 명령어가 실패해도 다음 명령어가 실행된다.이와 유사한 명령이 있는데 기능은 다음과 같다.&amp;amp; → 앞의 명령어를 비동기로 실행하고 동시에 뒤의 명령어를 실행&amp;amp;&amp;amp; → 앞 명령어가 성공했을 때 다음 명령어 실행Pull 하기git fetch 명령을 실행하면 서버에는 존재하지만 로컬에는 아직 없는 데이터를 받아와서 저장한다. 이때 워킹 디렉터리의 파일 내용은 변경되지 않고 그대로 남는다. 서버로부터 데이터를 가져와서 저장해두고 사용자가 직접 Merge 하도록 준비만 해둔다.반면 git pull 명령은 git fetch 명령을 실행하고 나서 자동으로 git merge 명령을 수행하는 것 뿐이다. git clone 이나 git switch 명령을 실행하여 트래킹 브랜치가 설정되면 git pull 명령은 서버로부터 데이터를 가져와서 현재 로컬 브랜치와 서버의 트래킹 브랜치를 자동으로 Merge 한다.리모트 브랜치 삭제동료와 협업하기 위해 리모트 브랜치를 만들었다가 작업을 마치고 master 브랜치로 Merge 했다. 협업하는 데 사용했던 그 리모트 브랜치는 더 이상 필요하지 않기에 삭제할 수 있다. git push 명령에 --delete 혹은 : 옵션을 사용하여 리모트 브랜치를 삭제할 수 있다. serverfix 라는 리모트 브랜치를 삭제하려면 아래와 같이 실행한다.$ git push origin --delete serverfixor$ git push origin : serverfixTo https://github.com/schacon/simplegit - [deleted] serverfix위 명령을 실행하면 서버에서 브랜치(커밋을 가리키는 포인터) 하나가 사라진다. Git의 가비지 컬렉터가 동작하지 않는 한 데이터는 사라지지 않기 때문에 종종 의도치 않게 삭제한 경우에도 커밋한 데이터를 되살릴 수도 있다. 그러나 만약 가비지 컬렉터가 가비지 컬렉팅 작업을 수행해 Refs와 연결되어 있지 않은 커밋들을 삭제한 상태라면 브랜치 또는 커밋을 복구할 수 없으므로 백업용 저장소를 함께 운용하는 것이 좋다." }, { "title": "[Git] 브랜치 워크플로", "url": "/posts/Branching-Workflows/", "categories": "Git, Branch", "tags": "git branch, Git, VCS, DVCS, Github", "date": "2022-01-12 19:38:00 +0900", "snippet": "브랜치 워크플로브랜치를 생성하고 Merge 하는 것을 어디에 써먹어야 할까. 이 절에서는 유용한 몇 가지 워크플로를 살펴본다. 여기서 설명하는 워크플로를 개발에 적용하면 많은 도움이 될 것이다.Long-Running 브랜치Git은 꼼꼼하게 3-way Merge를 사용하기 때문에 장기간에 걸쳐서 한 브랜치를 다른 브랜치와 여러 번 Merge 하는 것이 쉬운 편이다. 그래서 개발 과정에서 필요한 용도에 따라 브랜치를 만들어 두고 계속 사용할 수 있다. 그리고 정기적으로 브랜치를 다른 브랜치로 Merge 한다.이런 접근법에 따라서 Git 개발자가 많이 선호하는 워크플로가 하나 있다. 배포했거나 배포할 코드만 master 브랜치에 Merge 해서 안정된 버전의 코드만 master 브랜치에 둔다. 개발을 진행하는 브랜치는 develop 이나 next 라는 이름으로 추가로 만들어 사용한다. 이 브랜치는 언젠가 안정 상태가 되겠지만, 항상 안정 상태를 유지해야 하는 것이 아니다. 테스트를 거쳐서 안정적이라고 판단되면 master 브랜치에 Merge 한다. 토픽 브랜치(앞서 살펴본 iss53 브랜치 같은 짧은 호흡 브랜치)에도 적용할 수 있는데, 해당 토픽을 처리하고 테스트해서 버그도 없고 안정적이면 그때 Merge 한다.사실 우리가 얘기하는 것은 커밋을 가리키는 포인터에 관한 얘기다(커밋 포인터 생성/수정/분리/합치기 등). 개발 브랜치는 공격적으로 히스토리를 만들어 나아가고 안정 브랜치는 이미 만든 히스토리를 뒤따르며 나아간다.안정적인 브랜치일수록 커밋 히스토리가 뒤쳐짐백신 실험실에서 각 백신 약물 버전을 충분히 테스트한 후 안정된 약물을 각지에 전달하는 과정으로 보면 이해하기 쉽다.각 브랜치는 백신 실험실로, 각 커밋은 약물 버전으로 이해코드를 여러 단계로 나누어 진행하므로 안정적으로 운영할 수 있게 된다. 프로젝트 규모가 크면 proposed 혹은 pu(proposed updates)라는 이름의 브랜치를 만들고 next나 master 브랜치에 아직 Merge 할 준비가 되지 않은 것을 일단 Merge 시킨다. 중요한 개념은 브랜치를 이용해 여러 단계에 걸쳐서 안정화해 나아가면서 충분히 안정화가 됐을 때 안정 브랜치로 Merge 한다는 점이다. 다시 말해서 Long-Running의 브랜치가 여러 개일 필요는 없지만 정말 유용하다는 점이다. 특히 규모가 크고 복잡한 프로젝트일수록 그 유용함이 더욱 빛나게 된다.토픽 브랜치토픽 브랜치는 프로젝트 크기에 상관없이 유용하다. 토픽 브랜치는 어떤 한 가지 주제나 작업을 위해 만든 짧은 호흡의 브랜치다. 다른 버전 관리 시스템에서는 이런 브랜치를 본 적이 없을 것이다. Git이 아닌 다른 버전 관리 도구에서는 브랜치를 하나 만드는 데 큰 비용이 든다. 그에 반해 Git은 비용이 부담되지 않아 개발자는 매우 일상적으로 브랜치를 만들고 Merge 하고 삭제한다.앞서 사용한 iss53 이나 hotfix 브랜치가 토픽 브랜치다. 우리는 브랜치를 새로 만들고 어느 정도 커밋하고 나서 다시 master 브랜치에 Merge 하고 브랜치 삭제도 해 보았다. 보통 주제별로 브랜치를 만들고 각각은 독립돼 있기 때문에 매우 쉽게 컨텍스트 사이를 옮겨 다닐 수 있다. 묶음별로 나눠서 일하면 내용별로 검토하기에도, 테스트하기에도 더 편하다. 각 작업을 하루든 한 달이든 유지하다가 master 브랜치에 Merge 할 시점이 되면 순서에 관계없이 그때 Merge 하면 된다.master 브랜치로 Switch 한 상태에서 어떤 작업을 한다고 해보자. 한 이슈를 처리하기 위해서 iss91 브랜치를 만들고 해당 작업을 한다. 같은 이슈를 다른 방법으로 해결해보고 싶을 때도 있다. iss91v2 브랜치를 만들고 다른 방법을 시도해 본다. 확신할 수 없는 아이디어를 적용해보기 위해 다시 master 브랜치로 되돌아가서 dumbidea 브랜치를 하나 더 만든다. 지금까지 설명한 커밋 히스토리는 아래 그림 같다.토픽 브랜치가 많음이슈를 처리했던 방법 중 두 번째 방법인 iss91v2 브랜치가 괜찮아서 적용하기로 결정했다. 그리고 아이디어를 확신할 수 없었던 dumbidea 브랜치를 같이 일하는 다른 개발자에게 보여줬더니 썩 괜찮다는 반응을 얻었다. iss91 브랜치는(C5, C6 커밋도 함께) 버리고 다른 두 브랜치를 Merge 하면 아래 그림과 같이 된다.dumbidea와 iss91v2 브랜치를 Merge 하고 난 후의 히스토리 모습분산 환경에서의 Git에서 프로젝트를 Git으로 관리할 때 브랜치를 이용하여 만들 수 있는 여러 워크플로에 대해 살펴본다. 관련 부분을 살펴보면 프로젝트에 어떤 형태로 응용할수 있을 지 감이 올 것이다.지금까지 한 작업은 전부 로컬에서만 처리한다는 것을 꼭 기억하자. 로컬 저장소에서만 브랜치를 만들고 Merge 했으며 서버와 통신을 주고받는 일은 없었다." }, { "title": "[Git] 브랜치 관리", "url": "/posts/Branch-Management/", "categories": "Git, Branch", "tags": "git branch, Git, VCS, DVCS, Github", "date": "2022-01-12 19:34:00 +0900", "snippet": "어떻게 충돌을 해결했고 좀 더 확인해야 하는 부분은 무엇이고 왜 그렇게 해결했는지에 대해서 자세하게 기록한다. 자세한 기록은 나중에 이 Merge 커밋을 이해하는데 도움을 준다.브랜치 관리지금까지 브랜치를 만들고, Merge 하고, 삭제하는 방법에 대해서 살펴봤다. 브랜치를 관리하는 데 필요한 다른 명령도 살펴보자.git branch 명령은 단순히 브랜치를 만들고 삭제하는 것이 아니다. 아무런 옵션 없이 실행하면 브랜치의 목록을 보여준다.$ git branch iss53* master testing 기호가 붙어 있는 master 브랜치는 현재 Switch 해서 작업 중인 브랜치를 나타낸다. 즉, 지금 수정한 내용을 커밋하면 master 브랜치에 커밋되고 포인터가 앞으로 한 단계 나아간다. git branch -v 명령을 실행하면 브랜치마다 마지막 커밋 메시지도 함께 보여준다.$ git branch -v iss53 93b412c fix javascript issue* master 7a98805 Merge branch &#39;iss53&#39; testing 782fd34 add scott to the author list in the readmes각 브랜치가 지금 어떤 상태인지 확인하기에 좋은 옵션도 있다. 현재 Switch 한 브랜치를 기준으로--merged 와 --no-merged 옵션을 사용하여 Merge 된 브랜치인지 그렇지 않은 브랜치인지 필터링해 볼 수 있다. git branch --merged 명령으로 이미 Merge 한 브랜치 목록을 확인한다.$ git branch --merged iss53* masteriss53 브랜치는 앞에서 이미 master 브랜치에 Merge 했기 때문에 목록에 나타난다. * 기호가 붙어 있지 않은 브랜치는 git branch -d 명령으로 삭제해도 된다. 이미 다른 브랜치와 Merge 했기 때문에 삭제해도 정보를 잃지 않기 때문이다(master에 iss53과 합쳐진 정보가 있음).반대로 Switch한 브랜치에 Merge하지 않은 브랜치를 살펴보려면 git branch --no-merged 명령을 사용한다.$ git branch --no-merged testing--merged 옵션을 사용했을때 보이지 않던 testing 브랜치가 보인다. 아직 Merge하지 않은 커밋을 담고 있기 때문에 git branch -d 명령으로 삭제되지 않는다.$ git branch -d testingerror: The branch &#39;testing&#39; is not fully merged.If you are sure you want to delete it, run &#39;git branch -D testing&#39;.Merge 하지 않은 브랜치를 강제로 삭제하려면 -D 옵션으로 삭제한다. 위에서 설명한 --merged, --no-merged 옵션을 사용할 때 커밋이나 브랜치 이름을 지정해주지 않으면 현재 브랜치를 기준으로 Merge 되거나 Merge 되지 않은 내용을 출력한다. 특정 브랜치를 기준으로 Merge 되거나 혹은 Merge 되지 않은 브랜치 정보를 살펴보려면 명령에 브랜치 이름을 지정해주면 된다. 예를 들어 master 브랜치에 아직 Merge되지 않은 브랜치를 살펴보려면 다음과 같은 명령을 실행한다. $ git switch testing$ git branch --no-merged master topicA featureB " }, { "title": "[Git] 브랜치와 Merge 기초", "url": "/posts/Basic-Branching-and-Merging/", "categories": "Git, Branch", "tags": "git merge, git branch, git switch, Git, VCS, DVCS, Github", "date": "2022-01-12 19:19:00 +0900", "snippet": "실제 개발환경에서 겪을 만한 예제를 하나 살펴보자. 브랜치와 Merge는 보통 이런 식으로 진행한다. 작업 중인 웹사이트가 있다. 새로운 이슈를 처리할 새 Branch를 하나 생성한다. 새로 만든 Branch에서 작업을 진행한다.이때 어떤 문제가 생겨서 그것을 해결하는 Hotfix 브랜치를 먼저 만들어야 한다. 그러면 아래와 같이 할 수 있다. 새로운 이슈를 처리하기 이전의 운영(Production) 브랜치로 이동한다. Hotfix 브랜치를 새로 하나 생성한다. 수정한 Hotfix 테스트를 마치고 운영 브랜치로 Merge 한다. 다시 작업하던 브랜치로 옮겨가서 하던 일을 진행한다.먼저 지금 작업하는 프로젝트에서 이전에 master 브랜치에 커밋을 몇 번 했다고 가정한다.현재 커밋 히스토리이슈 관리 시스템에 등록된 53번 이슈를 처리한다고 하면 이 이슈에 집중할 수 있는 브랜치를 하나 만든다. 브랜치를 만들면서 Switch까지 한 번에 하려면 git switch 명령에 -c 라는 옵션을 추가한다.$ git switch -c iss53Switched to a new branch &#39;iss53&#39;위 명령은 아래 명령을 줄여놓은 것이다.$ git branch iss53$ git switch iss53브랜치 포인터를 새로 만듦iss53 브랜치로 Switch 했기 때문에 HEAD는 iss53 브랜치를 가리키게 되고, 어떤 작업 후 새로 커밋하면 iss53 브랜치가 앞으로 뻗어나가게 된다.$ vim index.html$ git commit -a -m &#39;added a new footer [issue 53]&#39;진행 중인 iss53 브랜치다른 상황을 가정해보자. 특정 웹페이지에 문제가 생겨서 즉시 고쳐야 한다. 버그를 해결한 Hotfix에 기존의 iss53 내용이 섞이는 것을 방지하기 위해 iss53과 관련된 코드를 어딘가에 저장해두고 원래 운영 환경의 소스로 복구해야 한다. Git을 사용하면 이런 노력을 들일 필요 없이 그냥 master 브랜치로 돌아가면 된다.그러나 브랜치 이동시 아직 커밋하지 않은 파일이 Switch 할 브랜치와 충돌이 발생하면 브랜치를 변경할 수 없다. 브랜치를 변경할 때는 워킹 디렉터리를 정리하는 것이 좋다. 이런 문제를 다루는 방법은 주로 Stash나 커밋 Amend가 있으며, 나중에 Stashing과 Cleaing에서 다룰 것이다.지금은 작업하던 것을 모두 커밋하고 master 브랜치로 옮기자.$ git add .$ git commit -m &quot;Committing current datas.&quot;$ git switch masterSwitched to branch &quot;master&quot;이때 워킹 디렉터리는 iss53 이슈를 시작하기 이전의 모습으로 돌아가기 때문에 새로운 문제에 집중할 수 있는 환경이 만들어진다. Git은 자동으로 워킹 디렉터리에 파일들을 추가하고, 지우고, 수정해서 Switch한 브랜치의 마지막 스냅샷으로 되돌려 놓는다는 점을 기억하자.이젠 해결해야 할 핫픽스가 생긴 상황을 가정해보자. hotfix라는 브랜치를 만들고 이슈를 해결할 때까지 사용한다.$ git switch -c hotfixSwitched to a new branch &#39;hotfix&#39;$ vim index.html$ git commit -a -m &#39;fixed the broken email address&#39;[hotfix 1fb7853] fixed the broken email address 1 file changed, 2 insertions(+)master 브랜치에서 갈라져 나온 hotfix 브랜치Production 환경에 적용하려면 문제를 제대로 고쳤는지 테스트하고 최종적으로 Production에 배포하기 위해 hotfix 브랜치를 master 브랜치에 합쳐야 한다. git merge 명령으로 다음과 같이 한다.$ git switch master$ git merge hotfixUpdating f42c576..3a0874cFast-forward index.html | 2 ++ 1 file changed, 2 insertions(+)메시지에 “Fast-forward”가 보이는가? hotfix 브랜치가 가리키는 C4 커밋이 C2 커밋에 기반한 브랜치이기 때문에 브랜치 포인터는 Merge 과정 없이 그저 최신 커밋으로 이동한다. 이러한 Merge 방식을 “Fast-forward”라고 부른다.이제 hotfix는 master 브랜치에 포함됐고 Production 환경에 적용할 수 있는 상태가 되었다고 가정해보자.Merge 후 hotfix와 같은 커밋을 가리키는 master 브랜치급한 문제 해결 후 master 브랜치에 적용하고 나면 다시 본래 작업하던 브랜치로 돌아가야 한다. 더 이상 필요없는 hotfix 브랜치는 삭제한다. git branch 명령에 -d 옵션을 주고 브랜치를 삭제한다.$ git branch -d hotfixDeleted branch hotfix (3a0874c).이제 53번 이슈를 처리하던 환경인 iss53 브랜치로 돌아가서 하던 작업을 마저 진행하자.$ git switch iss53Switched to branch &quot;iss53&quot;$ vim index.html$ git add index.html$ git commit -m &#39;finished the new footer [issue 53]&#39;[iss53 ad82d7a] finished the new footer [issue 53]1 file changed, 1 insertion(+)master와 별개로 진행하는 iss53 브랜치위에서 작업한 hotfix 브랜치가 iss53 브랜치에 영향을 끼치지 않는다는 점을 이해하는 것이 중요하다. git merge master 명령으로 master 브랜치를 iss53 브랜치에 Merge 하면 iss53 브랜치에 hotfix가 적용된다. 아니면 iss53 브랜치가 master에 Merge 할 수 있는 수준이 될 때까지 기다렸다가 Merge 하면 hotfix와 iss53 브랜치가 합쳐진다.Merge 기초53번 이슈를 해결하고 master 브랜치에 Merge 하는 과정을 살펴보자. iss53 브랜치를 master 브랜치에 Merge하는 것은 앞서 살펴본 hotfix 브랜치를 master 브랜치에 Merge 하는 것과 비슷하다. git merge 명령으로 합칠 브랜치에서 합쳐질 브랜치를 명시하면 된다.$ git switch masterSwitched to branch &#39;master&#39;$ git merge iss53Merge made by the &#39;recursive&#39; strategy.index.html | 1 +1 file changed, 1 insertion(+)hotfix를 Merge 했을 때와 메시지가 다르다. 현재 브랜치가 가리키는 커밋이 Merge 할 브랜치의 조상이 아니므로 Git은 “Fast-forward” 방식으로 Merge 하지 않는다. 이 경우에는 Git은 브랜치가 가리키는 커밋 두 개와 공통 조상(Common Ancestor) 하나를 사용하여 “3-way” Merge를 한다.커밋 3개를 Merge단순히 브랜치 포인터를 최신 커밋으로 옮기는 게 아니라 3-way Merge의 결과를 별도의 커밋으로 만들고 나서 해당 브랜치가 그 커밋을 가리키도록 이동시킨다. 그래서 이런 커밋은 부모가 여러 개고(여기선 두 개) Merge 커밋이라고 부른다.Merge 커밋iss53 브랜치를 master에 Merge하고 나면 더는 iss53 브랜치는 필요 없으므로 삭제 후 이슈 처리 완료 상태로 표시한다.$ git branch -d iss53충돌의 기초가끔 3-way Merge가 실패할 때도 있다. Merge 하는 두 브랜치에서 같은 파일의 한 부분을 동시에 수정하고 Merge 하면 Git은 해당 부분을 Merge 하지 못한다. 예를 들어 iss53과 hotfix가 같은 부분을 수정했다면 Git은 Merge 하지 못하고 아래와 같은 충돌(Conflict) 메시지를 출력한다.$ git merge iss53Auto-merging index.htmlCONFLICT (content): Merge conflict in index.htmlAutomatic merge failed; fix conflicts and then commit the result.Git은 자동으로 Merge하지 못해서 새 커밋이 생기지 않는다. 변경사항의 충돌을 개발자가 해결하지 않는 한 Merge 과정을 진행할 수 없다. Merge 충돌이 발생한 파일 내역을 보려면 git status 명령을 이용한다.$ git statusOn branch masterYou have unmerged paths. (fix conflicts and run &quot;git commit&quot;)Unmerged paths: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to mark resolution) both modified: index.htmlno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)충돌이 일어난 파일은 Unmerged 상태로 표시된다. Git은 충돌이 발생한 부분을 표준 형식에 따라 표시해준다. 개발자는 해당 내용을 보고 직접 수정해야 한다. 표준 형식을 따른 충돌 내역 예시는 다음과 같다.&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD:index.html&amp;lt;div id=&quot;footer&quot;&amp;gt;contact : email.support@github.com&amp;lt;/div&amp;gt;=======&amp;lt;div id=&quot;footer&quot;&amp;gt; please contact us at support@github.com&amp;lt;/div&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; iss53:index.html“=======” 위쪽의 내용은 HEAD 버전(merge 명령을 실행할 때 작업하던 master 브랜치)의 내용이고 아래쪽은 iss53 브랜치의 내용이다. 충돌을 해결하려면 위쪽이나 아래쪽 내용 중에서 고르거나 새로 작성하여 Merge 한다. 아래는 아예 새로 작성하여 충돌을 해결하는 예제다.&amp;lt;div id=&quot;footer&quot;&amp;gt;please contact us at email.support@github.com&amp;lt;/div&amp;gt;충돌한 양쪽에서 조금씩 가져와서 새로 수정했다. 그리고 ”«««&amp;lt;”, ”=======”, ”»»»&amp;gt;”가 포함된 행을 삭제했다. 이렇게 충돌한 부분을 해결하고 git add 명령으로 다시 Stage 한다.git status 명령으로 충돌이 해결된 상태인지 확인해보자.$ git statusOn branch masterAll conflicts fixed but you are still merging. (use &quot;git commit&quot; to conclude merge)Changes to be committed: modified: index.html충돌 해결 및 해당 파일이 Staging Area에 저장됐는지 확인했으면 git commit 명령으로 Merge 한 내용을 커밋한다. 충돌을 해결하고 Merge 할 때는 커밋 메시지가 아래와 같다.Merge branch &#39;iss53&#39;Conflicts: index.html## It looks like you may be committing a merge.# If this is not correct, please remove the file# .git/MERGE_HEAD# and try again.# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.# On branch master# All conflicts fixed but you are still merging.## Changes to be committed:# modified: index.html#" }, { "title": "[Git] 브랜치 및 커밋 개체 생성 과정", "url": "/posts/Creating-a-New-Branch/", "categories": "Git, Branch", "tags": "git branch, git switch, Git, VCS, DVCS, Github", "date": "2022-01-12 19:00:00 +0900", "snippet": "Git이 브랜치를 다루는 과정을 이해하려면 Git이 데이터를 어떻게 저장하는지 알아야 한다.Git은 데이터를 변경사항(Diff)으로 기록하지 않고 일련의 스냅샷으로 기록한다.커밋하면 Git은 현 Staging Area에 있는 데이터의 스냅샷에 대한 포인터, 저자나 커밋 메시지 같은 메타데이터, 이전 커밋에 대한 포인터 등을 포함하는 커밋 개체(커밋 Object)를 저장한다. 이전 커밋 포인터가 있어서 현재 커밋이 어떤 커밋을 기준으로 바뀌었는지를 알 수 있다. 최초 커밋을 제외한 나머지 커밋은 이전 커밋 포인터가 적어도 하나씩 있고 브랜치를 합친 Merge 커밋 같은 경우에는 이전 커밋 포인터가 여러개 있다.파일이 3개 있는 디렉터리가 하나 있고 이 파일을 Staging Area에 저장하고 커밋하는 예제를 살펴보자. 파일을 Stage하면 Git 저장소에 파일을 저장하고(Git은 이것을 Blob이라고 부른다) Staging Area에 해당 파일의 체크섬을 저장한다.$ git add README test.rb LICENSE$ git commit -m &#39;initial commit&#39;git commit으로 커밋하면 먼저 루트 디렉터리와 각 하위 디렉터리의 트리 개체를 체크섬과 함께 저장소에 저장한다. 그 다음에 커밋 개체를 만들고 메타데이터와 루트 디렉터리 트리 개체를 가리키는 포인터 정보를 커밋 개체에 넣어 저장한다.※ 체크섬은 SHA-1을 사용해 구성된다.이 작업을 마치고 나면 Git 저장소에는 다섯 개의 데이터 개체가 생긴다. 메타데이터와 루트 트리를 가리키는 포인터가 담긴 커밋 개체 하나 파일과 디렉터리 구조가 들어 있는 트리 개체 하나 각 파일에 대한 Blob 세 개커밋과 트리 데이터파일을 수정하고 커밋하면 이전 커밋이 무엇인지도 저장한다.커밋과 이전 커밋Git의 브랜치는 커밋 사이를 이동할 수 있는 포인터 같은 개념이다. Git은 기본적으로 master(or main) 브랜치를 만든다. 처음 커밋하면 이 master 브랜치가 생성된 커밋을 가리킨다. 이후 커밋을 만들면 브랜치는 자동으로 가장 마지막 커밋을 가리킨다.새 브랜치 생성하기브랜치를 하나 만들어 보자.$ git branch testing새로 만든 브랜치도 지금 작업하고 있던 마지막 커밋을 가리킨다.한 커밋 히스토리를 가리키는 두 브랜치지금 작업 중인 브랜치가 무엇인지 Git은 어떻게 파악할까? 다른 VCS와는 달리 Git은 “HEAD”라는 특수한 포인터가 있다. 이 포인터는 지금 작업하는 로컬 브랜치를 가리킨다. 브랜치를 새로 만들었지만, Git은 아직 master 브랜치를 가리키고 있다. git branch 명령은 브랜치를 만들기만 하고 브랜치를 옮기지는 않기 때문이다.현재 작업 중인 브랜치를 가리키는 HEADgit log 명령을 사용하면 HEAD가 어떤 커밋을 가리키고 있는지 확인할 수 있다.브랜치 이동하기git switch 명령으로 HEAD를 다른 브랜치로 이동시킬 수 있다. 한번 testing 브랜치로 옮겨보자.$ git switch testing$ git log --onelineHEAD는 testing 브랜치를 가리킴HEAD가 testing 브랜치를 가리키는 것을 알 수 있다.testing 브랜치에서 파일 생성 후 커밋을 새로 해보자.$ echo &#39;on testing branch&#39; &amp;gt; test.rb$ git add test.rb$ git commit -m &#39;made a change in testing branch&#39;HEAD가 가리키는 testing 브랜치가 새 커밋을 가리킴새로 커밋해서 testing 브랜치는 앞으로 이동했다. 하지만 master 브랜치는 여전히 이전 커밋을 가리킨다. master 브랜치로 돌아가 보자.$ git switch masterHEAD가 Switch한 브랜치(master)로 이동함방금 실행한 명령이 한 일은 두 가지다. master 브랜치가 가리키는 커밋을 HEAD가 워킹 디렉터리의 파일도 그 시점으로 되돌려 놓았다. 앞으로 커밋을 하면 다른 브랜치의 작업들과 별개로 진행되기 때문에 testing 브랜치에서 임시로 작업하고 원래 브랜치인 master로 돌아와서 하던 일을 계속할 수 있다. 브랜치를 이동하면 워킹 디렉토리의 파일이 변경된다는 점을 기억해두어야 한다. 이전에 작업했던 브랜치로 이동하면 워킹 디렉토리의 파일은 그 브랜치에서 가장 마지막으로 했던 작업 내용으로 변경된다. 파일 변경시 문제가 있어 브랜치를 이동시키는게 불가능한 경우 Git은 브랜치 이동 명령을 수행하지 않는다.master 브랜치에서 파일을 생성하고 다시 커밋해보자.$ echo &#39;on master branch&#39; &amp;gt; test.rb$ git add test.rb$ git commit -m &#39;made other changes in master branch&#39;갈라지는 브랜치브랜치가 갈라져 각 브랜치에 있는 test.rb 파일은 서로 다른 파일이 된다.git log 명령을 통해 현재 브랜치가 가리키고 있는 히스토리가 무엇이고 어떻게 갈라져 나왔는지 보여준다. git log --oneline --graph --all 이라고 실행하면 히스토리를 출력한다.$ git log --oneline --graph --all* c2b9e (HEAD, master) made other changes| * 87ab2 (testing) made a change|/* f30ab add feature #32 - ability to add new formats to the* 34ac2 fixed bug #1328 - stack overflow under certain conditions* 98ca9 initial commit of my project실제로 Git의 브랜치는 어떤 한 커밋을 가리키는 40글자의 SHA-1 체크섬 파일에 불과하기 때문에 마만들기도 쉽고 지우기도 쉽다. 새로 브랜치를 하나 만드는 것은 41바이트 크기의 파일(40자와 줄 바꿈 문자)을 하나 만드는 것에 불과하다.브랜치가 필요할 때 프로젝트를 통째로 복사해야 하는 다른 VCS와 Git의 차이는 극명하다. 통째로 복사하는 작업은 수십 초에서 수십 분까지 걸린다. 그에 비해 Git은 순식간이다. 게다가 커밋을 할 때마다 이전 커밋의 정보를 저장하기 때문에 Merge할 때 어디서부터(Merge Base) 합쳐야 하는지 안다." }, { "title": "[Git] 태그", "url": "/posts/Tagging/", "categories": "Git, Tag", "tags": "git remote, git fetch, git pull, Git, VCS, DVCS, Github", "date": "2022-01-12 18:44:00 +0900", "snippet": "Git의 태그는 브랜치와 비슷한데 브랜치처럼 가리키는 지점을 최신 커밋으로 이동시키지 않는다. 단순히 특정 커밋에 대한 포인터일 뿐이다.보통 Release할 때 사용하며(v1.0 등등) Git을 우아하게 다루기 위해 태그를 잘 알아두는 것이 좋다!태그 종류, 조회, 생성, 삭제에 관해 알아보자.태그 종류태그는 Lightweight 태그와 Annotated 태그 두 종류가 있다.Lightweight 태그는 따로 정보를 저장하지 않고 단순한 태그가 필요할 경우 사용한다.Annotated 태그는 Git 데이터베이스에 태그를 만든 사람의 이름, 이메일과 태그를 만든 날짜, 그리고 태그 메시지도 저장한다. GPG(GNU Privacy Guard)로 서명할 수도 있다. 이 모든 정보를 저장해둬야 할 때만 사용하길 추천한다.태그 조회하기git tag 명령으로 이미 만들어진 태그가 있는지 확인할 수 있다.Annotated 태그 생성git tag -a 명령을 통해 Annotated 태그를 생성할 수 있다. 또한, 메시지를 추가하기 위해 -m 옵션을 추가하면 된다(-m 옵션을 추가해놓고 메시지를 추가하지 않았을 경우 Git은 편집기를 실행시킨다).git show &amp;lt;tag-name&amp;gt; 명령으로 태그 정보와 커밋 정보를 모두 확인할 수 있다.커밋 정보를 보여주기 전에 먼저 태그를 만든 사람(Tagger)이 누구인지, 언제 태그를 만들었는지(Date), 그리고 태그 메시지가 무엇인지(여기선 “my version 1.0.0”) 보여준다.Lightweight 태그 생성Lightweight 태그는 기본적으로 파일에 커밋 체크섬을 저장하는 것뿐이다. 다른 정보는 저장하지 않는다. Lightweight 태그를 만들 때는 -a, -s, -m 옵션을 사용하지 않는다.이 태그에 git show 명령을 실행하면 별도의 태그 정보를 확인할 수 없다. 단순히 커밋 정보만을 보여줄 뿐이다.나중에 태그하기예전 커밋에도 태그할 수 있다. 커밋 히스토리는 아래와 같다고 가정한다.“removed unnecessary test code” 커밋을 v0.0.3로 태그하지 못했다고 해도 나중에 태그를 붙일 수 있다. 특정 커밋에 태그하기 위해서 명령의 끝에 커밋 체크섬을 명시한다. 참고로 긴 체크섬을 전부 명시 할 필요는 없다.※ 앞에서 설명했듯이 태그는 특정 커밋(여기서는 085bb3b…)을 포인팅할 뿐, HEAD는 해당 커밋을 가리키지는 않는다.태그 삭제하기git tag -d &amp;lt;tag-name&amp;gt; 명령을 통해 Lightweight, Annotated 태그 모두 삭제할 수 있다.태그 공유하기git push 명령은 자동으로 리모트 서버에 태그를 전송하지 않는다. 태그를 만들었으면 서버에 별도로 Push해야 한다. 브랜치를 공유하는 것과 같은 방법으로 할 수 있다. git push origin &amp;lt;tag-name&amp;gt; 명령을 통해 리모트 서버에 Push 한다.만약 한번에 태그를 여러 개 Push하고 싶으면 --tags 옵션을 추가하여 git push 명령을 실행한다.git push origin --tags이제 누군가 저장소에서 Clone하거나 Pull하면 모든 태그 정보도 함께 전송된다.태그 Checkout 하기태그는 브랜치와 달리 가리키는 커밋을 바꿀 수 없기 때문에 Checkout해서 사용할 수 없다. 태그가 가리키는 특정 커밋을 기반으로 하는 브랜치를 만들어 작업하려면 아래와 같이 새로 브랜치를 생성해야 한다.HEAD가 br_version2로 이동됨에 따라 해당 v0.0.4 태그 이후에 존재하던 3개의 커밋이 보이지 않게 됐다(영구적으로 사라진 것은 아니다). 물론 이렇게 브랜치를 만든 후에 br_version2 브랜치에서 커밋하면 브랜치 내용은 업데이트 된다. 하지만 v0.0.4 태그는 가리키는 커밋이 변하지 않았으므로 브랜치 br_version2와 태그 v0.0.4가 가리키는 커밋이 서로 다르다는 것을 알 수 있다.보다시피 a11bef0 커밋에서 내용 수정 후 커밋 하니깐 3337aae 커밋이 새로 생성되었고, HEAD 또한 변경되었다. 반면 태그는 그대로 a11bef0 커밋을 포인팅하고 있다. 이러한 태그의 특성으로 인해 발현된 상태를 Git에서 Detached HEAD state라고 정의한다. 반대로 HEAD가 브랜치를 통해 커밋을 가리키는 상태를 Attached HEAD state라고 정의한다." }, { "title": "[Git] Alias", "url": "/posts/Git-Aliases/", "categories": "Git, Getting Started", "tags": "git config, Git Alias, Git, VCS, DVCS, Github", "date": "2022-01-12 18:44:00 +0900", "snippet": "Git의 명령을 전부 입력하는 것이 귀찮다면 git config를 사용하여 각 명령을 단축하여 사용할 수 있도록 설정하면 된다.$ git config --global alias.co checkout$ git config --global alias.br branch$ git config --global alias.ci commit$ git config --global alias.st status이제 git commit 대신 git ci 만으로도 커밋할 수 있다. 이 처럼 자주 사용하는 명령들을 Alias를 등록해 편하게 사용할 수 있다.이미 있는 명령 또한 축약해 사용할 수 있다. 예를 들어 파일을 Unstaged 상태로 만드는 명령을 만들어서 불편함을 덜 수 있다.$ git config --global alias.unstage &#39;restore --staged&#39;or$ git config --global alias.unstage &#39;reset HEAD --&#39;아래 세 명령은 동일한 명령이 된다.$ git unstage fileA$ git restore --staged fileA$ git reset HEAD fileA한결 간결해졌다. 추가로 last 명령을 만들어 보자.$ git config --global alias.last &#39;log -1 HEAD&#39;이제 최근 커밋을 좀 더 쉽게 확인할 수 있다.Git의 명령어 뿐만 아니라 외부 명령어도 실행할 수 있다. !를 맨 앞에 추가하면 외부 명령을 실행한다. 커스텀 스크립트를 만들어 사용할 때 매우 유용하다. 아래 명령은 git visual이라고 입력하면 extScr가 실행된다.$ git config --global alias.visual &#39;!extScr&#39;" }, { "title": "[Git] 리모트 저장소", "url": "/posts/Working-with-Remotes/", "categories": "Git, Getting Started", "tags": "git tag, Lightweight Tag, Annotated Tag, Git, VCS, DVCS, Github", "date": "2022-01-12 18:36:00 +0900", "snippet": "리모트 저장소를 알아야 다른 개발자들과 협업할 수 있다.리모트 저장소는 인터넷이나 네트워크 어딘가에 있는 저장소를 말한다. 저장소는 여러 개가 있을 수 있는데 어떤 저장소는 읽고 쓰기 모두 할 수 있고 어떤 저장소는 읽기만 가능하다. 간단히 말해서 다른 개발자들과 함께 협업한다는 것은 리모트 저장소를 관리하면서 데이터를 거기에 Push하고 Pull하는 것이다. 리모트를 관리한다는 것은 저장소를 추가, 삭제하는 것뿐만 아니라 브랜치를 관리하고 추적할지 말지 등을 관리하는 것을 말한다. 이번에는 리모트 저장소를 관리하는 방법에 대해 설명한다.리모트 저장소 확인하기git remote 명령으로 현재 프로젝트에 등록된 리모트 저장소를 확인할 수 있다. 저장소를 Clone하면 origin이라는 이름의 리모트 저장소가 자동으로 등록된다.-v 옵션을 주어 단축 이름과 URL을 함께 볼 수 있다.만약 리모트 저장소가 여러 개 있다면 이 명령은 등록된 전부를 보여준다. 여러 사람과 함께 작업하는 리모트 저장소가 여러 개라면 아래와 같은 결과를 얻을 수 도 있다.이렇게 여러 리모트 저장소가 등록되어 있으면 다른 사람이 기여한 내용(Contributions)을 쉽게 가져올 수 있다. 어떤 저장소에는 Push 권한까지 제공하기도 하지만 일단 이 화면에서 Push 기능 권한까지는 확인할 수 없다.리모트 저장소 추가하기git remote add &amp;lt;remote-name&amp;gt; &amp;lt;url&amp;gt; 명령을 통해 리모트 저장소를 쉽게 추가할 수 있다.리모트 저장소를 Pull하거나 Fetch하기git fetch &amp;lt;remote-name&amp;gt; 명령을 통해 리모트 저장소에서 모든 브랜치 데이터를 받아올 수 있다.저장소를 Clone하면 명령은 자동으로 리모트 저장소를 “origin”이라는 이름으로 추가한다. 그래서 나중에 git fetch origin을 실행하면 Clone 한 이후에 리모트 저장소에서 수정된 것을 모두 가져온다. git fetch 명령은 리모트 저장소의 데이터를 모두 로컬로 가져오지만, 자동으로 Merge하지는 않는다. 그래서 우리가 로컬에서 하던 작업을 정리하고 나서 수동으로 Merge해야 한다.이 번거로움을 해소하기 위해 있는 명령어가 git pull이다. 이 명령으로 리모트 저장소 브랜치에서 데이터를 가져올 뿐만 아니라 자동으로 로컬 브랜치와 Merge해준다.리모트 저장소에 Push하기프로젝트를 공유하고 싶을 때 Upstream 저장소에 Push할 수 있다. 이 명령은 git push &amp;lt;remote-name&amp;gt; &amp;lt;branch-name&amp;gt;으로 단순하다. master 브랜치를 origin 서버에 Push하려면 아래와 같은 명령을 쓰면 된다.$ git push origin master이 명령은 origin 저장소에 쓰기 권한이 있고, Clone하고 난 후 아무도 Upstream 저장소에 Push하지 않았을 때만 사용할 수 있다. 다시 말해서 Clone한 사람이 여러 명 있을 때, 다른 사람이 Push한 경우 나는 Push 할 수 없다. 먼저 다른 사람이 작업한 것을 가져와서 Merge한 후에 Push할 수 있다.리모트 저장소 살펴보기git remote show &amp;lt;remote-name&amp;gt; 명령으로 리모트 저장소의 구체적인 정보를 확인할 수 있다.리모트 저장소의 URL과 추적 중인 브랜치를 출력한다. 이 명령은 git pull 명령을 실행할 때 master 브랜치와 Merge할 브랜치가 무엇인지 보여준다.추후 프로젝트가 점점 커지면서 브랜치가 여러개가 되면 git push 명령을 실행할 때 어떤 브랜치가 어떤 브랜치로 Push되는지, 아직 로컬로 가져오지 않은 리모트 저장소의 브랜치는 어떤 것들이 있는지, 서버에서는 삭제됐지만 아직 가지고 있는 브랜치는 어떤 것인지, git pull 명령을 실행했을 때 자동으로 Merge할 브랜치는 어떤 것이 있는지 볼 수 있다.리모트 저장소 이름을 바꾸거나 리모트 저장소를 삭제하기git remote rename &amp;lt;old-remote-name&amp;gt; &amp;lt;new-remote-name&amp;gt; 명령으로 리모트 저장소의 이름을 변경할 수 있다. 예를 들어 example을 ex로 변경하려면 다음과 같이 하면 된다.리모트 저장소를 삭제해야 한다면 git remote rm 명령을 사용한다." }, { "title": "[Git] 커밋 되돌리기", "url": "/posts/Undoing-Things/", "categories": "Git, Getting Started", "tags": "git reset, git restore, git checkout, Git, VCS, DVCS, Github", "date": "2022-01-12 18:27:00 +0900", "snippet": "종종 완료한 커밋을 수정해야 할 때가 있다. 너무 일찍 커밋했거나 어떤 파일을 빼먹었을 때 그리고 커밋 메시지를 잘못 적었을 때 그렇다. 기존 커밋에 다시 커밋하려면 --amend를 사용하면 된다.$ git commit --amend만약 마지막으로 커밋하고 나서 수정한 것이 없다면(커밋하자마자 바로 이 명령을 실행하는 경우) 조금 전에 한 커밋과 모든 것이 같고, 커밋 메시지만 수정한다.커밋을 했는데 Stage하는 것을 깜빡하고 빠트린 파일이 있으면 아래와 같이 고칠 수도 있다.$ git commit -m &quot;initial commit&quot;$ git add forgotten_file$ git commit --amend여기서 실행한 명령어 3개는 모두 하나의 커밋으로 기록된다.파일 상태를 Unstage로 변경하기예를 들어 파일 두 개를 수정하고서 따로따로 커밋하려고 했지만, 실수로 git add * 명령을 실행해 버린 경우 두 파일 모두 Staging Area에 들어있게 된다. 이제 둘 중 하나를 어떻게 꺼낼까? 우선 git status 명령으로 확인해보자.$ git add *$ git status“Changes to be committed” 밑에 “git restore –staged ...” 메시지가 보인다. 이 명령으로 Unstaged 상태로 변경할 수 있다. CONTRIBUTING.md 파일을 Unstaged 상태로 변경해보자.※ Git 2.23.0 이전 버전의 경우 “git reset HEAD ...” 로 보일 것이다. 이 명령 또한 `git restore --staged`와 같은 기능을 한다.$ git restore --staged CONTRIBUTING.md$ git status보다시피 CONTRIBUTING.md 파일이 정상적으로 Unstaged 상태가 됐다. git reset 명령을 --hard 옵션과 함께 사용하면 워킹 디렉터리 파일까지 수정되기에 조심해야 한다. --hard 옵션만 사용하지 않는다면 git reset 명령은 Staging Area의 파일만 조작하기 때문에 위험하지 않다.Modified 파일 되돌리기어떻게 해야 CONTRIBUTING.md 파일을 수정하고 나서 다시 되돌릴 수 있을까? 그러니까 최근 커밋된 버전으로(아니면 처음 Clone 했을 때처럼 워킹 디렉터리에 처음 Checkout한 그 내용으로) 되돌리는 방법이 무얼까? git status 명령이 친절하게 알려준다. 바로 앞 쪽의 예제에서 Unstaged 부분을 보자.위 메시지는 수정한 파일을 되돌리는 방법을 꽤 정확하게 알려준다. 그대로 해보자.※ Git 2.23.0 이전 버전을 사용하는 경우 git restore &amp;lt;file&amp;gt;... 이 아닌 git checkout -- &amp;lt;file&amp;gt;... 로 나타날 것이다. 둘 다 같은 기능을 한다. 앞으로 파일 원복시 최신 트렌드에 맞도록 되도록이면 checkout이 아닌 restore를 사용하도록 하자.$ git restore CONTRIBUTING.mdCONTRIBUTING.md 파일이 정상적으로 수정하기 이전 상태로 돌아가 Staging Area에서 보이지 않는 것을 알 수 있다. git checkout -- &amp;lt;file&amp;gt;... 혹은 git restore &amp;lt;file&amp;gt;... 명령은 꽤 위험한 명령이라는 것을 알아야 한다. 원래 파일로 덮어썼기 때문에 수정한 내용은 전부 사라지기 때문이다. 수정한 내용이 정말로 마음에 들지 않을 때만 사용하도록 하자.※ checkout 다음에 나오는 “–”는 Git의 고유 옵션이 아닌 Unix의 일반적인 명령어 이다. 의미는 다음에 나오는 모든 문자를 문자열로 취급하라는 것이다.예) git checkout -- -f : 여기서 -f는 Git의 옵션이 아닌 문자열로 취급하므로 -f 라는 이름을 지닌 파일을 원복하게 된다.여기서 checkout 명령의 단점이 드러나게 된다. 파일 원복과 브랜치 이동이 하나의 명령에 포함되므로 만약 master라는 이름의 파일을 원복하고 싶을때 git checkout master로 입력하게 되면 파일 원복이 아닌 master 브랜치로 이동하기 때문이다.또, “-”로 시작하는 파일을 원복하고 싶어 git checkout -someFile 명령을 입력하면 -someFile 이라는 옵션이 checkout 명령어에서 지원하지 않는다는 메시지가 뜰 것이다.그러므로 “–” 옵션을 통해 강제로 문자열화 시켜주어야 하는 것이다.따라서 Git은 2.23.0 버전 이후 checkout 명령을 두 가지로 나누어 브랜치 이동시 switch, 파일 원복시 restore를 권장하는 것이다.만약 변경한 내용을 잠시 보존 후 이전 커밋으로 되돌아가야 하는 경우 stash와 branch를 사용하자.Git으로 커밋한 모든 것들은 언제나 복구할 수 있다. 삭제한 브랜치에 있었던 것도, --amend 옵션으로 다시 커밋한 것도 복구할 수 있다. 하지만 커밋하지 않고 잃어버린 것은 절대로 되돌릴 수 없다." }, { "title": "[Git] 커밋 히스토리 조회하기", "url": "/posts/Viewing-the-Commit-History/", "categories": "Git, Getting Started", "tags": "Commit History, Git, VCS, DVCS, Github", "date": "2022-01-12 18:08:00 +0900", "snippet": "그 동안 커밋했던 내역을 보고싶은 경우 git log 명령을 활용하면 된다.아래 예제에서는 “simplegit”이라는 매우 단순한 프로젝트를 사용한다. 아래와 같이 이 프로젝트를 Clone 한다.$ git clone https://github.com/schacon/simplegit-progit이 프로젝트 디렉터리에서 git log 명령을 실행하면 아래와 같이 출력된다.특별한 아규먼트 없이 git log 명령을 실행하면 저장소의 커밋 히스토리를 시간 순으로 보여준다. 즉, 가장 최근 커밋이 가장 먼저 나온다. 그리고 이어서 각 커밋의 SHA-1 체크섬, 저자 이름, 저자 이메일, 커밋한 날짜, 커밋 메시지를 보여준다.원하는 히스토리를 검색할 수 있도록 git log 명령은 매우 다양한 옵션을 지원한다. 여기에서는 자주 사용하는 옵션을 설명한다.여러 옵션 중 -p는 굉장히 유용한 옵션이다. -p는 각 커밋의 diff 결과를 보여준다.다른 유용한 옵션으로 -2가 있는데 최근 두 개의 결과만 보여주는 옵션이다.git log -p -2 처럼 두 옵션을 합쳐 사용하면 두 개의 커밋 히스토리를 diff를 포함해 보여준다.각 커밋 히스토리의 통계 정보를 보고싶은 경우 --stat 옵션을 활용하면 된다.이 결과에서 어떤 파일이 수정됐는지, 얼마나 많은 파일이 변경됐는지, 또 얼마나 많은 라인을 추가하거나 삭제했는지 보여준다. 요약 정보는 각 커밋의 가장 마지막 줄에 보여준다.다른 또 다른 유용한 옵션은 --pretty 옵션이다. 이 옵션을 통해 히스토리 내용을 보여줄 때 기본 형식 이외에 여러 가지 중 하나를 선택할 수 있다. 몇 개 선택할 수 있는 옵션의 값이 있는데, 이 중 oneline 옵션은 각 커밋을 한 라인으로 보여준다. 이 옵션은 많은 커밋을 한 번에 조회할 때 유용하다.추가로 short, full, fuller 옵션도 있는데 이것은 정보를 조금씩 가감해서 보여준다.사용자가 직접 지정한 포맷으로 결과를 출력하고 싶은 경우 format 옵션을 활용한다. 특히 조회 결과를 다른 프로그램으로 파싱하고자 할 때 유용하다. 이 옵션을 사용하면 포맷을 정확하게 일치시킬 수 있기 때문에 Git을 새 버전으로 바꿔도 결과 포맷이 바뀌지 않는다.git log –pretty=format에 쓸 수 있는 몇 가지 유용한 옵션저자(author)와 커미터(committer)를 구분하는 것이 조금 이상해 보일 수 있다. 저자는 원래 작업을 수행한 원작자이고 커미터는 마지막으로 이 작업을 적용한(저장소에 포함한) 사람이다. 만약 여러분이 어떤 프로젝트에 패치를 보냈고 그 프로젝트의 담당자가 패치를 적용했다면 두 명의 정보를 알 필요가 있다. 그래서 이 경우 여러분이 저자고 그 담당자가 커미터다.oneline과 format 옵션은 --graph 옵션과 함께 사용할 때 더 빛난다. 이 명령은 브랜치와 머지 히스토리를 보여주는 아스키 그래프를 출력한다.git log 주요 옵션조회 제한조건git log 명령엔 조회 범위를 제한하는 옵션도 있다. 이미 최근 두 개의 커밋만 조회하는 -2 옵션은 살펴봤다. 실제 사용법은 -&amp;lt;n&amp;gt;이고 n은 최근 n개 커밋을 의미한다.--since나 --until 같은 시간을 기준으로 조회하는 옵션 또한 있다.$ git log --since=2.weeks이 옵션은 다양한 형식을 지원한다. “2010-5-25”같이 정확한 날짜로 지정할 수도 있고 “2 years 1 day 3 minutes ago”와 같이 상대적인 기간을 사용할 수도 있다.또 다른 기준도 있다. --author 옵션으로 저자를 지정하여 검색할 수도 있고 --grep 옵션으로 커밋 메시지에서 키워드를 검색할 수도 있다. author와 grep옵션을 함께 사용하여 조건에 모두 만족하는 커밋을 찾으려면 --all-match 옵션도 반드시 함께 사용해야 한다.유용한 옵션으로는 -S가 있는데 이 옵션은 코드에서 추가되거나 제거된 내용 중에 특정 텍스트가 포함되어 있는지를 검색한다. 예를 들어 어떤 함수가 추가되거나 제거된 커밋만을 찾아볼 수 있다.“0.1.1” 이라는 문자가 해당 커밋에서 추가되었고, 이를 표시한다.git log 조회 범위를 제한하는 옵션" }, { "title": "[Git] 파일 이름 변경하기", "url": "/posts/Moving-Files/", "categories": "Git, Getting Started", "tags": "git mv, Git, VCS, DVCS, Github", "date": "2022-01-12 18:02:00 +0900", "snippet": "Git은 다른 VCS와는 달리 파일 이름의 변경이나 파일의 이동을 명시적으로 관리하지 않는다. 다시 말해서 파일 이름이 변경됐다는 별도의 정보를 저장하지 않는다. Git은 굳이 파일 이름이 변경되었다는 것을 추적하지 않아도 아는 방법이 있다.이렇게 말하고 Git에 mv 명령이 있는 게 좀 이상하겠지만, 아래와 같이 파일 이름을 변경할 수 있다.$ git mv file_from file_to잘 동작한다. 이 명령을 실행하고 Git의 상태를 확인해보면 Git은 이름이 바뀐 사실을 알고 있다.$ git mv README.md README$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage) renamed: README.md -&amp;gt; README사실 git mv 명령은 아래 명령어를 수행한 것과 완전 똑같다.$ mv README.md README$ git rm README.md$ git add READMEgit mv 명령은 일종의 단축 명령어이다. 이 명령으로 파일 이름을 바꿔도 되고 mv 명령으로 파일 이름을 직접 바꿔도 된다. 단지 Git의 mv 명령은 편리하게 명령을 세번 실행해주는 것뿐이다. 어떤 도구로 이름을 바꿔도 상관없다. 중요한 것은 이름을 변경하고 나서 꼭 rm/add 명령을 실행해야 한다는 것이다." }, { "title": "[Git] 파일 삭제하기", "url": "/posts/Removing-Files/", "categories": "Git, Getting Started", "tags": "git rm, Git, VCS, DVCS, Github", "date": "2022-01-12 17:58:00 +0900", "snippet": "Git에서 파일을 제거하려면 git rm 명령으로 Tracked 상태의 파일을 삭제한 후(정확하게는 Staging Area에서 삭제하는 것) 커밋해야 한다. 이 명령은 워킹 디렉터리에 있는 파일도 삭제하기 때문에 실제로 파일도 지워진다. Git 명령을 사용하지 않고 단순히 워킹 디렉터리에서 파일을 삭제하고 git status 명령으로 상태를 확인하면 Git은 현재 “Changes not staged for commit” 즉, Unstaged 상태라고 표시해준다.$ rm grit.gemspec$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed) (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory) deleted: grit.gemspecno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)그리고 다시 git rm 명령을 실행하면 삭제한 파일은 Staged 상태가 된다.$ git rm grit.gemspecrm &#39;grit.gemspec&#39;$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage) deleted: grit.gemspec커밋하면 파일은 삭제되고 Git은 이 파일을 더는 추적하지 않는다. 이미 파일을 수정했거나, 수정한 파일을 Index(Staging Area)에 추가했다면 -f 옵션을 주어 강제로 삭제해야 한다. 이 점은 실수로 데이터를 삭제하지 못하도록 하는 안전장치다. 커밋하지 않고 수정한 데이터는 Git으로 복구할 수 없기 때문이다.또 Staging Area에서만 제거하고 워킹 디렉터리에 있는 파일은 지우지 않고 남겨둘 수 있다. 다시 말해서 하드디스크에 있는 파일은 그대로 두고 Git만 추적하지 않게 된다. 이것은 .gitignore 파일에 추가하는 것을 빼먹었거나, 대용량 로그 파일이나 컴파일된 파일인 .a 파일 같은 것을 실수로 추가했을 때 아주 유용하다. --cached 옵션을 사용하여 명령을 실행한다.$ git rm --cached README여러 개의 파일이나 디렉터리를 한꺼번에 삭제할 수도 있다. 아래와 같이 git rm 명령에 file-glob 패턴을 사용한다.$ git rm log/\\*.log* 앞에 \\를 사용한 것을 기억하자. 파일명 확장 기능은 Shell에만 있는 것이 아니라 Git 자체에도 있으므로 필요하다. 이 명령은 log/ 디렉터리에 있는 모든 .log 파일을 삭제한다.아래의 예제처럼 할 수도 있다.$ git rm \\*~이 명령은 ~로 끝나는 파일을 모두 삭제한다.※ ~로 끝나는 파일은 Emacs나 vi 같은 텍스트 편집기가 임시로 만들어내는 파일이다." }, { "title": "[Git] 변경사항 커밋하기", "url": "/posts/Committing-Your-Changes/", "categories": "Git, Getting Started", "tags": "git commit, Git, VCS, DVCS, Github", "date": "2022-01-12 17:55:00 +0900", "snippet": "수정한 내용을 커밋하기 위해 Staging Area에 파일을 정리했다. Unstaged 상태의 파일은 커밋되지 않는다는 것을 기억해야 한다. Git은 파일을 생성하거나 수정하고 나서 git add 명령으로 추가하지 않으면 커밋하지 않는다. 그 파일은 여전히 Modified 상태로 남아 있을 것이다. 커밋하기 전에 git status 명령으로 모든 것이 Staged 상태인지 확인할 수 있다. 그 후에 git commit을 실행하여 커밋한다.$ git commitGit 설정에서 지정된 편집기가 실행되고, 아래와 같은 텍스트가 자동으로 포함된다(아래 예제는 Vim 편집기의 화면이다. 이 편집기는 Shell의 $EDITOR 환경변수에 등록된 편집기이고 보통은 Vim이나 Emacs를 사용한다. 또 앞에서 설명했듯이 git config --global core.editor 명령으로 어떤 편집기를 사용할지 설정할 수 있다)편집기는 아래와 같은 내용을 표시한다(아래 예제는 vim 편집기).# Please enter the commit message for your changes. Lines starting# with &#39;#&#39; will be ignored, and an empty message aborts the commit.# On branch master# Changes to be committed:#new file: README#modified: CONTRIBUTING.md#~~~&quot;.git/COMMIT_EDITMSG&quot; 9L, 283c자동으로 생성되는 커밋 메시지의 첫 라인은 비어 있고 둘째 라인부터 git status 명령의 결과가 채워진다. 커밋한 내용을 쉽게 기억할 수 있도록 이 메시지를 포함할 수도 있고, 메시지를 전부 지우고 새로 작성할 수도 있다(정확히 무엇을 수정했는지 보여줄 수 있는데, git commit -v 옵션을 추가하면 편집기에 diff 메시지도 추가된다). 내용을 저장하고 편집기를 종료하면 Git은 입력된 내용(#으로 시작하는 내용 제외)으로 새 커밋을 하나 완성한다.메시지를 인라인으로 첨부할 수도 있다. commit 명령을 실행할 때 아래와 같이 -m 옵션을 사용한다.$ git commit -m &quot;Story 182: Fix benchmarks for speed&quot;[master 463dc4f] Story 182: Fix benchmarks for speed 2 files changed, 2 insertions(+) create mode 100644 README이렇게 첫 번째 커밋을 작성해보았다. commit 명령은 몇 가지 정보를 출력하는데 위 예제는 (master) 브랜치에 커밋했고 체크섬은 “463dc4f”라고 알려준다. 그리고 수정한 파일이 몇 개이고 삭제됐거나 추가된 라인이 몇 라인인지 알려준다.Git은 Staging Area에 속한 스냅샷을 커밋한다는 것을 기억해야 한다. 수정은 했지만, 아직 Staging Area에 넣지 않은 것은 다음에 커밋할 수 있다. 커밋할 때마다 프로젝트의 스냅샷을 기록하기 때문에 나중에 스냅샷끼리 비교하거나 예전 스냅샷으로 되돌릴 수 있다.Staging Area 생략하기Staging Area는 커밋할 파일을 정리한다는 점에서 매우 유용하지만 복잡하기만 하고 필요하지 않을 때도 있다. 아주 쉽게 Staging Area를 생략할 수 있다. git commit 명령을 실행할 때 -a 옵션을 추가하면 Git은 Tracked 상태의 파일을 자동으로 Staging Area에 넣는다. 그래서 git add 명령을 실행하는 수고를 덜 수 있다.$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed) (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.mdno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)$ git commit -a -m &#39;added new benchmarks&#39;[master 463dc4f] Story 182: Fix benchmarks for speed 1 files changed, 5 insertions(+), 0 deletions(-)이 예제에서는 커밋하기 전에 git add 명령으로 “CONTRIBUTING.md” 파일을 Staging Area에 추가하지 않았다는 점을 눈여겨보자." }, { "title": "[Git] Staged와 Unstaged 상태의 변경 내용 보기", "url": "/posts/Viewing-Your-Staged-and-Unstaged-Changes/", "categories": "Git, Getting Started", "tags": "Git Staged/Unstaged, Commit History, Git, VCS, DVCS, Github", "date": "2022-01-12 17:43:00 +0900", "snippet": "단순히 파일이 변경됐다는 사실이 아니라 어떤 내용이 변경됐는지 살펴보려면 git status 명령이 아니라 git diff 명령을 사용해야 한다. 보통 우리는 “수정했지만 아직 Staged 파일이 아닌 것”과 “어떤 파일이 Staged 상태인지”가 궁금하기 때문에 git status 명령으로도 충분했다. 하지만 파일의 내용이 어떻게 변경됐는지는 알 수 없기 때문에 git diff 명령을 사용하는데, Patch처럼 어떤 라인을 추가했고 삭제했는지가 궁금할 때 사용한다. git diff는 나중에 더 자세하게 다룬다.README 파일 수정 후 git add 명령을 통해 Staged 상태로 만들고 CONTRIBUTING.md 파일은 수정만 해둔다. 이 상태에서 git status 명령을 실행하면 아래와 같은 메시지를 볼 수 있다.$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage) new file: READMEChanges not staged for commit: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed) (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.mdgit diff 명령을 실행하면 수정했지만 아직 staged 상태가 아닌 파일을 비교해 볼 수 있다.$ git diffdiff --git a/CONTRIBUTING.md b/CONTRIBUTING.mdindex 8ebb991..643e24f 100644--- a/CONTRIBUTING.md+++ b/CONTRIBUTING.md@@ -65,7 +65,8 @@ branch directly, things can get messy. Please include a nice description of your changes when you submit your PR; if we have to read the whole diff to figure out why you&#39;re contributing in the first place, you&#39;re less likely to get feedback and have your change-merged in.+merged in. Also, split your changes into comprehensive chunks if your patch is+longer than a dozen lines. If you are starting to work on a particular area, feel free to submit a PR that highlights your work in progress (and note in the PR title that it&#39;s이 명령은 워킹 디렉터리에 있는 것과 Staging Area에 있는 것을 비교한다. 그래서 수정하고 아직 Stage하지 않은 것을 보여준다.만약 커밋하려고 Staging Area에 넣은 파일의 변경 부분을 보고 싶으면 git diff --staged 옵션을 사용한다. 이 명령은 저장소에 커밋한 것과 Staging Area에 있는 것을 비교한다.$ git diff --stageddiff --git a/README b/READMEnew file mode 100644index 0000000..03902a1--- /dev/null+++ b/README@@ -0,0 +1,4 @@+My Project꼭 잊지 말아야 할 것이 있는데, git diff 명령은 마지막으로 커밋한 후에 수정한 것들 전부를 보여주지 않는다. git diff는 Unstaged 상태인 것들만 보여준다. 이 부분이 조금 헷갈릴 수 있다. 수정한 파일을 모두 Staging Area에 넣었다면 git diff 명령은 아무것도 출력하지 않는다. Staged된 파일의 수정내용을 확인하려면 --staged 옵션을 사용하자.CONTRIBUTING.md 파일을 Stage한 후에 다시 수정해도 git diff 명령을 사용할 수 있다. 이때는 Staged 상태인 것과 Unstaged 상태인 것을 비교한다.$ git add CONTRIBUTING.md$ echo &#39;# test line&#39; &amp;gt;&amp;gt; CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage) new file: CONTRIBUTING.mdChanges not staged for commit: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed) (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md$ git diffdiff --git a/CONTRIBUTING.md b/CONTRIBUTING.mdindex 8ebb991..643e24f 100644--- a/CONTRIBUTING.md+++ b/CONTRIBUTING.md@@ -119,3 +119,4 @@ at the ## Starter Projects See our projects list at ....................+# test lineStaged 상태인 파일은 git diff --cached 옵션으로 확인한다. --staged와 --cached는 같은 옵션이다.$ git diff --cacheddiff --git a/CONTRIBUTING.md b/CONTRIBUTING.mdindex 8ebb991..643e24f 100644--- a/CONTRIBUTING.md+++ b/CONTRIBUTING.md@@ -65,7 +65,8 @@ branch directly, things can get messy. Please include a nice description of your changes when you submit your PR; if we have to read the whole diff to figure out why you&#39;re contributing in the first place, you&#39;re less likely to get feedback and have your change-merged in.+merged in. Also, split your changes into comprehensive chunks if your patch is+longer than a dozen lines. If you are starting to work on a particular area, feel free to submit a PR that highlights your work in progress (and note in the PR title that it&#39;s앞으로 계속 git diff 명령을 여기저기서 사용할 것이다. 즐겨쓰거나 결과를 보기 좋게 꾸며주는 Diff 도구가 있다면 그걸 사용할 수도 있다. git diff 대신 git difftool 명령을 사용해 emerge, vimdiff 같은 도구로 비교할 수 있다. 상용 제품도 사용할 수 있다. git difftool --tool--help라는 명령은 사용 가능한 도구를 보여준다." }, { "title": "[Git] 특정 파일 혹은 폴더 무시하기 (.gitignore)", "url": "/posts/Ignoring-Files/", "categories": "Git, Getting Started", "tags": ".gitignore, Glob, Git, VCS, DVCS, Github", "date": "2022-01-12 17:37:00 +0900", "snippet": "어떤 파일은 Git이 관리할 필요가 없다. 보통 로그 파일이나 빌드 시스템이 자동으로 생성한 파일이 그렇다. 그런 파일을 무시하려면 .gitignore 파일을 생성하고 그 안에 무시할 파일 패턴을 입력하면 된다. 아래는 .gitignore 파일의 예이다.$ cat .gitignore*.[oa]*~첫 번째 라인은 확장자가 “.o”나 “.a”인 파일을 Git이 무시하라는 것이고 둘째 라인은 ~로 끝나는 모든 파일을 무시하라는 것이다. “.o”와 “.a”는 각각 빌드 시스템이 만들어내는 오브젝트와 아카이브 파일이고 ~로 끝나는 파일은 Emacs나 vi 같은 텍스트 편집기가 임시로 만들어내는 파일이다. 또 log, tmp, pid 같은 디렉터리나, 자동으로 생성하는 문서 같은 것들도 추가할 수 있다. .gitignore 파일은 보통 처음에 만들어 두는 것이 편리하다. 그래서 Git 저장소에 커밋하고 싶지 않은 파일을 실수로 커밋하는 일을 방지할 수 있다..gitignore 파일에 입력하는 패턴 규칙 아무것도 없는 라인이나, #으로 시작하는 라인은 무시한다. 표준 Glob 패턴을 사용한다. /로 시작하면 하위 디렉터리에 적용되지 않는다(recursivity). 디렉터리는 끝에 슬래시 /를 사용하는 것으로 표현한다. !로 시작하는 패턴의 파일은 무시하지 않는다.Glob 패턴은 정규표현식을 단순하게 만든 것으로 생각하면 되고 보통 Shell에서 많이 사용한다. *: 문자가 하나도 없거나 하나 이상을 의미 [abc]: 는 중괄호 안에 있는 문자 중 하나를 의미 (이 경우 a 혹은 b 혹은 c) ?: 문자 하나를 의미 [0-9]: 캐릭터 사이에 있는 문자 하나를 의미 * 두 개: 디렉터리 안의 디렉터리까지 의미ex) a/**/z 패턴은 a/z, a/b/z, a/b/c/z 와 같이 a와 z 사이의 모든 디렉터리 및 파일을 의미함아래는 .gitignore 파일의 예이다.# 확장자가 .a인 파일 무시*.a# 윗 라인에서 확장자가 .a인 파일은 무시하게 했지만 lib.a는 무시하지 않음!lib.a# 현재 디렉터리에 있는 TODO 파일은 무시하고 subdir/TODO 처럼# 하위 디렉터리에 있는 파일은 무시하지 않음/TODO# build/ 디렉터리에 있는 모든 파일 무시build/# doc/notes.txt 파일은 무시하고 doc/server/arch.txt 파일은 무시하지 않음doc/*.txt# doc 디렉터리 아래의 모든 .pdf 파일을 무시doc/**/*.pdfReferences 다양한 .gitignore 파일 템플릿" }, { "title": "[Git] 수정하고 저장소에 저장하기", "url": "/posts/Recording-Changes-to-the-Repository/", "categories": "Git, Getting Started", "tags": "Git Repository, git commit, Git, VCS, DVCS, Github", "date": "2022-01-12 17:24:00 +0900", "snippet": "Git 저장소를 하나 만들었고 Working Directory에 Checkout도 했다. 이제는 파일을 수정하고 파일의 스냅샷을 커밋해 보자. 파일을 수정하다가 저장하고 싶으면 스냅샷을 커밋한다.워킹 디렉터리의 모든 파일은 크게 Tracked(관리대상)와 Untracked(관리대상 아님)로 나눈다. Tracked 파일은 또 Unmodified(수정하지 않음)와 Modified(수정함) 그리고 Staged(커밋으로 저장소에 기록할) 상태 중 하나이다.Working Directory’s file states Tracked UntrackedTracked file’s states Unmodified Modified StagedUntracked 파일은 워킹 디렉터리에 있는 파일 중 스냅샷에도 Staging Area에도 포함되지 않은 파일이다.처음 저장소를 Clone하면 모든 파일은 Tracked이면서 Untracked 상태이다. 파일을 Checkout하고 나서 아무것도 수정하지 않았기 때문에 그렇다.마지막 커밋 이후 아직 아무것도 수정하지 않은 상태에서 어떤 파일을 수정하면 Git은 그 파일을 Modified 상태로 인식한다. 실제로 커밋을 하기 위해서는 이 수정한 파일을 Staged 상태로 만들고, Staged 상태의 파일을 커밋한다. 이런 라이프사이클을 계속 반복한다.The lifecycle of the status of your files파일의 상태 확인하기파일의 상태를 확인하려면 보통 git status 명령을 사용한다. Clone한 후에 바로 이 명령을 실행하면 다음과 같은 메시지를 볼 수 있다.$ git statusOn Branch masternothing to commit, working director yclean위의 내용은 파일을 하나도 수정하지 않았다는 것을 말해준다. Tracked나 Modified 상태인 파일이 없다는 것이다. Untracked 파일은 아직 없어서 목록에 나타나지 않는다. 그리고 현재 작업중인 브랜치를 알려주며 서버의 같은 브랜치로부터 진행된 작업이 없는 것을 나타낸다. 기본 브랜치가 master이기 때문에 현재 브랜치 이름이 “master”로 나타난다.README 파일 만들기$ echo &#39;My Project&#39; &amp;gt; README$ git statusOn branch masterUntracked files: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to include in what will be committed) READMEnothing added to commit but untracked files present (use &quot;git add&quot; to track)README 파일은 새로 만든 파일이기 때문에 git status를 실행하면 “Untracked files”에 들어 있다. 이것은 README 파일이 Untracked 상태라는 것을 말한다. Git은 Untracked 파일을 아직 스냅샷(커밋)에 넣어지지 않은 파일이라고 본다. 파일이 Tracked 상태가 되기 전까지는 Git은 절대 그 파일을 커밋하지 않는다. 그래서 업무중 실수로 생성하는 바이너리 파일 같은 것을 커밋하는 실수는 하지 않게 된다.파일을 새로 추적하기git add 명령으로 파일을 새로 추적할 수 있다. 아래 명령을 실행하면 Git은 README 파일을 추적한다.$ git add READMEgit status 명령을 다시 실행하면 README 파일이 Tracked 상태이면서 커밋에 추가될 Staged 상태라는 것을 확인할 수 있다.$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage) new file: README“Changes to be committed”에 들어 있는 파일은 Staged 상태라는 것을 의미한다. 커밋하면 git add를 실행한 시점의 파일이 커밋되어 저장소 히스토리에 남는다. 앞에서 git init 명령을 실행한 후 그 다음 git add &amp;lt;file&amp;gt; 명령을 실행했던 걸 기억할 것이다. 이 명령을 통해 디렉터리에 있는 파일을 추적하고 관리하도록 한다. git add **명령은 파일 또는 디렉터리의 경로를 아규먼트로 받는다. 디렉터리면 아래에 있는 모든 파일들까지 재귀적으로 추가한다.Modified 상태의 파일을 Stage하기이미 Tracked 상태인 파일을 수정하는 방법을 알아보자. “CONTRIBUTING.md”라는 파일을 수정하고 나서 git status 명령을 다시 실행하면 결과는 아래와 같다.$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage) new file: READMEChanges not staged for commit: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed) (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md이 “CONTRIBUTING.md” 파일은 “Changes not staged for commit”에 있다. 이것은 수정한 파일이 Tracked 상태이지만 아직 Staged 상태는 아니라는 것이다. Staged 상태로 만들려면 git add 명령을 실행해야 한다. git add 명령은 파일을 새로 추적할 때도 사용하고 수정한 파일을 Staged 상태로 만들때도 사용한다. 또한, Merge할 때 충돌 난 상태의 파일을 Resolve 상태로 만들 때도 사용한다. add의 의미는 프로젝트에 파일을 추가한다기보다는 다음 커밋에 추가한다고 받아들이는 게 좋다. git add 명령을 실행하여 “CONTRIBUTING.md” 파일을 Staged 상태로 만들고 git status 명령으로 결과를 확인해보자.$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage) new file: README modified: CONTRIBUTING.md두 파일 모두 Staged 상태이므로 다음 커밋에 포함될 것이다. 하지만 아직 더 수정해야 한다는 것을 알게 되어 바로 커밋하지 못하는 상황이 되었다고 생각해보자. 이 상황에서 CONTIBUTING.md 파일을 열고 수정한다. 이제 커밋할 준비가 다 됐다고 생각할 테지만, Git은 그렇지 않다. git status 명령으로 파일의 상태를 다시 확인해 보자.$ vim CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage) new file: README modified: CONTRIBUTING.mdChanges not staged for commit: (use &quot;git add &amp;lt;file&amp;gt;...&quot; to update what will be committed) (use &quot;git checkout -- &amp;lt;file&amp;gt;...&quot; to discard changes in working directory) modified: CONTRIBUTING.md어라? CONTRIBUTING.md가 Staged 상태이면서 동시에 Unstaged 상태로 나온다. 어떻게 이런 일이 가능할까? git add 명령을 실행하면 Git은 파일을 바로 Staged 상태로 만든다. 지금 이 시점에서 커밋을 하면 git commit 명령을 실행하는 시점의 버전이 커밋되는 것이 아니라 마지막으로 git add 명령을 실행했을 때의 버전이 커밋된다. 그러니까 git add 명령을 실행한 후에 또 파일을 수정하면 git add 명령을 다시 실행해서 최신 버전을 Staged 상태로 만들어야 한다.$ git add CONTRIBUTING.md$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage) new file: README modified: CONTRIBUTING.md파일 상태를 짤막하게 확인하기git status 명령으로 확인할 수 있는 내용이 좀 많아 보일 수 있다. 좀 더 간단하게 변경 내용을 보여주는 옵션이 있다. git status -s 또는 git status --short 옵션을 주면 현재 변경한 상태를 짤막하게 보여준다.$ git status -s M READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt {공백}M: 파일 수정 후 Staged 상태로 만들지 않은 파일 M{공백}: 파일 수정 후 Staged 상태로 만든 파일 MM: 파일 수정 후 Staged 상태로 만든 후 또 다시 수정하여 Staged이면서 Unstaged 상태인 파일 A: 새로 생성한 파일 ??: 아직 추적하지 않는 새 파일" }, { "title": "[Git] 저장소 만들기", "url": "/posts/Getting-a-Git-Repository/", "categories": "Git, Getting Started", "tags": "Repository, Git Clone, Git, VCS, DVCS, Github", "date": "2022-01-12 17:20:00 +0900", "snippet": "Git 저장소를 만드는 방법은 두 가지다. 기존 프로젝트를 Git 저장소로 만들기 다른 서버에 있는 저장소를 Clone하기기존 프로젝트를 Git 저장소로 만들기해당 프로젝트의 디렉터리로 이동 후 아래 명령 실행.$ git init이 명령은 .git이라는 하위 디렉터리를 만든다. .git 디렉터리에는 저장소에 필요한 뼈대 파일(skeleton)이 들어 있다. 이 명령으로만으로는 아직 프로젝트의 어떤 파일도 관리하지 않는다. Git이 파일을 관리하게 하려면 저장소에 파일을 추가하고 커밋해야 한다.git add 명령으로 파일을 추가하고 git commit 명령으로 커밋한다.$ git add *.c$ git add LICENSE$ git commit -m &quot;initial project version&quot;다른 서버에 있는 저장소를 Clone하기다른 프로젝트에 참여하거나(contribute) Git 저장소를 복사하고 싶을 때 git clone 명령을 사용한다. git clone을 실행하면 프로젝트 히스토리를 전부 받아온다. 서버의 디스크가 망가져도 클라이언트 저장소 중에서 아무거나 하나 가져다가 복구하면 문제 없다. 서버에만 적용했던 설정은 복구하지 못하지만 모든 데이터는 복구된다.$ git clone https://github.com/facebook/react.git이 명령은 “react”라는 디렉터리를 만들고 그 안에 .git 디렉터리를 만든다. 그리고 저장소의 데이터를 모두 가져와서 자동으로 가장 최신 버전을 Checkout 해 놓는다. react 디렉터리로 이동하면 Checkout으로 생성한 파일을 볼 수 있고, 당장 하고자 하는 일을 시작할 수 있다.아래와 같은 명령을 사용하여 저장소를 Clone하면 “react”가 아니라 다른 디렉터리 이름으로 Clone 할 수 있다.$ git clone https://github.com/facebook/react.git myReactGit은 다양한 프로토콜을 지원한다. 이제까지는 https:// 프로토콜을 사용했지만, git:// 를 사용할 수도 있고 user@server:path/to/repo.git 처럼 SSH 프로토콜을 사용할 수도 있다." }, { "title": "[Git] 최초 설정", "url": "/posts/Git-Settings/", "categories": "Git, Getting Started", "tags": "Git Settings, Git, VCS, DVCS, Github", "date": "2022-01-12 17:11:00 +0900", "snippet": "git config라는 도구로 설정 내용을 확인하고 변경할 수 있다. Git은 이 설정에 따라 동작한다.※ 파일(fedora 혹은 ubuntu(debian 류) 등 리눅스 환경에서의 경로) linux: /etc/gitconfigWindows ($HOME 디렉토리에서 .gitconfig 파일 검색)C:\\Users$USER.gitconfig 시스템의 모든 사용자와 모든 저장소에 적용되는 설정이다.git config --system 옵션으로 이 파일을 읽고 쓸 수 있다. linux: ~/.gitconfig, ~/.config/git/config특정 사용자에게만 적용되는 설정이다.git config --global 옵션으로 이 파일을 읽고 쓸 수 있다. .git/configGit 디렉터리($프로젝트/.git/)에 있고 특정 저장소(혹은 현재 작업 중인 프로젝트)에만 적용된다.각 설정은 역순으로 우선시 된다..git/config &amp;gt; ~/.gitconfig, ~/.config/git/config &amp;gt; /etc/gitconifg사용자 정보Git을 설치하고 나서 가장 먼저 해야 할 일은 사용자 이름과 이메일 주소를 설정하는 것이다. Git은 커밋할 때마다 이 정보를 사용한다. 한번 커밋한 후에는 정보를 변경할 수 없다.$ git config --global user.name &quot;SunhyeokChoe&quot;$ git config --global user.email &quot;hackerwreckers@gmail.com&quot;–global 옵션으로 설정하는 것은 딱 한 번만 하면 된다. 해당 시스템에서 해당 사용자가 사용할 때에는 이 정보를 사용한다. 만약 프로젝트마다 다른 이름과 이메일 주소를 사용하고 싶으면 –global 옵션을 빼고 명령을 실행한다.설정 확인git config --list 명령을 실행하면 설정한 모든 값을 보여준다.Git은 같은 키를 여러 파일(/etc/gitconfig와 ~/.gitconfig 같은)에서 읽기 때문에 같은 키가 여러 개 있을 수도 있다. 그러면 Git은 나중 값을 사용한다.$ git config &amp;lt;key&amp;gt; 명령으로 Git의 특정 key에 대해 어떤 값을 사용하는지 확인할 수 있다.ex) $ git config user.name" }, { "title": "[Git] 시작하기", "url": "/posts/Getting-Started/", "categories": "Git, Getting Started", "tags": "Git, VCS, DVCS, Github", "date": "2022-01-12 17:00:00 +0900", "snippet": "Pro Git 2nd본 Git 게시글은 도서 “Pro Git 2nd 스캇 샤콘, 벤 스트라웁 공저 / 박창우, 이성환, 최용재 공역“을 참고하여 작성했습니다. 내용은 거의 대부분 도서와 동일하나 Git 2.23.0 이전 버전의 명령어를 Git에서 새로 제안하는 명령어로 바꿨고, 중간중간 추가 내용이 있으면 좋겠다 싶은 곳에는 짧게 제 의견을 추가했습니다.※ 이미지 내 글씨가 잘 보이지 않을 경우 좌측 하단 반달 모양의 버튼을 눌러 테마를 밝은색으로 바꿔주세요.Git이란?Git은 버전 관리 시스템(VCS, Version Control System)의 한 종류이며, 기존 중앙집중식 버전 관리 시스템(CVCS, Central Version Control System) 방식을 채택한 프로그램들 보다 조금 더 발전한 분산 버전 관리 시스템(DVCS, Distributed Version Control System)을 채택했으며, BitKeeper의 단점을 보완해 출시했다.Git의 장점 빠른 속도 단순한 구조 비선형적인 개발(수천 개의 동시다발적인 브랜치) 완벽한 분산 리눅스 커널 같은 대형 프로젝트에서도 유용할 것(속도나 데이터 크기 면에서)파일의 세 가지 상태Git은 파일을 Committed, Modified, Staged 세 가지 상태로 관리한다. Committed: 데이터가 로컬 데이터베이스에 저장된 상태 Modified: 수정한 파일을 아직 로컬 데이터베이스에 커밋하지 않은 상태 Staged: 수정한 파일을 곧 커밋할 것이라고 표시한 상태위 세 가지 상태는 Git 프로젝트의 세 단계와 연결된다.The three states Working Directory: 프로젝트의 특정 버전을 Checkout 한 것.git Directory 안에 압축된 데이터베이스에서 파일을 가져와서 Working Directory를 생성함 Staging Area: .git Directory 내부에 존재하며 단순한 파일이고, 곧 커밋할 파일에 대한 정보를 저장함종종 “index”라고 불리기도 하지만, Staging Area라는 명칭이 표준이 되어가고 있음 .git Directory: 프로젝트의 메타데이터와 객체 데이터베이스를 저장하는 곳" }, { "title": "프론트엔드 웹 서비스에서 우아하게 비동기 처리하기", "url": "/posts/Asynchronous-handling-in-front-end-web-services/", "categories": "React, SLASH21 - 토스개발자컨퍼런스", "tags": "React Suspense, Data Fetching", "date": "2021-10-05 11:50:00 +0900", "snippet": "API를 호출하거나 네이티브 앱과 통신할 때 프론트엔드 웹 서비스에서는 반드시 비동기 작업이 일어나게 됩니다.일상처럼 다루고 있지만 정작 UI에서 다루기 힘든 비동기 프로그래밍.React Suspense를 이용하여 우아하게 처리하는 이론과 실전 적용법을 공유합니다.토스의 프로젝트 구조 토스 앱 내에서 WebView를 이용해 iOS/Android 공통의 웹 서비스를 개발하고 있음 60개 이상의 크고 작은 활성 서비스가 웹 기술을 이용하여 개발되고 있음 그 외의 홈페이지나 토스증권, 토스페이먼츠, 토스인슈어런스 등의 서비스는 100% 웹 기술을 이용해서 개발되고 있음 토스 앱 안에서는 주식 탭, 혜택 탭 등이 대표적으로 웹 서비스를 이용해서 개발된 서비스임 이렇게 많은 서비스들은 마이크로프론트엔드 아키텍처(모노레포)를 이용해서 같은 레포지토리 안에서 독립적으로 개발/배포되고 있음 모든 서비스들은 React, TypeScript, Next.js 기술 스택을 공유하고 있고, 구체적인 로직만 다르게 가져가고 있음웹 서비스, UI 개발에서 가장 다루기 어려운 부분은?웹에서는 10여년 전 JQuery를 활용해서 명령형으로 프로그래밍을 하다가 React/Vue.js와 같이 선언적인 프로그래밍을 지원하는 프레임워크들이 나오면서 각각의 개발자가 신경써야 하는 부분들이 많이 줄었다.그럼에도 아직까지 다루기 어려운 영역을 하나 꼽아보자면 비동기 프로그래밍을 꼽을 수 있다. 비동기 프로그래밍은 ‘순서가 보장되지 않는 상황’으로 요약할 수 있다.비동기 프로그래밍은 끊기지 않는 60프레임의 좋은 사용자 경험을 위해서는 필수이고, JavaScript에서는 Callback, Promise, Observable(using RxJs)과 같이 다양한 도구를 이용해서 비동기적인 상황을 다루고 있다.그럼에도 불구하고 여전히 다루기가 어렵다.이유는 뭘까?좋은 코드에 대해 돌아보자이 코드의 문제점은 무엇일까?function getBazFromX(x) { if (x === undefined) { return undefined; } if (x.foo === undefined) { return undefined; } if (x.foo.bar === undefined) { return undefined; } return x.foo.bar.baz;} 하는 일은 단순하지만 코드가 너무 복잡하다. 각 프로퍼티에 접근하는 핵심 기능이 코드로 잘 드러나지 않는다.이 함수가 하는 일을 요약한다면, x.foo.bar.baz 라고 하는 프로퍼티에 안전하게 접근하는 일인데, 함수가 하는 일이 명확하게 드러난다기 보다는 ‘x가 없는지 검사한다.’, ‘x.foo가 없는지 검사한다.’, ‘x.foo.bar’가 없는지 검사한다’와 같이 명령어의 노이즈가 많아 함수가 어떤 역할을 하는지 명확하게 드러나지 않는다.이를 해결하기 위해 최근 ECMAScript에 추가된 Optional Chaining 문법을 활용한 동일한 함수를 살펴보자.function getBazFromX(x) { return x?.foo?.bar?.baz;}일전의 비효율적인 함수와 다른점이 무엇일까? ‘성공한 경우’를 생각하는 x.foo.bar.baz와 문법적 차이가 크지 않다. 함수의 역할을 한눈에 파악할 수 있다.우선 함수가 하는 일을 흐리게 만들던 if문들이 사라져 코드가 간결해진 덕분에 어떤 역할을 하는 함수인지 한눈에 확인할 수 있다.또한, 잘 살펴보면 Nullable이 아닐 때, 즉 성공할 때 접근하는 모습을 나타내는 x.foo.bar.baz라고 하는 표현식과 모양이 큰 차이가 없는 것도 확인할 수 있다.같은 역할을 하는 식이 비슷하게 표현된다는 것은 코드에 있어서 좋은 징조 중 하나이다.더 복잡한 예제를 살펴보자.이 코드의 문제점은 무엇일까?(JavaScript에 Promise가 없던 시절 비동기를 처리하기 위해 callback을 사용했던 코드)function fetchAccounts(callback) { fetchUserEntity((err, user) =&amp;gt; { if (err != null) { callback(err, null); return; } fetch(UserAccounts(user.no, (err, accounts) =&amp;gt; { if (err != null) { callback(err, null); return; { callback(null, accounts); }); });}fetchUserEntity를 호출해서 그 결과를 Callback으로 받는데, 에러가 있으면 에러를 Emit한다.그리고 그 결과값을 이용해서 사용자의 계좌 목록을 가져오는데, 마찬가지로 에러가 있으면 에러를 Emit하고, 그렇지 않을 경우 실제값을 Emit 한다. ‘성공하는 경우’와 ‘실패하는 경우’가 섞여서 처리된다. 코드를 작성하는 입장에서 매번 에러 유무를 확인해야 한다.이 함수를 요약하자면, user를 가져오고, 그 정보를 바탕으로 accounts를 가져오고, 그 값을 반환하는 역할이다. 중간에 ‘실패하는 경우’에 대한 처리가 섞여 있어서 함수가 하는 진짜 역할이 가려졌다(노이즈).또한, 코드를 작성하는 입장에서 매번 비동기 호출을 할 때마다 에러 처리를 해줘야 한다는 점이 불편한 점 중 하나라고 할 수 있다.이를 해결하기 위해 async-await 문법을 활용해보자.async function fetchAccounts() { const user = await fetchUserEntity(); const accounts = await fetchUserAccounts(user.no); return accounts;}왜 이 코드를 좋은 코드라고 말할 수 있을까? ‘성공하는 경우’만 다루고, ‘실패하는 경우’는 catch 절에서 분리해서 처리한다. ‘실패하는 경우’에 대한 처리를 외부에 위임할 수 있다.비동기 요청을 통해 ‘성공하는 경우’들만 모아서 살펴볼 수 있기에 함수가 하는 역할이 명확히 드러난다. 동기적인 코드가 외견적으로는 큰 차이가 없다.또한, 별도로 에러를 처리하는 부분이 없고 모든 에러 처리는 외부에 위임된다라고 하는 점도 좋은 코드임을 드러내는 부분 중 하나이다.좋은 코드의 특징 성공, 실패의 경우를 분리해 처리할 수 있다. 비즈니스 로직을 한눈에 파악할 수 있다.함수에는 성공하는 경우들만 적혀 있으니 읽기도 쉽고, 함수의 책임이 명확히 드러난다.어려운 코드의 특징 실패, 성공의 경우가 서로 섞여 처리된다. 비즈니스 로직을 파악하기 어렵다.‘실패하는 경우’와 ‘성공하는 경우’가 섞여서 처리된다는 점이 함수의 책임을 알아보기 어렵게 한다. 덕분에 함수의 크기가 커지고, 하는 역할이 명시적으로 드러나지 못한다.프론트엔드 웹 서비스에서 비동기 처리는 지금까지 어땠는가?우리는 보통 API 호출과 같은 상황을 처리할 때 어떻게 처리했을까?in ReactAPI 호출const { data, error } = useAsyncValue(() ⇒ { return fetchSomething();});SWR이나 react-query와 같은 라이브러리를 많이 활용했다.Promise를 반환하는 함수를 React Hook의 인자로 넘기고, Promise의 상태 변화에 따라 Hook이 반환하는 data, error의 값을 적절히 채워주는 것이다.그리고 아래와 같이 컴포넌트를 작성하고는 했다.컴포넌트 처리function Profile() { const foo = useAsyncValue(() =&amp;gt; { return fetchFoo(); }); if (foo.error) return &amp;lt;div&amp;gt;로딩에 실패했습니다.&amp;lt;/div&amp;gt; if (!foo.data) return &amp;lt;div&amp;gt;로딩 중입니다.&amp;lt;/div&amp;gt; return &amp;lt;div&amp;gt;{foo.data.name}님 안녕하세요!&amp;lt;/div&amp;gt;}이 함수를 살펴보면, 비동기인 foo를 가져오는데, foo가 에러이면 실패 메시지를 보여주고, foo가 없으면 로딩중이라고 보여주고, foo가 있으면 안녕하세요 라고 하는 메시지를 보여주는 식이다.위 코드는 다음과 같은 문제점이 있다. ‘성공하는 경우’와 ‘실패하는 경우’가 섞여서 처리된다. ‘실패하는 경우’에 대한 처리를 위부에 위임하기 어렵다.이러한 문제는 여러 개의 비동기 작업이 동시에 실행될 때 심각한 일이 발생한다!방금 전에 봤던 callback 코드와 비슷하게 코드가 점점 읽기 어려워지는 것이다.한번 코드를 살펴보자. (foo와 bar 값을 비동기로 가져오는 함수)/* 비동기 코드 지옥 */function Profile() { const foo = useAsyncValue(() =&amp;gt; { return fetchFoo(); }); const bar = useAsyncValue(() =&amp;gt; { if (foo.error || !foo.data) { return undefined; } return fetchBar(foo.data); }); if (foo.error || bar.error) return &amp;lt;div&amp;gt;로딩에 실패했습니다.&amp;lt;/div&amp;gt; if (!foo.data || !bar.data) return &amp;lt;div&amp;gt;로딩 중입니다.&amp;lt;/div&amp;gt; return /* foo와 bar로 적합한 처리하기 */}bar를 가져오기 위해서는 foo가 있어야 한다.결국 bar는 foo가 로드될 때까지 기다리고, if문은 복잡해지고… 그냥 복잡하다.보통은 하나의 비동기 작업은 (로딩중 / 에러 / 완료됨) 3가지의 상태를 가지고 있다.Three states of async job만약에 2개의 비동기 작업이 있다면, 3^2=9가지의 상태를 가질 수 있다는 것을 생각할 수 있다.그렇다면 비동기 호출이 3개, 4개가 된다면 더욱 복잡해질 것이다.React의 비동기 처리는 어렵다는 내용을 간략화 하자면 성공하는 경우에만 집중해 컴포넌트를 구성하기 어렵다. 2개 이상의 비동기 로직이 개입할 때, 비즈니스 로직을 파악하기 점점 어려워진다.React에서 지금까지 살펴보았던 Hook이나 State를 사용하는 방식으로는 이렇게 간단히 비동기 처리를 할 수가 없다.다행히도 이 문제를 우아하게 해결해주는 도구가 있다!React 팀이 제안하는 “React Suspense for Data Fetching”한국어로 번역하자면 “데이터를 가져오기 위한 Suspense”라고 한다. 아직은 React의 experimental, 즉 실험 버전에서만 사용할 수 있다.React Suspense for Data Fetching이 목표로 하는 코드는 간단하다. 쉽게 말해 async-await 급으로 비동기를 처리하면서 간단하고 읽기 편한 React 컴포넌트를 만들겠다고 하는 것이다. 다시 말해, 컴포넌트는 성공한 상태만 다루고, 로딩 상태와 에러 상태는 외부에 위임함으로써 동기적인 코드와 큰 차이가 없는 코드를 만들겠다는 비전이다.실제로 아래와 같이 FooBar 컴포넌트의 useAsyncValue를 동기적인 계산을 하는 useMemo로 거의 그대로 치환하면, 완벽히 똑같은 구조를 가지고 있는 것을 확인할 수 있다./* useAsyncValue 버전 */function FooBar() { const foo = useAsyncValue(() =&amp;gt; fetchFoo()); const bar = useAsyncValue(() =&amp;gt; fetchBar()); return &amp;lt;div&amp;gt;{foo}{bar}&amp;lt;/div&amp;gt;}/* useMemo 버전 */function FooBar() { const foo = useMemo(() =&amp;gt; fetchFoo()); const bar = useMemo(() =&amp;gt; fetchBar()); return &amp;lt;div&amp;gt;{foo}{bar}&amp;lt;/div&amp;gt;}React Suspense for Data Fetching은 이러한 useAsyncValue와 같은 hook을 만들 수 있는 Low-level API를 제공한다.만약에 비동기 작업을 아래와 같이 처리한다면, 로딩 상태나 에러 상태는 어떻게 처리해야 할까?&amp;lt;ErrorBoundary fallback={&amp;lt;MyErrorPage /&amp;gt;}&amp;gt; &amp;lt;Suspense fallback={&amp;lt;Loader /&amp;gt;}&amp;gt; &amp;lt;FooBar /&amp;gt; &amp;lt;/Suspense&amp;gt;&amp;lt;/ErrorBoundary&amp;gt;함수의 에러 처리를 감싸는 catch 문에서 하는 것처럼 로딩 상태와 에러 처리도 컴포넌트를 쓰는 곳에서 처리해주면 된다. 컴포넌트를 ‘쓰는 쪽’에서 로딩 처리와 에러를 처리한다. 로딩 상태는 가장 가까운 ‘Suspense’의 ‘Fallback’으로 그려진다. 에러 상태는 가장 가까운 ‘ErrorBoundary’가 componentDidCatch()로 처리한다.방금 작성한 ErrorBoundary/Suspense를 살펴보면 다음과 같은 코드와 거의 유사하다try { await fetchFooBar();} catch (error) { // 에러 처리}비동기 콜을 하는 함수나 컴포넌트가 가운데에 있고, 실패하는 경우를 처리하는 부분이 그 부분을 감싸고 있다.ex) ErrorBoundary 컴포넌트가 Suspense와 FooBar 컴포넌트를 감싸고 있음ex) 비동기 함수 fetchFooBar를 call하는 부분을 try…catch로 감싸고 있음우리가 모든 실패할 수 있는 함수에 try…catch를 감싸지 않는 것처럼, Suspense를 일으키는 모든 컴포넌트에 Suspense나 ErrorBoundary를 붙여주기보다는 적당한 부분 단위로 에러와 로딩 상태를 한 번에 처리하게 된다.예를 들어 아래 코드는 App 전체에서 로딩 상태와 에러 상태를 처리해주는 핸들러를 선언한 것이다.&amp;lt;ErrorBoundary fallback={&amp;lt;ErrorPage /&amp;gt;}&amp;gt; &amp;lt;Suspense fallback={&amp;lt;Loader /&amp;gt;}&amp;gt; &amp;lt;App /&amp;gt; &amp;lt;/Suspense&amp;gt;&amp;lt;/ErrorBoundary&amp;gt;이렇게 비동기를 동기적으로 바꿔주는 Suspense 기능을 이용하기는 전혀 어렵지 않다.사용하는 라이브러리에서 Suspense를 사용한다고 선언해주면 된다.Suspense 지원 라이브러리각 라이브러리에서 위와 같은 옵션을 사용하면 자동으로 컴포넌트의 Suspense 상태가 관리된다.React Suspense를 사용하면 로딩과 에러 처리를 바깥에 위임하여 비동기 작업을 동기와 똑같이 처리할 수 있었는데, React 팀의 Sebastian이 만들었던 코드 스니펫은 이런 ‘마법’이 어떻게 React에서 구현되어 있는지 보여준다./* React Team의 *Sebastian markbage*의 Proof-of-concept */function getUserName(id) { var user = JSON.parse(fetchTextSync(&#39;/users/&#39; + id); return user.name;}function getGreeting(name) { if (name === &#39;Seb&#39;) { return &#39;Hey&#39;; } return fetchTextSync(&#39;/greeting&#39;);}function getMessage() { let name = getUserName(123); return getGreeting(name) + &#39;, &#39; + name + &#39;!&#39;;}runPureTask(getMessage).then(message =&amp;gt; console.log(message));runPureTask로 실행시키면 비동기 함수도 동기적으로 작성할 수 있다.코드를 살펴보면 fetchTextSync라고 하는 함수는 원래 API 호출으로 비동기 작업이지만, 동기처럼 사용되고 있는 걸 볼 수 있다. 이 모든것을 가능하게 해주는 것은 runPureTask라고 하는 런타임이다.토스팀에서 적용한 제품 예시토스팀에서는 최근에 개발된 서비스 일부를 React Suspense를 활용해서 마이그레이션을 진행하고 있다. 사용 경험이 좋았는데, 대표적으로 적용된 제품은 토스팀의 TUBA라고 하는 제품이다.TUBATUBA 제품은 토스 대부분의 데이터가 모이고 분석되는 내부 제품이며, 다양한 A/B 테스트를 설정하거나, 알림이나 푸시를 전송하는 등 다양한 작업을 수행하고 있다.토스 앱에서 알림이나 푸시를 보낼 때 토스팀이 사용하는 제품이 바로 ‘TUBA 메신저’ 인데, TUBA 메신저의 메시지 상세 화면에서는 상당히 복잡한 비동기 처리가 필요했다.직관성을 떨어뜨리는 다양한 비동기 리소스API 호출로 가져와야 하는 부분들이 이렇게나 다양했다.어떤 메시지였는지, 메시지의 내용이 무엇인지, 발송 일정이 뭔지, 통계 정보가 어떻게 나왔는지 등 다양한 데이터를 복잡한 조건 하에 가져와야 하는 니즈가 있었다.토스는 이런 문제를 Recoil의 비동기 셀렉터를 이용해 해결할 수 있었다!Recoil에서는 비동기 리소스를 다음과 같이 selector 또는 selectorFamilty로 정의할 수 있다.export const templateSetSelector = selectorFamily({ key: &#39;@messages/template-set&#39;, get: (no: number) =&amp;gt; async () =&amp;gt; { return fetchTemplateSet(no); },});templateSetSelector는 no라고 하는 번호를 인자로 받아 fetchTemplateSet이라고 하는 비동기 호출을 보내는 것을 볼 수 있다.이렇게 정의한 비동기 리소스를 useRecoilValue를 이용해서 가져오려고 하면 Suspense가 발생하게 된다.function TemplateSetDetails({ templateSetNo }: Props) { const templateSet = useRecoilValue(templateSetSelector(templateSetNo)); /* 이 아래에서는 templateSet이 존재하는 것이 타입적으로 완전히 보장됨 */}&amp;lt;Suspense fallback={&amp;lt;Skeleton /&amp;gt;}&amp;gt; &amp;lt;TemplateSetDetails /&amp;gt;&amp;lt;/Suspense&amp;gt;이렇게 비동기 호출을 하는 컴포넌트를 적절히 Suspense로 감싸주기만 하면 된다.사용자 경험 측면에서도 데이터가 준비되는 대로 하나씩 자연스럽게 보여줄 수 있어 좋다고 할 수 있다.React Hooks와의 유사도React Suspense 덕분에 많은 비동기적인 문제를 깔끔하고 우아하게 처리할 수가 있게 되었고, 코드의 복잡도도 줄일 수 있었다.2년 반 정도 전에 나왔던 React Hooks는 이제 엄청 익숙하지만, 비슷한 역할을 해주고 있다.웹 서비스의 코드 복잡도를 줄여주고, 상태, 이펙트와 메모이제이션과 같이 자주 발생하는 작업들을 매우 쉽게 사용할 수 있게 해주었다.React HooksReact Hooks는 어떻게 토스팀 프로젝트 코드의 복잡도를 줄여주었을까?그 중 선언적인 API의 비중이 굉장히 컸다.이전의 클래스 컴포넌트에서는 컴포넌트의 라이프사이클에 맞춰 다양한 작업을 명령형으로 해주어야 했지만, Hooks를 사용하면서 상황이 달라졌다.useState로 상태를 사용한다고 선언하고, useMemo로 메모이제이션을 한다고 선언하고, useEffect로 효과를 발생시킨다고 선언했다. 이렇게 선언하기만 하면 React 프레임워크가 실제 작업을 대신해주었다.Suspense for Data FetchingSuspense도 비슷하다. 컴포넌트에서는 비동기적인 리소스를 선언하고, 그 값을 읽어온다고 선언하기만 한 것이다. 그러면 실제 로딩 상태나 에러 상태처리는 컴포넌트를 감싸는 부모 컴포넌트가 대신해주었다.또 비슷한 것이 있다. 바로 우리가 자주 사용하는 try…catch 문이다.기존 예외처리 방법실패할 수 있는 함수는 throw 문으로 에러를 발생시키고, 실제 에러 처리는 컴포넌트를 감싸는 부모 함수가 수행해주는 것이다.이렇게 어떤 코드 조각을 감싸는 맥락으로 책임을 분리하는 방식을 대수적 효과(Algebraic Effects)라고 한다. 객체지향의 의존성 주입(DI), 의존성 역전(IoC)과도 유사하다.대수적 효과를 지원하는 언어에서 함수는 필요한 코드 조각을 선언적으로 사용한다.예를 들면, 메모이제이션이 필요하면 useMemo를 호출하는 식이다. 그러면 실제로 관련된 처리는 함수를 감싸는 부모 함수나 런타임이 대신 처리하는 형식이 된다.하지 못한 이야기들 (React에서 사용자 경험을 더욱 향상시킬 수 있는 React 요소) React Concurrent Mode useTransition, useDeferredValue위 요소들을 사용한다면 React에서 컴포넌트 렌더 트리를 부분적으로만 완성함으로써 사용자 경험을 크게 향상시킬 수 있다.비동기 작업 뿐만이 아니라 Debounce 등으로 처리하던 무거운 동기적 작업에도 적용할 수 있다.Reference 토스ㅣSLASH 21 - 프론트엔드 웹 서비스에서 우아하게 비동기 처리하기 YouTube 데이터를 가져오기 위한 Suspense (실험 단계) (React Suspense for Data Fetching) Dan Abramov" } ]
